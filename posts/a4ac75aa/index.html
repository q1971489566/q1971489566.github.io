<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>板子基础总结 | 云落溪音</title><meta name="keywords" content="C++,算法"><meta name="author" content="云落溪音"><meta name="copyright" content="云落溪音"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="模板：常用算法、线性、树、图、搜索、数论、动态规划等"><meta property="og:type" content="article"><meta property="og:title" content="板子基础总结"><meta property="og:url" content="https://www.vulxin.top/posts/a4ac75aa/index.html"><meta property="og:site_name" content="云落溪音"><meta property="og:description" content="模板：常用算法、线性、树、图、搜索、数论、动态规划等"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/1971489/Images/P/2131660/69660140_p0.jpg"><meta property="article:published_time" content="2021-04-13T00:58:34.000Z"><meta property="article:modified_time" content="2021-05-01T05:33:49.865Z"><meta property="article:author" content="云落溪音"><meta property="article:tag" content="C++"><meta property="article:tag" content="算法"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/1971489/Images/P/2131660/69660140_p0.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/1971489/Images/Site/favicon.ico"><link rel="canonical" href="https://www.vulxin.top/posts/a4ac75aa/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.gstatic.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;500;700;900&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:{limitDay:365,position:"top",messagePrev:"距离上次更新已经过去",messageNext:"天了, 请注意内容的时效性"},highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"null",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"bottom-left"},source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!0,islazyload:!0,isanchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!0,isToc:!0,postUpdate:"2021-05-01 13:33:49"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));const n=saveToLocal.get("global-font-size");void 0!==n&&document.documentElement.style.setProperty("--global-font-size",n+"px")})(window)</script><link rel="stylesheet" href="/inject/custom.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><meta name="generator" content="Hexo 5.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/Site/avatar.jpg" onerror='onerror=null,src="/mimg/PokeBall_gray_small.PNG"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">63</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i> <span>文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></li><li><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></li><li><a class="site-page" href="/archives/"><i class="fa-fw fas fa-calendar-day"></i> <span>时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/essay/"><i class="fa-fw fas fa-feather-alt"></i> <span>随笔</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>推荐</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background:0 0"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">云落溪音</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i> <span>文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></li><li><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></li><li><a class="site-page" href="/archives/"><i class="fa-fw fas fa-calendar-day"></i> <span>时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/essay/"><i class="fa-fw fas fa-feather-alt"></i> <span>随笔</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>推荐</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">板子基础总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-04-13T00:58:34.000Z" title="发表于 2021-04-13 08:58:34">2021-04-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-01T05:33:49.865Z" title="更新于 2021-05-01 13:33:49">2021-05-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>42分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/a4ac75aa/#post-comment"><span class="waline-comment-count" id="/posts/a4ac75aa/"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>说明<ol><li>用C库中的输入输出更快。</li><li>1s的时间复杂度限制大约可以进行 $10^7$ 的运算，再根据输入数据的规模可以猜到应该使用什么复杂度的算法。</li><li>要用到的空间用类似于<code>constexpr int N = 1e5</code>的方法进行静态开辟。</li><li>同样根据数据规模确定<code>int</code>会不会溢出</li><li>命名规则都比较简洁，用自己喜欢的风格就行。</li></ol></li></ul><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>用两个数组，<code>e</code>， <code>ne</code>，头<code>h</code>，个数<code>idx</code>，第k个插入的数在k-1</p><ul><li><code>e[N]</code>：数组元素。<code>ne[N]</code>下一个元素的数组下标。</li><li>不添加额外的头节点，<code>h</code>：第一个节点的数组下标。</li><li>数组中的元素个数为<code>idx</code>，也是下一个可以用来存放新元素的数组下标</li></ul><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.acwing.com/problem/content/828/">单链表</a></p><p><em>注意题中的<code>k</code>是插入的第<code>k</code>个而不是从前向后遍历到的第<code>k</code>个。所以这里的<code>k-1</code>正好就是对应元素的数组下标</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>;<br><span class="hljs-keyword">int</span> e[N], ne[N], h, idx;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span>&#123;<br>    h = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 第一个节点</span><br>    idx = <span class="hljs-number">0</span>; <span class="hljs-comment">// 下一个存储位</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Head</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    e[idx] = x;<br>    ne[idx] = h;<br>    h = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    k--;<br>    e[idx] = x;<br>    ne[idx] = ne[k];<br>    ne[k] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span>&#123;<br>    k--;<br>    ne[k] = ne[ne[k]];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> M;<br>    <span class="hljs-keyword">char</span> op;<br>    <span class="hljs-keyword">int</span> k, x;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; M;<br>    Init();<br>    <span class="hljs-keyword">while</span>(M--)&#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; op;<br>        <span class="hljs-keyword">switch</span>(op)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;H&#x27;</span>:<br>                <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>                Head(x);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;D&#x27;</span>:<br>                <span class="hljs-built_in">cin</span> &gt;&gt; k;<br>                <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>)&#123;<br>                    h = ne[h]; <span class="hljs-comment">// 删除头部</span><br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    Delete(k);<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;I&#x27;</span>:<br>                <span class="hljs-built_in">cin</span> &gt;&gt; k &gt;&gt; x;<br>                Insert(k, x);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = h; i != <span class="hljs-number">-1</span>; i = ne[i])&#123; <span class="hljs-comment">// h开始，-1结束</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, e[i]);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.acwing.com/problem/content/829/">双链表</a></p><ul><li><code>e</code>：数组元素，<code>l</code>：左边的下标，<code>r</code>：右边的下标。加入额外的<code>头节点0</code>和<code>尾节点1</code>。第k个插入的数在<code>k+1</code>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span>;<br><br><span class="hljs-keyword">int</span> l[N], r[N], e[N], idx;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span>&#123;<br>    r[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 头-&gt;尾</span><br>    l[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 尾-&gt;头</span><br>    idx = <span class="hljs-number">2</span>; <span class="hljs-comment">// 下一个存储位</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InsertL</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123; <span class="hljs-comment">// 头插</span><br>    e[idx] = x; <span class="hljs-comment">// 存储</span><br>    l[idx] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 左指向头</span><br>    r[idx] = r[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 右指向第一个</span><br>    r[<span class="hljs-number">0</span>] = idx;<br>    l[r[idx]] = idx;<br>    idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InsertR</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123; <span class="hljs-comment">// 尾插</span><br>    e[idx] = x;<br>    l[idx] = l[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 左指向最后一个</span><br>    r[idx] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 右指向尾</span><br>    r[l[idx]] = idx;<br>    l[<span class="hljs-number">1</span>] = idx;<br>    idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span>&#123;<br>    k++;<br>    r[l[k]] = r[k];<br>    l[r[k]] = l[k];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InsertKL</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    k++;<br>    e[idx] = x;<br>    l[idx] = l[k];<br>    r[idx] = k;<br>    r[l[idx]] = idx;<br>    l[k] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InsertKR</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    k++;<br>    e[idx] = x;<br>    l[idx] = k;<br>    r[idx] = r[k];<br>    l[r[idx]] = idx;<br>    r[k] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> M, k, x;<br>    <span class="hljs-built_in">string</span> s;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; M;<br>    Init();<br>    <span class="hljs-keyword">while</span>(M--)&#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; s;<br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;L&quot;</span>)&#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>            InsertL(x);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;R&quot;</span>)&#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>            InsertR(x);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;D&quot;</span>)&#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; k;<br>            Delete(k);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;IL&quot;</span>)&#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; k &gt;&gt; x;<br>            InsertKL(k, x);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; k &gt;&gt; x;<br>            InsertKR(k, x);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = r[<span class="hljs-number">0</span>]; i != <span class="hljs-number">1</span>; i = r[i])&#123; <span class="hljs-comment">// r[0]开始，1结束</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, e[i]);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><ul><li><code>stk</code>：栈。 <code>e</code>：栈中元素在原序列中的下标。 <code>tt</code>：栈顶元素下标，0号不存。</li><li><code>q</code>：队列。<code>hh</code>：队头。 <code>tt</code>：队尾。</li></ul><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.luogu.com.cn/problem/P5788">单调栈</a></p><p>从后向前扫描，比较栈顶，如果大则就是后面最靠近的大数，否则一直出栈，如果空，则表明后面没有大的数，结果为0（结果保存在数组<code>q</code>中，要逆序输出）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">3000000</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> stk[N], e[N], tt, a[N], q[N], qq;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">while</span> (tt &amp;&amp; stk[tt] &lt;= a[i]) &#123; <span class="hljs-comment">// 将小的都出栈</span><br>            tt--;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (tt == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 栈空，没有大的</span><br>            q[qq++] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 结果为0</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            q[qq++] = e[tt]; <span class="hljs-comment">// 否则就是 对应元素的下标</span><br>        &#125;<br>        stk[++tt] = a[i]; <span class="hljs-comment">// 将这个元素也入栈</span><br>        e[tt] = i; <span class="hljs-comment">// 同时保存其原下标</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = qq - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123; <span class="hljs-comment">// 逆序输出</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, q[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.acwing.com/file_system/file/content/whole/index/content/118289/">Trie字符统计</a></p><p><code>p[N][27]</code>：保存下一个节点在数组中的下标，根为<code>p[0]</code>，每个节点可以保存26个字母，从而保存一系列字符串，对应字符串最后一节点加标记。<code>cnt[N]</code>记录每个节点对应字符串出现次数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> p[N][<span class="hljs-number">27</span>], cnt[N], idx = <span class="hljs-number">1</span>; <span class="hljs-comment">// idx为下一个可存储节点的数组下标</span><br><span class="hljs-keyword">char</span> s[N]; <span class="hljs-comment">// 输入的字符串</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; s[i]; i++) &#123;<br>        <span class="hljs-keyword">int</span> u = s[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (p[j][u] == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 没有存储这个字符</span><br>            p[j][u] = idx++; <span class="hljs-comment">// “开辟新节点”以表示存储(u对应存到idx)</span><br>        &#125;<br>        j = p[j][u]; <span class="hljs-comment">// 进入到下一个节点</span><br>    &#125;<br>    cnt[j]++; <span class="hljs-comment">// 到最后一个字符节点之后添加标记</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; s[i]; i++) &#123;<br>        <span class="hljs-keyword">int</span> u = s[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (p[j][u] == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 字符串中这个字符未被存储</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 就不存在这个字符串</span><br>        &#125;<br>        j = p[j][u];<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt[j]; <span class="hljs-comment">// 返回标记值（累积存储字符串次数）</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">char</span> op[<span class="hljs-number">2</span>];<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">while</span> (n--) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%s&quot;</span>, op, s); <span class="hljs-comment">// op中有&#x27;\0&#x27;所以要%s而不是%c</span><br>        <span class="hljs-keyword">if</span> (op[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;I&#x27;</span>) &#123;<br>            Add(s);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, Find(s));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="快速排序模板"><a href="#快速排序模板" class="headerlink" title="快速排序模板"></a>快速排序模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> arr[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> x = arr[l+((r-l)&gt;&gt;<span class="hljs-number">1</span>)], i = l<span class="hljs-number">-1</span>, j = r+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(arr[i] &lt; x); <span class="hljs-comment">// 不会越界，因为最多到达x，会因为相等而停下</span><br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(arr[j] &gt; x);<br>        <span class="hljs-keyword">if</span>(i &lt; j) swap(arr[i], arr[j]);<br>    &#125;<br>    QuickSort(l, j);<br>    QuickSort(j+<span class="hljs-number">1</span>, r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, arr+i);<br>    &#125;<br>    QuickSort(<span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, arr[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通常还是用<code>&lt;algorithm&gt;</code>中的<code>std::sort()</code>，如果要从大到小排：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br>...<br>sort(arr, arr+n, cmp);<br></code></pre></td></tr></table></figure><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><p>扫描一遍并保存在<code>S</code>中之后，快速求指定范围的和</p><p>递归公式：（0号下标保持为0，这样不会溢出）</p><ul><li><p>一维数组递推：<script type="math/tex">S_i=S_{i-1}+a_i</script></p><p>快速求指定范围数组和：<script type="math/tex">Sum_{i,j}=S_j-S_{i-1}</script></p></li><li><p>二维数组递推：<script type="math/tex">S_{i,j}=S_{i-1,j}+S_{i,j-1}-S_{i-1,j-1}+a_{i,j}</script></p><p>快速求指定两点之间形成的矩形：<script type="math/tex">Sum_{(x,y),(i,j)}=S_{i,j}-S_{x-1,j}-S_{i,y-1}+S_{x-1,y-1}</script></p><p><em>边界部分要根据题意取舍</em></p></li></ul><p><strong>注意：如果要求的范围超出原数组，则结果是整个数组的和</strong></p><p>为了优化空间，实际<code>Sum</code>和<code>S</code>共用一个数组</p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.acwing.com/problem/content/description/101/">激光炸弹</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">5000</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> f[N][N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n, r;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; r;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        <span class="hljs-keyword">int</span> x, y, w;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;w);<br>        f[x+<span class="hljs-number">1</span>][y+<span class="hljs-number">1</span>] += w; <span class="hljs-comment">// 0号不存</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; N; j++)&#123; <span class="hljs-comment">// 求前缀和</span><br>            f[i][j] = f[i<span class="hljs-number">-1</span>][j] + f[i][j<span class="hljs-number">-1</span>] - f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + f[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(r &gt;= N)&#123; <span class="hljs-comment">// 涵盖原数组</span><br>        ans = f[N<span class="hljs-number">-1</span>][N<span class="hljs-number">-1</span>];<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = r; i &lt; N; i++)&#123; <span class="hljs-comment">// 从r开始遍历，1.防越界，2.避免不必要的搜索</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = r; j &lt; N; j++)&#123;<br>                <span class="hljs-comment">// x=i-r+1，画图易得</span><br>                ans = max(ans, f[i][j] - f[i-r][j] - f[i][j-r] + f[i-r][j-r]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><p>相邻两项之差（0号下标恒为0）</p><p>递推：<script type="math/tex">b_i=a_i-a_{i-1}</script></p><p>用于快速将指定范围内的数加上同一个数<code>c</code>：<script type="math/tex">b_l += c; b_{r+1} -= c</script></p><p>(<script type="math/tex">b_l=a_l-a_{l-1}, b_{l+1}=a_{l+1}-a_l...b_{r+1}=a_{r+1}-a_{r}</script>刚好中间的都消掉了，只需要改变首尾)</p><p>改变之后的原数组元素：<script type="math/tex">a_i=\sum_{1}^{i}b_i</script>，用一个数累加即可。</p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.acwing.com/problem/content/799/">差分</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> b[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n, m;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, b+i);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n; i &gt;= <span class="hljs-number">2</span>; i--)&#123;<br>        b[i] -= b[i<span class="hljs-number">-1</span>];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-keyword">int</span> l, r, c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;c);<br>        b[l] += c;<br>        b[r+<span class="hljs-number">1</span>] -= c;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, a = <span class="hljs-number">0</span>; i &lt;= n; i++)&#123;<br>        a += b[i];<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>两种方法，结合可用来查找相同值所在的范围（而不是只查找一个）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> t)</span> </span>&#123; <span class="hljs-comment">// 第一个t</span><br>    <span class="hljs-keyword">if</span> (l &gt; r) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (arr[mid] &lt; t) l = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> r = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> t)</span> </span>&#123; <span class="hljs-comment">// 最后一个t</span><br>    <span class="hljs-keyword">if</span> (l &gt; r) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (arr[mid] &gt; t) r = mid - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br>...<br><span class="hljs-keyword">int</span> arr[] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span> ,<span class="hljs-number">3</span> ,<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span> ,<span class="hljs-number">5</span> &#125;;<br><span class="hljs-built_in">cout</span> &lt;&lt; Find1(arr, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>) &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 3 第一个在3</span><br><span class="hljs-built_in">cout</span> &lt;&lt; Find2(arr, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>) &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 5 最后一个在5</span><br></code></pre></td></tr></table></figure><h3 id="其他应用"><a href="#其他应用" class="headerlink" title="其他应用"></a>其他应用</h3><ul><li>解立方根</li></ul><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.acwing.com/problem/content/792/">数的三次方根</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">double</span> n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">double</span> l = <span class="hljs-number">-10000</span>, r = <span class="hljs-number">10000</span>;<br>    <span class="hljs-keyword">while</span>(r-l &gt; <span class="hljs-number">1e-7</span>)&#123; <span class="hljs-comment">// 1e-6精度不足</span><br>        <span class="hljs-keyword">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(mid * mid * mid &lt; n) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid;<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.6f&quot;</span>, l);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="搜索问题答案"><a href="#搜索问题答案" class="headerlink" title="搜索问题答案"></a>搜索问题答案</h3><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.acwing.com/problem/content/description/104/">最佳牛围栏</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100005</span>;<br><span class="hljs-keyword">int</span> cows[N]; <span class="hljs-keyword">double</span> sum[N];<br><span class="hljs-keyword">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">double</span> avg)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        sum[i] = sum[i - <span class="hljs-number">1</span>] + (cows[i] - avg); <span class="hljs-comment">//计算前缀和(与均值之差)</span><br>    &#125;<br><br>    <span class="hljs-keyword">double</span> minv = <span class="hljs-number">0</span>; <span class="hljs-comment">//设置最小值(圈地范围前面的)</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = m; j &lt;= n; j++, i++) &#123; <span class="hljs-comment">// 圈地为i+1~j(共m块)</span><br>        minv = <span class="hljs-built_in">std</span>::min(minv, sum[i]); <span class="hljs-comment">//找最优极小值(与均值之差的累积)</span><br>        <span class="hljs-keyword">if</span>(sum[j] - minv &gt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//进行判断(从最小值那里到j区间中的均值&gt;=avg)</span><br>        								 <span class="hljs-comment">// 	avg小了</span><br>    &#125; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//如果所有的都不满足，那么这个平均数就一定不满足(avg大了)</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m); <span class="hljs-comment">// 共n块地，至少围m块地</span><br>    <span class="hljs-keyword">double</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123; <span class="hljs-comment">//最小左区间 最大右区间</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;cows[i]); <br>        r = <span class="hljs-built_in">std</span>::max(r, (<span class="hljs-keyword">double</span>)cows[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(r - l &gt; <span class="hljs-number">1e-5</span>) &#123; <span class="hljs-comment">//开始二分 因为是实数所以这里还搞个精度</span><br>        <span class="hljs-keyword">double</span> mid = (l + r) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 不是&gt;&gt;1 这里是实数</span><br>        <span class="hljs-keyword">if</span>(check(mid)) l = mid; <span class="hljs-comment">//将问题转变为判定问题</span><br>        <span class="hljs-keyword">else</span> r = mid;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, (<span class="hljs-keyword">int</span>)(r * <span class="hljs-number">1000</span>)); <span class="hljs-comment">//因为我们找的极大值 所以要右端点*1000 否则可能会出错</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="二进制运算"><a href="#二进制运算" class="headerlink" title="二进制运算"></a>二进制运算</h2><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>&amp;, |, ^, ~, &lt;&lt;, &gt;&gt;</p><ol><li>第k位(最低位为第0位)：<code>x &gt;&gt; k &amp; 1</code></li><li>从右向左第一个1：<code>x &amp; -x</code></li></ol><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// a^b % p</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> p)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(b)&#123;<br>        <span class="hljs-keyword">if</span>(b &amp; <span class="hljs-number">1</span>)&#123;<br>            res = (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)res * a % p;<br>        &#125;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>        a = (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)a * a %p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>快速判断集合合并以及判断两元素是否属于同一集合。用一个数组实现（保存其所在集合中的父），类似一棵树。</p><p>如果是二维则通过换算坐标转换成一维数组。</p><p>如果要统计集合中的总数，另设一个数组，合并时合并集合中的总个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> p[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a != p[a]) p[a] = find(p[a]); <span class="hljs-comment">// 路径压缩</span><br>    <span class="hljs-keyword">return</span> p[a];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> m, n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123; <span class="hljs-comment">// 初始化为每个集合一个</span><br>        p[i] = i;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-keyword">char</span> op[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%d%d&quot;</span>, op, &amp;a, &amp;b);<br>        <span class="hljs-keyword">if</span>(op[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;M&#x27;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(find(a) != find(b))&#123;<br>                p[find(a)] = find(b); <span class="hljs-comment">// 集合合并(合并根)</span><br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(find(a) == find(b))&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="DFS-amp-BFS"><a href="#DFS-amp-BFS" class="headerlink" title="DFS &amp; BFS"></a>DFS &amp; BFS</h2><p>DFS，栈或递归，回溯</p><h3 id="n皇后"><a href="#n皇后" class="headerlink" title="n皇后"></a>n皇后</h3><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.acwing.com/problem/content/845/">n-皇后问题</a></p><p>不能同行，同列，同斜线</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">char</span> mp[N][N]; <span class="hljs-comment">// 棋盘</span><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">bool</span> col[N], g[<span class="hljs-number">2</span>*N], ug[<span class="hljs-number">2</span>*N]; <span class="hljs-comment">// 判断同列，同斜线(2N条!)，同反斜线（由于按行遍历，不需要增加行的）</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span>&#123; <span class="hljs-comment">// 枚举到第u行(共0~n-1行)</span><br>    <span class="hljs-keyword">if</span>(n == u)&#123; <span class="hljs-comment">// 一个完整的方案</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, mp[i]); <span class="hljs-comment">// 有0，所以可当字符串输出</span><br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ;i &lt; n; i++)&#123; <span class="hljs-comment">// 当前行u，遍历可能的列（0~n-1）</span><br>        <span class="hljs-keyword">if</span>(col[i] || g[i+u] || ug[n+u-i])&#123; <span class="hljs-comment">// 以左上角建坐标，同斜线的x+y相同</span><br>            <span class="hljs-keyword">continue</span>;					 <span class="hljs-comment">// 同反斜线的x-y相同(防止负数，统一加n)</span><br>        &#125;<br>        col[i] = g[i+u] = ug[n+u-i] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记</span><br>        mp[u][i] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>        dfs(u+<span class="hljs-number">1</span>); <span class="hljs-comment">// 放下一行</span><br>        col[i] = g[i+u] = ug[n+u-i] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 回溯</span><br>        mp[u][i] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i= <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n ; j++)&#123;<br>            mp[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>; <span class="hljs-comment">// 初始化</span><br>        &#125;<br>    &#125;<br>    dfs(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>BFS</p><p>队列，最短路径(权值相同)</p><h3 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h3><p>n*m的二维数组，0可走，1不可走。从左上角(0,0)开始，可以按上下左右移动，到达(n-1,m-1)最少需要移动多少次？((0,0)和(n-1,m-1)处数字必为0，且至少有一条路，数据规模1~100)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">110</span>;<br><br><span class="hljs-keyword">int</span> qx[N*N], qy[N*N]; <span class="hljs-comment">// 队列</span><br><span class="hljs-keyword">int</span> n, m, dd, tt=<span class="hljs-number">-1</span>; <span class="hljs-comment">// dd, tt为队头队尾</span><br><br><span class="hljs-keyword">int</span> mp[N][N], d[N][N]; <span class="hljs-comment">// 地图，距离（-1为没有走过）</span><br><br><span class="hljs-keyword">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<br>    qx[++tt] = <span class="hljs-number">0</span>; qy[tt] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 入队</span><br>    d[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(dd &lt;= tt)&#123; <span class="hljs-comment">// 队列非空</span><br>        <span class="hljs-keyword">int</span> x = qx[dd], y = qy[dd++]; <span class="hljs-comment">// 出队</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt; <span class="hljs-number">4</span>;i++)&#123;<br>            <span class="hljs-keyword">int</span> ix=x+dx[i], iy=y+dy[i];<br>            <span class="hljs-comment">// 越界，走过，不可走</span><br>            <span class="hljs-keyword">if</span>(ix&lt;<span class="hljs-number">0</span>||iy&lt;<span class="hljs-number">0</span>|| ix&gt;=n||iy&gt;=m || d[ix][iy]!=<span class="hljs-number">-1</span> || mp[ix][iy]==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            qx[++tt]=ix; qy[tt]=iy; <span class="hljs-comment">// 入队</span><br>            d[ix][iy]=d[x][y]+<span class="hljs-number">1</span>; <span class="hljs-comment">// 到起点的距离（步数）</span><br>            <span class="hljs-keyword">if</span>(ix==n<span class="hljs-number">-1</span>&amp;&amp;iy==m<span class="hljs-number">-1</span>)&#123; <span class="hljs-comment">// 已到达终点，那么这就是最小值！</span><br>                <span class="hljs-keyword">return</span> d[ix][iy]; <span class="hljs-comment">// 广度搜索，之后的路径距离更大</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j &lt; m;j++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, mp[i]+j);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d); <span class="hljs-comment">// 初始化为没有走过（距离-1）</span><br>    					   <span class="hljs-comment">// 只能初始化字节相同的int，如0，-1，0x3f3f3f3f,0x7f7f7f7f</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; bfs();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中队列可以用STL的<code>push</code>,<code>front</code>,<code>pop</code>,<code>size</code>,<code>empty</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-keyword">int</span> x, y;<br>&#125;Node;<br><br>q.push(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;); <span class="hljs-comment">// 临时结构体</span><br></code></pre></td></tr></table></figure><h3 id="八数码"><a href="#八数码" class="headerlink" title="八数码"></a>八数码</h3><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.acwing.com/problem/content/847/">八数码</a></p><p>保存网格状态：用<code>string</code></p><p>网格状态对应交换的次数：用<code>map&lt;string, int&gt;</code>，<code>map.count</code>判断状态不重复</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-built_in">string</span> start;<span class="hljs-comment">// 初始状态</span><br><span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; d; <span class="hljs-comment">// 用map会超时</span><br><br><span class="hljs-keyword">int</span> dx[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span> &#125;;<br><span class="hljs-keyword">int</span> dy[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span> &#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-built_in">string</span>&gt; q;<br>    q.push(start); <span class="hljs-comment">// 初始入队</span><br>    d[start] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 移动了0步</span><br>    <span class="hljs-keyword">while</span> (!q.empty()) &#123;<br>        <span class="hljs-built_in">string</span> t = q.front(); <span class="hljs-comment">// 取出一个状态</span><br>        q.pop();<br>        <span class="hljs-keyword">int</span> x, y; <span class="hljs-comment">// 此状态中&#x27;x&#x27;坐标</span><br>        <span class="hljs-keyword">int</span> id = d[t]; <span class="hljs-comment">// 此状态已经交换的次数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (t[i] == <span class="hljs-string">&#x27;x&#x27;</span>) &#123;<br>                x = i / <span class="hljs-number">3</span>;<br>                y = i % <span class="hljs-number">3</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123; <span class="hljs-comment">// 尝试四个方向</span><br>            <span class="hljs-keyword">int</span> ix = x + dx[i], iy = y + dy[i];<br>            <span class="hljs-keyword">if</span> (ix &lt; <span class="hljs-number">0</span> || ix&gt;<span class="hljs-number">2</span> || iy &lt; <span class="hljs-number">0</span> || iy&gt;<span class="hljs-number">2</span>) &#123; <span class="hljs-comment">// 越界</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            swap(t[x * <span class="hljs-number">3</span> + y], t[ix * <span class="hljs-number">3</span> + iy]); <span class="hljs-comment">// 将x与下一步的格子交换，进入下一个状态</span><br>            <span class="hljs-keyword">if</span> (d.count(t)) &#123; <span class="hljs-comment">// 状态存在过</span><br>                swap(t[x * <span class="hljs-number">3</span> + y], t[ix * <span class="hljs-number">3</span> + iy]);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            q.push(t); <span class="hljs-comment">// 入队</span><br>            d[t] = id + <span class="hljs-number">1</span>; <span class="hljs-comment">// 计算距离</span><br>            <span class="hljs-keyword">if</span> (t == <span class="hljs-string">&quot;12345678x&quot;</span>) &#123; <span class="hljs-comment">// 已结束</span><br>                <span class="hljs-keyword">return</span> d[t];<br>            &#125;<br>            swap(t[x * <span class="hljs-number">3</span> + y], t[ix * <span class="hljs-number">3</span> + iy]); <span class="hljs-comment">// 因为四个方向的尝试共用一个string，要记得恢复</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 没有路径</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> ch;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c &quot;</span>, &amp;ch); <span class="hljs-comment">// 输入有空格</span><br>        start += ch;<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; bfs() &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果不能使用<code>unordered_map</code>，使用<code>map</code>会超时,需要手动哈希</p><h4 id="手动映射-康托展开"><a href="#手动映射-康托展开" class="headerlink" title="手动映射-康托展开"></a>手动映射-康托展开</h4><p>对于全排列的哈希，可以使用<code>康托展开</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> fac[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">24</span>,<span class="hljs-number">120</span>,<span class="hljs-number">720</span>,<span class="hljs-number">5040</span>,<span class="hljs-number">40320</span>,<span class="hljs-number">362880</span>&#125;;<br><span class="hljs-comment">//         0!1!2!3! 4! 5!  6!  7!   8!    9!</span><br><span class="hljs-comment">// 将一个全排列映射到其在所有排列中的次序</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cantor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s[])</span></span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++)&#123;<br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">// 小于当前位的个数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">9</span>; j++)&#123;<br>            <span class="hljs-keyword">if</span>(s[j] &lt; s[i]) cnt++;<br>        &#125;<br>        sum += (cnt * fac[<span class="hljs-number">9</span>-i<span class="hljs-number">-1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum+<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">decantor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v;  <span class="hljs-comment">// 存放当前可选数</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; a;  <span class="hljs-comment">// 所求排列组合</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        v.push_back(i);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> r = x % FAC[i<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">int</span> t = x / FAC[i<span class="hljs-number">-1</span>];<br>        x = r;<br>        sort(v.begin(),v.end());<span class="hljs-comment">// 从小到大排序</span><br>        a.push_back(v[t]);      <span class="hljs-comment">// 剩余数里第t+1个数为当前位</span><br>        v.erase(v.begin()+t);   <span class="hljs-comment">// 移除选做当前位的数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>另一种理解是变进制数，也就是转换成十进制时，<code>i</code>位的权值为<code>i!</code></p><p>9位字符串排列共<code>9!</code>个，而</p><script type="math/tex;mode=display">1\times1!+2\times2!+...+8\times8! \\
= 1+1\times1!+2\times2!+...+8\times8!-1 \\
= 2!+2\times2!+3\times3!+...+8\times8!-1 \\
=...
= 9!-1</script><p>所以变进制数恰好可以映射所有的字符串排列</p><p>首先用数组d统计每个数字前比其大的数字个数，分别对应权值<code>0!~8!</code>加权求和</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> f[<span class="hljs-number">10</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span>&#123;<br>    f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">9</span>; i++)&#123;<br>        f[i] = f[i<span class="hljs-number">-1</span>] * i;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Hash</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++)&#123;<br>        <span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>            <span class="hljs-keyword">if</span>(s[j] &gt; s[i]) col++;<br>        &#125;<br>        sum += f[i] * col; <span class="hljs-comment">// f[i] = i!</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>将字符串映射到<code>int</code>之后就可以用大小为9!=362880的数组保存对应状态的距离值，从而代替<code>unordered_map</code></p><h2 id="树与图的搜索"><a href="#树与图的搜索" class="headerlink" title="树与图的搜索"></a>树与图的搜索</h2><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>用邻接表（多个单链表）：<code>h[N]</code>是各个头节点，<code>e[N]</code>为元素，<code>ne</code>,<code>idx</code>与单链表定义相同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> h[N], e[N*<span class="hljs-number">2</span>], ne[N*<span class="hljs-number">2</span>], idx;<br><span class="hljs-keyword">bool</span> st[N]; <span class="hljs-comment">// 遍历过</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123; <span class="hljs-comment">// 添加一条边a-&gt;b</span><br>    e[idx] = b, ne[idx] = h[a], h[a] = idx++; <span class="hljs-comment">// 将这条边头插入a的邻接链表</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123; <span class="hljs-comment">// u当前节点，遍历其邻接链表</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>        <span class="hljs-keyword">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (st[j]) <span class="hljs-keyword">continue</span>;<br>        st[j] = <span class="hljs-literal">true</span>;<br>        dfs(j);<br>        st[j] = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="树的重心"><a href="#树的重心" class="headerlink" title="树的重心"></a>树的重心</h3><p>一棵树，n个节点（1~n），n-1条无向边，树的重心为：删除这个节点后，剩余各个连通块中节点数的最大值最小。找到其重心并输出删除重心之后剩余各个连通块中节点数的最大值。</p><p>输入n和n-1条边</p><p>遍历树，逐个尝试删除每个节点，其删除后的连通块为左子树、右子树和其余的，其中其余的可以通过n-左子树-右子树-1来算出。</p><p>这里的树可以看成是只有无向边的图，左右孩子就是其两个邻接节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n; <span class="hljs-comment">// 总节点数</span><br><span class="hljs-keyword">int</span> g[N]; <span class="hljs-comment">// 其余连通分支的节点最大数</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123; <span class="hljs-comment">// u当前节点，遍历其邻接链表，这里是左右孩子</span><br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">1</span>; <span class="hljs-comment">// 当前节点及其子树节点数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>        <span class="hljs-keyword">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (st[j]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//st[j] = true; // 因为遍历的是树，没有环，不会重复遍历节点</span><br>        <span class="hljs-keyword">int</span> col = dfs(j); <span class="hljs-comment">// col 累积左右孩子节点数</span><br>        <span class="hljs-keyword">if</span> (col &gt; g[u]) g[u] = col;<br>        sum += col;<br>        <span class="hljs-comment">//st[j] = false;</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (g[u] &lt; n - sum) g[u] = n - sum; <span class="hljs-comment">// 剩余节点数</span><br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123; <span class="hljs-comment">// n-1条边</span><br>        <span class="hljs-keyword">int</span> a, b;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b;<br>        add(a, b); <span class="hljs-comment">// 为了在邻接表中存储无向边，同时保存两有向边即可</span><br>        add(b, a);<br>    &#125;<br>    st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>    dfs(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">int</span> Min = <span class="hljs-number">0x3f3f3f3f</span>;<br>    <span class="hljs-comment">// 遍历g，得到Min</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>优化：改用一个Min全局记录，省去g数组。</p><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>有向无环图，BFS计算每个节点的入度。每去掉一个节点，就将其指向的每个节点的入度—，然后将其下入度为0的节点加入队列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> d[N]; <span class="hljs-comment">// 每个节点的入度</span><br><span class="hljs-keyword">int</span> q[N], dd, tt; <span class="hljs-comment">// 队列，队头，队尾</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">int</span> b;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; b &amp;&amp; b) &#123;<br>            add(i, b);<br>            d[b]++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (d[i] == <span class="hljs-number">0</span>) q[++tt] = i;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (dd &lt;= tt) &#123;<br>        <span class="hljs-keyword">int</span> t = q[dd++];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>            <span class="hljs-keyword">int</span> j = e[i];<br>            d[j]--;<br>            <span class="hljs-keyword">if</span> (d[j] == <span class="hljs-number">0</span>) q[++tt] = j;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123; <span class="hljs-comment">// 输出队列</span><br>        <span class="hljs-built_in">cout</span> &lt;&lt; q[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h3 id="无负权边"><a href="#无负权边" class="headerlink" title="无负权边"></a>无负权边</h3><h4 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h4><p>普通版</p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.acwing.com/problem/content/851/">Dijkstra求最短路</a></p><p>在还没有确定最短距离的点中选择dist最小的点，用它更新相邻且未确定的点的dist</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">510</span>;<br><br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> g[N][N], dist[N]; <span class="hljs-comment">// g为邻接矩阵，dist为距离起点的最短距离</span><br><span class="hljs-keyword">bool</span> st[N]; <span class="hljs-comment">//是否已经确定</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> t = n + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; dist[t] &gt; dist[j]) t = j; <span class="hljs-comment">// 找到未确定且距离最小的</span><br>        &#125;<br>        st[t] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; dist[t] + g[t][j] &lt; dist[j]) dist[j] = dist[t] + g[t][j]; <span class="hljs-comment">// 更新剩余点</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 路径不存在</span><br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> g);<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-keyword">int</span> x, y, z;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; z;<br>        <span class="hljs-keyword">if</span> (g[x][y] &gt; z) g[x][y] = z; <span class="hljs-comment">// 因为输入可能有重边，临界矩阵只保存最短的</span><br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; Dijkstra() &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>用邻接表更快</p><p><strong>堆优化</strong></p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.acwing.com/problem/content/852/">Dijkstra求最短路II</a></p><p>改用优先队列作为小顶堆，同时由于数据过大，不能用邻接矩阵，只能用邻接表存储。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PII pair<span class="hljs-meta-string">&lt;int, int&gt;</span></span><br>...<br><span class="hljs-comment">// 初始</span><br><span class="hljs-built_in">priority_queue</span>&lt;PII, <span class="hljs-built_in">vector</span>&lt;PII&gt;, greater&lt;PII&gt; &gt;Heap; <span class="hljs-comment">// 小顶堆，按照pair第一个元素排，注意写成&gt;&gt;可能编译错误</span><br>Heap.push(&#123; <span class="hljs-number">0</span>,<span class="hljs-number">1</span> &#125;); <span class="hljs-comment">// &#123;dist, id&#125;</span><br><br><span class="hljs-comment">// 之后取dist最小元素操作</span><br>PII t = Heap.top();<br>Heap.pop();<br><span class="hljs-keyword">int</span> id = t.second, d = t.first;<br><br><span class="hljs-comment">// 更新距离操作</span><br>dist[k] = d + w[j]; <span class="hljs-comment">// 为了方便遍历，仍需要dist数组</span><br>Heap.push(&#123;dist[k], k&#125;); <span class="hljs-comment">// 而原来的pair会因为dist较大而沉下（不需要删掉）</span><br></code></pre></td></tr></table></figure><h3 id="有负权边"><a href="#有负权边" class="headerlink" title="有负权边"></a>有负权边</h3><h4 id="Bellman-ford"><a href="#Bellman-ford" class="headerlink" title="Bellman-ford"></a>Bellman-ford</h4><p>只有当含有负权边并且题中指定了固定步数k时才可以使用</p><p>只保存图中的边，还需要备份dist的backup数组，与Dijkstra不同之处在于更新操作使用的是backup数组，</p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.acwing.com/problem/content/855/">有边数限制的最短路</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">int</span> dist[<span class="hljs-number">550</span>], bak[<span class="hljs-number">550</span>], n, m, k;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">N</span> &#123;</span><br>    <span class="hljs-keyword">int</span> a, b, c;<br>&#125;Ns[<span class="hljs-number">10010</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>        <span class="hljs-built_in">memcpy</span>(bak, dist, <span class="hljs-keyword">sizeof</span> dist);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-keyword">int</span> a = Ns[j].a, b = Ns[j].b, c = Ns[j].c;<br>            <span class="hljs-keyword">if</span> (bak[a] + c &lt; dist[b]) dist[b] = bak[a] + c; <span class="hljs-comment">// 使用bak更新</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dist[n] &gt; <span class="hljs-number">0x3f3f3f3f</span> / <span class="hljs-number">2</span>) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt; dist[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">int</span> a, b, c;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        Ns[i] = &#123; a,b,c &#125;;<br>    &#125;<br>    bellman_ford();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h4><p>类似于BFS，起点入队，一个点的dist被更新时，如果没有在队列里，则入队列。</p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.acwing.com/problem/content/853/">spfa求最短路</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> n, m, e[N], ne[N], h[N], w[N], idx, dist[N];<br><span class="hljs-keyword">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>    e[idx] = b; ne[idx] = h[a];<br>    w[idx] = c; h[a] = idx++; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;q;<br>    q.push(<span class="hljs-number">1</span>);<br>    st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span> (q.size()) &#123;<br>        <span class="hljs-keyword">int</span> t = q.front();<br>        q.pop();<br>        st[t] = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123; <span class="hljs-comment">// 更新t的相邻点</span><br>            <span class="hljs-keyword">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i]) &#123;<br>                dist[j] = dist[t] + w[i];<br>                <span class="hljs-keyword">if</span> (!st[j]) &#123;<br>                    q.push(j);<br>                    st[j] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 在队列中</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dist[n] &gt; <span class="hljs-number">0x3f3f3f3f</span> / <span class="hljs-number">2</span>) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt; dist[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">int</span> a, b, c;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        add(a, b, c);<br>    &#125;<br>    spfa();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>判断是否有负权回路</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> cnt[N];<br>...<br>    <span class="hljs-comment">// 开始时将所有点入队列</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)&#123;<br>        q.push(i);<br>        st[i] = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i]) &#123;<br>        dist[j] = dist[t] + w[i];<br>        cnt[j] = cnt[t] + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (cnt[j] &gt; n - <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 存在负权回路</span><br><br>    	&#125;<br></code></pre></td></tr></table></figure><h3 id="多源点"><a href="#多源点" class="headerlink" title="多源点"></a>多源点</h3><p>Floyd</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2e2</span> + <span class="hljs-number">5</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">int</span> g[N][N], n, m, k;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (i == j) g[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> g[i]][j] = INF;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-keyword">int</span> a, b, c;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        <span class="hljs-keyword">if</span> (g[a][b] &gt; c) &#123;<br>            g[a][b] = c;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (g[i][j] &gt; g[i][k] + g[k][j]) &#123;<br>                    g[i][j] = g[i][k] + g[k][j];<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (k--) &#123;<br>        <span class="hljs-keyword">int</span> x, y;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; x &gt;&gt; y;<br>        <span class="hljs-keyword">if</span> (g[x][y] &gt; INF / <span class="hljs-number">2</span>) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt; g[x][y] &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><h4 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h4><p>适用于点远少于边，找到集合外dist最小的，更新其他点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Prim</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (dist[t] &gt; dist[j] || t == <span class="hljs-number">-1</span>)) &#123;<br>                t = j;<br>            &#125;<br>        &#125;<br>        st[t] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (i) &#123;<br>            res += dist[t];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &amp;&amp; dist[t] == <span class="hljs-number">0x3f3f3f3f</span>) &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; g[t][j]) dist[j] = g[t][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h4><p>保存每条边，按照权值从小到大排序，连通用到并查集</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2e2</span> + <span class="hljs-number">5</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">int</span> g[N][N], n, m, k;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e2</span> + <span class="hljs-number">5</span>,<br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">2e2</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> p[M], n, m, res, cnt; <span class="hljs-comment">// p为并查集</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-keyword">int</span> a, b, c;<br>&#125;Ns[M];<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Node a, Node b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.c &lt; b.c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p[a] != a) &#123;<br>        p[a] = find(p[a]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> p[a];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        p[i] = i; <span class="hljs-comment">//并查集初始化</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">int</span> a, b, c;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        Ns[i] = &#123; a,b,c &#125;;<br>    &#125;<br>    sort(Ns, Ns + m, cmp); <span class="hljs-comment">// 边排序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">int</span> a = Ns[i].a, b = Ns[i].b, c = Ns[i].c;<br>        <span class="hljs-keyword">if</span> (find(a) != find(b)) &#123;<br>            p[find(a)] = find(b);<br>            res += c;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cnt != n - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; res;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h2><h3 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h3><p><strong>判断n是否为质数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 试除法判断n是否为质数</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>, up = <span class="hljs-built_in">sqrt</span>(n); i &lt;= up; i++) &#123;<br>        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>筛选出1~n的质数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 埃式筛1~n的质数 O(nloglogn)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!st[i]) &#123;<br>            prime[cnt++] = i;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + i; j &lt;= n; j += i) &#123; <span class="hljs-comment">// i的倍数肯定都不是质数</span><br>                st[j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 线性筛质数O(n) (按照每一个数的最小质因数来筛，每个数都只会筛一次)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!st[i]) &#123;<br>            prime[cnt++] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>, up = n / i; prime[j] &lt;= up; j++) &#123; <span class="hljs-comment">// 枚举之前选的质数</span><br>            st[prime[j] * i] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 两个质数乘积prime[j]*i肯定不是质数</span><br>            <span class="hljs-keyword">if</span> (i % prime[j] == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// prime[j]是i的质因数?，不需要再重复筛</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>对n分解质因数</strong></p><script type="math/tex;mode=display">n=P_1^{a_1}{\times}P_2^{a_2}\times...{\times}P_n^{a_n}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>, up = <span class="hljs-built_in">sqrt</span>(n); i &lt;= up; i++) &#123;<br>        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 只要满足则i一定是质数(因为如果i不是质数，则前面就已经把n中i的质因子除掉了)</span><br>            <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (n % i == <span class="hljs-number">0</span>) &#123;<br>                cnt++;<br>                n /= i;<br>            &#125;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; cnt &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 一个因子i^cnt</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (n != <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h3><p><strong>求约数</strong></p><p>数字n可能很大，数组静态开辟不能太大，可以改用<code>std::vector</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, up = <span class="hljs-built_in">sqrt</span>(n); i &lt;= up; i++) &#123;<br>        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) &#123;<br>            q[cnt++] = i; <br>            <span class="hljs-keyword">if</span> (i != n / i) &#123;<br>                q[cnt++] = n / i; <span class="hljs-comment">// 对称的另一个</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>约数个数</strong></p><p>先分解质因数<script type="math/tex">n=P_1^{a_1}{\times}P_2^{a_2}\times...{\times}P_n^{a_n}</script>，约数个数为<script type="math/tex">(a_1+1){\times}(a_2+1){\times}...{\times}(a_n+1)</script>。<strong>注意是相乘</strong>。</p><p>例：给定n个正数ai，输出这些数的乘积的约数个数，答案对1e9+7取模。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; h; <span class="hljs-comment">// 保存质因数的底和指数</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n--) &#123;<br>        <span class="hljs-keyword">int</span> a;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; a;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= a / i; i++) &#123;<br>            <span class="hljs-keyword">if</span> (a % i == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">while</span> (a % i == <span class="hljs-number">0</span>) &#123;<br>                    a /= i;<br>                    h[i]++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (a != <span class="hljs-number">1</span>) &#123;<br>            h[a]++; <span class="hljs-comment">// a没有被除完?</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> i : h) &#123;<br>        <span class="hljs-keyword">int</span> b = i.second;<br>        res = res * (b + <span class="hljs-number">1</span>) % MOD; <span class="hljs-comment">// 约数个数公式</span><br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; res;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>约数和</strong></p><p>先分解质因数<script type="math/tex">n=P_1^{a_1}{\times}P_2^{a_2}\times...{\times}P_n^{a_n}</script>，约数和为<script type="math/tex">\sum_0^{a_1}P_1^i{\times}...{\times}\sum_0^{a_n}P^i</script>，<strong>注意也是相乘</strong>。</p><p>每一部分都可以使用等比数列求和公式进行快速计算，而且还可以使用快速幂。</p><p>例：给定n个正数ai，输出这些数的乘积的约数个数，答案对1e9+7取模。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fastpow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> p)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(b)&#123;<br>        <span class="hljs-keyword">if</span>(b &amp; <span class="hljs-number">1</span>)&#123;<br>            res = (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)res * a % p;<br>        &#125;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>        a = (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)a * a %p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-comment">// 基本同上，不同之处</span><br><span class="hljs-keyword">int</span> a = i.first, b = i.second;<br>res = (res * ((<span class="hljs-number">1</span>-fastpow(a, b+<span class="hljs-number">1</span>, MOD)) / (<span class="hljs-number">1</span> - a))) % MOD;<br></code></pre></td></tr></table></figure><p><strong>最大公约数</strong></p><p><code>b != 0，(a, b) = (b, a%b)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : gcd(b, a%b);<br>&#125;<br><br><span class="hljs-comment">// 最小公倍数</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lcm</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a * b / gcd(a, b);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p>函数值为为小于等于n的正整数中与n互质的数的个数。</p><p>先分解质因数<script type="math/tex">n=P_1^{a_1}{\times}P_2^{a_2}\times...{\times}P_n^{a_n}</script></p><p>则<script type="math/tex">\phi(n)=n{\times}(1-\frac{1}{P_1})\times(1-\frac{1}{P_2})\times...\times(1-\frac{1}{P_n})</script></p><p>其实展开就是<script type="math/tex">n-\frac{n}{P_1}-...-\frac{n}{P_n}+\frac{n}{P_1P_2}+...+\frac{n}{P_{n-1}P_{n}}-\frac{n}{P_1P_2P_3}-...</script></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// O(n)</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Euler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> ans = n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">if</span>(n%i == <span class="hljs-number">0</span>)&#123;<br>            ans = ans / i * (i<span class="hljs-number">-1</span>);<br>            <span class="hljs-keyword">while</span>(n%i==<span class="hljs-number">0</span>)&#123;<br>                n /= i;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-comment">// O(n^0.5)</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Euler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> ans = n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">if</span>(n%i == <span class="hljs-number">0</span>)&#123;<br>            ans = ans / i * (i<span class="hljs-number">-1</span>); <br>            <span class="hljs-keyword">while</span>(n%i == <span class="hljs-number">0</span>)&#123;<br>                n /= i;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">1</span>)&#123;<br>        ans = ans / n * (n<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>性质</strong></p><p><script type="math/tex">\phi(m{\times}n)=\phi(m)\times\phi(n)</script>，其中m和n互质。</p><p><strong>线性筛</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 在线性筛素数基础上添加</span><br><span class="hljs-keyword">int</span> euler[N]; <span class="hljs-comment">// 保存对应的欧拉函数值</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!st[i]) &#123;<br>            prime[cnt++] = i;<br>            euler[i] = i<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>, up = n / i; prime[j] &lt;= up; j++) &#123;<br>            st[prime[j] * i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % prime[j] == <span class="hljs-number">0</span>) &#123;<br>                euler[i*prime[j]] = euler[i] * prime[j];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            euler[i*prime[j]] = euler[i] * euler[prime[j]]; <span class="hljs-comment">// 欧拉函数性质</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>某个问题可以转换成N个子问题，并且子问题还可以转换，而且存在着重复。</p><p>流程：反推、正推-状态表示-分类讨论-状态方程-优化</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="闰年"><a href="#闰年" class="headerlink" title="闰年"></a>闰年</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isLeapYear</span><span class="hljs-params">(<span class="hljs-keyword">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> y%<span class="hljs-number">400</span>==<span class="hljs-number">0</span> || (y%<span class="hljs-number">100</span>!=<span class="hljs-number">0</span> &amp;&amp; y%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="输入挂"><a href="#输入挂" class="headerlink" title="输入挂"></a>输入挂</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 读整数</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">scan_d</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;num)</span>  </span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">char</span> in; <span class="hljs-keyword">bool</span> IsN=<span class="hljs-literal">false</span>;<br>        in=getchar();<br>        <span class="hljs-keyword">if</span>(in==EOF) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span>(in!=<span class="hljs-string">&#x27;-&#x27;</span>&amp;&amp;(in&lt;<span class="hljs-string">&#x27;0&#x27;</span>||in&gt;<span class="hljs-string">&#x27;9&#x27;</span>)) in=getchar();<br>        <span class="hljs-keyword">if</span>(in==<span class="hljs-string">&#x27;-&#x27;</span>)&#123; IsN=<span class="hljs-literal">true</span>;num=<span class="hljs-number">0</span>;&#125;<br>        <span class="hljs-keyword">else</span> num=in-<span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">while</span>(in=getchar(),in&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;in&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>                num*=<span class="hljs-number">10</span>,num+=in-<span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(IsN) num=-num;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 读实数</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">scan_lf</span><span class="hljs-params">(<span class="hljs-keyword">double</span> &amp;num)</span>  </span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">char</span> in; <span class="hljs-keyword">double</span> Dec=<span class="hljs-number">0.1</span>;<br>        <span class="hljs-keyword">bool</span> IsN=<span class="hljs-literal">false</span>, IsD=<span class="hljs-literal">false</span>;<br>        in=getchar();<br>        <span class="hljs-keyword">if</span>(in==EOF) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span>(in!=<span class="hljs-string">&#x27;-&#x27;</span>&amp;&amp;in!=<span class="hljs-string">&#x27;.&#x27;</span>&amp;&amp;(in&lt;<span class="hljs-string">&#x27;0&#x27;</span>||in&gt;<span class="hljs-string">&#x27;9&#x27;</span>))<br>        	in=getchar();<br>        <span class="hljs-keyword">if</span>(in==<span class="hljs-string">&#x27;-&#x27;</span>)&#123;IsN=<span class="hljs-literal">true</span>;num=<span class="hljs-number">0</span>;&#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(in==<span class="hljs-string">&#x27;.&#x27;</span>)&#123;IsD=<span class="hljs-literal">true</span>;num=<span class="hljs-number">0</span>;&#125;<br>        <span class="hljs-keyword">else</span> num=in-<span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(!IsD)&#123;<br>            <span class="hljs-keyword">while</span>(in=getchar(),in&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;in&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>                num*=<span class="hljs-number">10</span>;num+=in-<span class="hljs-string">&#x27;0&#x27;</span>;&#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(in!=<span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(IsN) num=-num;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">while</span>(in=getchar(),in&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;in&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>                num+=Dec*(in-<span class="hljs-string">&#x27;0&#x27;</span>);Dec*=<span class="hljs-number">0.1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(IsN) num=-num;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h3><ol><li>01</li><li>完全</li></ol><p>。。。</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noreferrer">云落溪音</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://www.vulxin.top/posts/a4ac75aa/">https://www.vulxin.top/posts/a4ac75aa/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明作者和来源。</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/1971489/Images/P/2131660/69660140_p0.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/bf30e3e0/"><img class="prev-cover" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/P/2131660/87977950_p0.jpg" onerror='onerror=null,src="/mimg/PokeBall_gray.PNG"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">LL(1)无回溯的递归下降语法分析器</div></div></a></div><div class="next-post pull-right"><a href="/posts/bed86e5b/"><img class="next-cover" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21/04/11/test_mini.svg" onerror='onerror=null,src="/mimg/PokeBall_gray.PNG"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Python绘制语法分析树</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/Site/avatar.jpg" onerror='this.onerror=null,this.src="/mimg/PokeBall_gray_small.PNG"' alt="avatar"><div class="author-info__name">云落溪音</div><div class="author-info__description">分享知识、记录生活</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">63</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/vulxin" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:vulxin@foxmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F"><span class="toc-number">1.</span> <span class="toc-text">序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">2.</span> <span class="toc-text">单链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">双链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">4.</span> <span class="toc-text">栈和队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">5.</span> <span class="toc-text">树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">6.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%A8%A1%E6%9D%BF"><span class="toc-number">6.1.</span> <span class="toc-text">快速排序模板</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">7.</span> <span class="toc-text">前缀和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%AE%E5%88%86"><span class="toc-number">8.</span> <span class="toc-text">差分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%B3%95"><span class="toc-number">9.</span> <span class="toc-text">二分法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-number">9.1.</span> <span class="toc-text">查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%BA%94%E7%94%A8"><span class="toc-number">9.2.</span> <span class="toc-text">其他应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E9%97%AE%E9%A2%98%E7%AD%94%E6%A1%88"><span class="toc-number">9.3.</span> <span class="toc-text">搜索问题答案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BF%90%E7%AE%97"><span class="toc-number">10.</span> <span class="toc-text">二进制运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">10.1.</span> <span class="toc-text">位运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-number">10.2.</span> <span class="toc-text">快速幂</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">11.</span> <span class="toc-text">并查集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS-amp-BFS"><span class="toc-number">12.</span> <span class="toc-text">DFS &amp; BFS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#n%E7%9A%87%E5%90%8E"><span class="toc-number">12.1.</span> <span class="toc-text">n皇后</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98"><span class="toc-number">12.2.</span> <span class="toc-text">迷宫问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E6%95%B0%E7%A0%81"><span class="toc-number">12.3.</span> <span class="toc-text">八数码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E6%98%A0%E5%B0%84-%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80"><span class="toc-number">12.3.1.</span> <span class="toc-text">手动映射-康托展开</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E4%B8%8E%E5%9B%BE%E7%9A%84%E6%90%9C%E7%B4%A2"><span class="toc-number">13.</span> <span class="toc-text">树与图的搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">13.1.</span> <span class="toc-text">图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83"><span class="toc-number">13.2.</span> <span class="toc-text">树的重心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">13.3.</span> <span class="toc-text">拓扑排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E8%AE%BA"><span class="toc-number">14.</span> <span class="toc-text">图论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E8%B4%9F%E6%9D%83%E8%BE%B9"><span class="toc-number">14.1.</span> <span class="toc-text">无负权边</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Dijkstra"><span class="toc-number">14.1.1.</span> <span class="toc-text">Dijkstra</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E8%B4%9F%E6%9D%83%E8%BE%B9"><span class="toc-number">14.2.</span> <span class="toc-text">有负权边</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bellman-ford"><span class="toc-number">14.2.1.</span> <span class="toc-text">Bellman-ford</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SPFA"><span class="toc-number">14.2.2.</span> <span class="toc-text">SPFA</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%BA%90%E7%82%B9"><span class="toc-number">14.3.</span> <span class="toc-text">多源点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">14.4.</span> <span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Prim"><span class="toc-number">14.4.1.</span> <span class="toc-text">Prim</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kruskal"><span class="toc-number">14.4.2.</span> <span class="toc-text">Kruskal</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E8%AE%BA"><span class="toc-number">15.</span> <span class="toc-text">数论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%A8%E6%95%B0"><span class="toc-number">15.1.</span> <span class="toc-text">质数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A6%E6%95%B0"><span class="toc-number">15.2.</span> <span class="toc-text">约数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0"><span class="toc-number">15.3.</span> <span class="toc-text">欧拉函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">16.</span> <span class="toc-text">动态规划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">17.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%B0%E5%B9%B4"><span class="toc-number">17.1.</span> <span class="toc-text">闰年</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%8C%82"><span class="toc-number">17.2.</span> <span class="toc-text">输入挂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E5%8C%85"><span class="toc-number">17.3.</span> <span class="toc-text">背包</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/488468bb/" title="Design Patterns: Factory 工厂模式"><img data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/P/2131660/72277519_p0.jpg" onerror='this.onerror=null,this.src="/mimg/PokeBall_gray.PNG"' alt="Design Patterns: Factory 工厂模式"></a><div class="content"><a class="title" href="/posts/488468bb/" title="Design Patterns: Factory 工厂模式">Design Patterns: Factory 工厂模式</a><time datetime="2021-05-05T00:33:40.000Z" title="发表于 2021-05-05 08:33:40">2021-05-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/ed19ae83/" title="Design Patterns: Decorator 装饰器模式"><img data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/P/2131660/75126666_p0.jpg" onerror='this.onerror=null,this.src="/mimg/PokeBall_gray.PNG"' alt="Design Patterns: Decorator 装饰器模式"></a><div class="content"><a class="title" href="/posts/ed19ae83/" title="Design Patterns: Decorator 装饰器模式">Design Patterns: Decorator 装饰器模式</a><time datetime="2021-05-02T05:47:18.000Z" title="发表于 2021-05-02 13:47:18">2021-05-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/28f934ed/" title="Git提交失败：Please make sure you have the correct access rights and the repository exists."><img data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/P/2131660/77734148_p0.jpg" onerror='this.onerror=null,this.src="/mimg/PokeBall_gray.PNG"' alt="Git提交失败：Please make sure you have the correct access rights and the repository exists."></a><div class="content"><a class="title" href="/posts/28f934ed/" title="Git提交失败：Please make sure you have the correct access rights and the repository exists.">Git提交失败：Please make sure you have the correct access rights and the repository exists.</a><time datetime="2021-05-01T09:33:45.000Z" title="发表于 2021-05-01 17:33:45">2021-05-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/ebb7c955/" title="谷歌在线字体不生效"><img data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/P/2131660/68281311_p0.jpg" onerror='this.onerror=null,this.src="/mimg/PokeBall_gray.PNG"' alt="谷歌在线字体不生效"></a><div class="content"><a class="title" href="/posts/ebb7c955/" title="谷歌在线字体不生效">谷歌在线字体不生效</a><time datetime="2021-05-01T01:26:00.000Z" title="发表于 2021-05-01 09:26:00">2021-05-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4ea5f14a/" title="Design Patterns: Observer 观察者模式"><img data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/P/2131660/75013679_p0.jpg" onerror='this.onerror=null,this.src="/mimg/PokeBall_gray.PNG"' alt="Design Patterns: Observer 观察者模式"></a><div class="content"><a class="title" href="/posts/4ea5f14a/" title="Design Patterns: Observer 观察者模式">Design Patterns: Observer 观察者模式</a><time datetime="2021-04-27T10:35:55.000Z" title="发表于 2021-04-27 18:35:55">2021-04-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 云落溪音</div><div class="footer_custom_text"><p><a href="https://icp.gov.moe/?keyword=20212019" target="_blank" rel="external nofollow noreferrer" style="margin-inline:5px"><img src="https://img.shields.io/badge/萌ICP备-20212019号-ff69b4?logo=Github-Sponsors"></a><a href="https://www.jsdelivr.com/" target="_blank" rel="external nofollow noreferrer" style="margin-inline:5px"><img src="https://img.shields.io/badge/CDN-jsDelivr-red?logo=jsDelivr"></a><a href="https://www.aliyun.com/" target="_blank" rel="external nofollow noreferrer" style="margin-inline:5px"><img src="https://img.shields.io/badge/Host-Ali Cloud-orange?logo=alibaba-cloud"></a><a href="https://github.com/" target="_blank" rel="external nofollow noreferrer" style="margin-inline:5px"><img src="https://img.shields.io/badge/SVN-Github-brightgreen?logo=Github"></a><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external nofollow noreferrer" style="margin-inline:5px"><img src="https://img.shields.io/badge/Copyright-CC_BY--NC--SA_4.0-blue?logo=Coursera&logoColor=blue"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js").then(()=>{pangu.autoSpacingPage()})}function panguInit(){panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>if(window.MathJax)MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset();else{window.MathJax={loader:{source:{"[tex]/amsCd":"[tex]/amscd"}},tex:{inlineMath:[["$","$"],["\\(","\\)"]],tags:"ams"},options:{renderActions:{findScript:[10,t=>{for(const e of document.querySelectorAll('script[type^="math/tex"]')){const a=!!e.type.match(/; *mode=display/),n=new t.options.MathItem(e.textContent,t.inputJax[0],a),s=document.createTextNode("");e.parentNode.replaceChild(s,e),n.start={node:s,delim:"",n:0},n.end={node:s,delim:"",n:0},t.math.push(n)}},""],addClass:[200,()=>{document.querySelectorAll("mjx-container:not([display='true']").forEach(t=>{const e=t.parentNode;e.classList.contains("has-jax")||e.classList.add("mathjax-overflow")})},"",!1]}}};const t=document.createElement("script");t.src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js",t.id="MathJax-script",t.async=!0,document.head.appendChild(t)}</script><script>document.getElementsByClassName("mermaid").length&&(window.mermaidJsLoad?mermaid.init():getScript("https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js").then(()=>{window.mermaidJsLoad=!0,mermaid.initialize({theme:"default"}),mermaid.init()}))</script><script>function loadWaline(){function e(){let e={el:"#waline-wrap",serverURL:"https://hexo-comment.vercel.app/",avatar:"mp",path:location.pathname,emojiCDN:"",emojiMaps:""};new Waline(e)}"function"==typeof Waline?e():getScript("https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js").then(e)}{function loadOtherComment(){loadWaline()}setTimeout(loadWaline,0)}</script></div><script src="/inject/custom.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:send",(function(){if("object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.16/hexo_githubcalendar.js"></script><script data-pjax>function GithubCalendarConfig(){var t=document.getElementById("recent-posts");t&&"/"==location.pathname&&(console.log("已挂载github calendar"),t.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="height:100%;display: flex;align-items: center;justify-content: center;"><svg style="height:50px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>')),GithubCalendar("https://github-calendar-api-eight.vercel.app/api?vulxin",["#ebedf0","#85e89d","#34d058","#28a745","#22863a","#176f2c","#165c26","#144620","#144620","#144620","#144620"],"vulxin")}document.getElementById("recent-posts")&&GithubCalendarConfig()</script><style>#github_container{min-height:248px}@media screen and (max-width:650px){#github_container{min-height:0}}</style><style></style><script data-pjax>function history_calendar_injector_config(){var i=document.getElementsByClassName("sticky_layout")[0];console.log("已挂载history_calendar"),i.insertAdjacentHTML("afterbegin",'<div class="card-widget card-history"><div class="card-content"><div class="item-headline"><i class="fas fa-clock fa-spin"></i><span>那年今日</span></div><div id="history-baidu" style="height: 100px;overflow: hidden"><div class="history_swiper-container" id="history-container" style="width: 100%;height: 100%"><div class="swiper-wrapper" id="history_container_wrapper" style="height:20px"></div></div></div></div>')}document.getElementsByClassName("sticky_layout")[0]&&(location.pathname,1)&&history_calendar_injector_config()</script><script data-pjax src="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script></body></html>