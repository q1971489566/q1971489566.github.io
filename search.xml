<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Design Patterns: Decorator 装饰器模式</title>
      <link href="posts/ed19ae83/"/>
      <url>posts/ed19ae83/</url>
      
        <content type="html"><![CDATA[<h1 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h1><blockquote><p>  结构型模式</p></blockquote><p>在不改变代码的情况下给一个对象增加功能，类似于继承中覆写方法，但是可以在运行时进行改变。用装饰器模式可以替代继承。</p><p>具体实现：</p><p>要被装饰的类叫做实体类<code>ConcreteComponent</code>，在这个实体类外面再包装一个类，叫做装饰类<code>Decorator</code>，这个装饰类和实体类一样继承自<code>Component</code>而且持有<code>Component</code>类型的引用<code>decoratedComponent</code>，这个引用其实是要被装饰的实体，也就是<code>ConcreteComponent</code>类型的。</p><p>功能扩展类<code>ConcreteDecorator</code>都继承自装饰类并覆写相应的方法。在这些功能扩展类拥有从装饰类里继承来的<code>decoratedComponent</code>引用。在每个功能扩展类看来，这个引用都是最初那个实体(<strong>但是其实可能是已经被层层装饰过了</strong>)，然后在每个功能扩展类里对要装饰的方法再包装一层。</p><p>所以装饰器模式实现复用和扩展依靠的就是那个关键的<code>decoratedComponent</code>引用，在添加功能时不是通过层层继承，而是通过组合的方式。</p><p>看具体的例子会比较容易理解。</p><h1 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h1><p>有一个房子，里面空空如也，现在要往房子里添加各种家具来装修这个房子。为了直观理解，先上运行的测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 一个空教室</span><br>House classroom = <span class="hljs-keyword">new</span> Classroom();<br>System.out.println(<span class="hljs-string">&quot;==== Original ====&quot;</span>);<br>classroom.show();<br><span class="hljs-comment">// 空教室加一把椅子</span><br>House classroomWithChair = <span class="hljs-keyword">new</span> Chair(classroom);<br>System.out.println(<span class="hljs-string">&quot;==== Classroom with a chair ====&quot;</span>);<br>classroomWithChair.show();<br><span class="hljs-comment">// 空教室加一个桌子</span><br>House classroomWithDesk = <span class="hljs-keyword">new</span> Desk(classroom);<br>System.out.println(<span class="hljs-string">&quot;==== Classroom with a desk ====&quot;</span>);<br>classroomWithDesk.show();<br><span class="hljs-comment">// 在加了椅子的基础上加桌子</span><br>House classroomWithChairAndDesk = <span class="hljs-keyword">new</span> Desk(classroomWithChair);<br>System.out.println(<span class="hljs-string">&quot;==== Classroom with a chair and a desk ====&quot;</span>);<br>classroomWithChairAndDesk.show();<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x3D;&#x3D;&#x3D;&#x3D; Original &#x3D;&#x3D;&#x3D;&#x3D;<br>A classroom.<br>&#x3D;&#x3D;&#x3D;&#x3D; Classroom with a chair &#x3D;&#x3D;&#x3D;&#x3D;<br>A classroom.<br>There is a chair<br>&#x3D;&#x3D;&#x3D;&#x3D; Classroom with a desk &#x3D;&#x3D;&#x3D;&#x3D;<br>A classroom.<br>There is a desk<br>&#x3D;&#x3D;&#x3D;&#x3D; Classroom with a chair and a desk &#x3D;&#x3D;&#x3D;&#x3D;<br>A classroom.<br>There is a chair<br>There is a desk<br></code></pre></td></tr></table></figure><p>可以看到如果要给教室添加家具，只需要在外面嵌套一个类，而且已经被嵌套过的对象还能再次嵌套。</p><p>这里的<code>House</code>对应<code>Component</code>，<code>Classroom</code>对应<code>ConcreteComponent</code>，<code>Chair</code>和<code>Desk</code>都对应<code>ConcreteComponent</code>。</p><p>如果最后只需要一个教室，可以重复使用同一个引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">House classroom = <span class="hljs-keyword">new</span> Classroom();<br>System.out.println(<span class="hljs-string">&quot;==== Original ====&quot;</span>);<br>classroom.show();<br><br>classroom = <span class="hljs-keyword">new</span> Chair(classroom);<br>System.out.println(<span class="hljs-string">&quot;==== Add a chair ====&quot;</span>);<br>classroom.show();<br><br>classroom = <span class="hljs-keyword">new</span> Desk(classroom);<br>System.out.println(<span class="hljs-string">&quot;==== Add a desk ====&quot;</span>);<br>classroom.show();<br></code></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>一个共同的基类<code>House</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">House</span></span>&#123;<br>    <span class="hljs-keyword">protected</span> String name = <span class="hljs-string">&quot;House&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>要被装饰的类<code>Classroom</code>，要被装饰的方法是<code>show</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Classroom</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">House</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Classroom</span><span class="hljs-params">()</span> </span>&#123;<br>        name = <span class="hljs-string">&quot;Classroom&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;A classroom.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>装饰器基类<code>HouseDecorator</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HouseDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">House</span></span>&#123;<br>    <span class="hljs-keyword">protected</span> House house;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HouseDecorator</span><span class="hljs-params">(House house)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.house = house;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        house.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体的装饰器<code>Chair</code>和<code>Desk</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chair</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HouseDecorator</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Chair</span><span class="hljs-params">(House house)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(house);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        house.show();<br>        System.out.println(<span class="hljs-string">&quot;There is a chair&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Desk</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HouseDecorator</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Desk</span><span class="hljs-params">(House house)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(house);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        house.show();<br>        System.out.println(<span class="hljs-string">&quot;There is a desk&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="简化"><a href="#简化" class="headerlink" title="简化"></a>简化</h1><ol><li>如果要被装饰的类只有一个，比如这里只有一个<code>Classroom</code>，那么就可以把共同的基类省掉，让装饰器也直接继承自这个类，这里就是让<code>HouseDecorator</code>继承自<code>Classroom</code>。</li><li>如果具体的装饰器只有一个，比如只有<code>Chair</code>，那么就可以把装饰器类省掉，直接让具体的装饰器继承自共同的基类，也就是让<code>Chair</code>继承自<code>House</code>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> DesignPatterns </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git提交失败：Please make sure you have the correct access rights and the repository exists.</title>
      <link href="posts/28f934ed/"/>
      <url>posts/28f934ed/</url>
      
        <content type="html"><![CDATA[<div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>背景</span></div>    <div class="hide-content"><p>不知从什么时候开始，用git提交的时候需要手动输入用户名和密码了。提交一次之后，github就发了封邮件给我，提醒我说用密码登录的方式要在今年被废弃了，让我尽快换成ssh或其他验证方式。</p><p>但是其实我之前都是用ssh验证的，也不知道是出了什么问题，只好重新添加ssh key。</p><p>先在文件管理器里右键<code>git bash here</code>，在终端依次输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/.ssh<br>ssh-keygen -t rsa -C <span class="hljs-string">&quot;github账号的邮箱地址&quot;</span><br></code></pre></td></tr></table></figure><p>一路回车，在<code>C:/用户/（用户名）/.ssh/</code>目录里就生成了<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，分别对应私钥和公钥。</p><p>在浏览器登录<a href="https://github.com">Github</a>，点击右上角头像，找到<code>Settings</code>，再找到<code>SSH and GPG keys</code>，点击添加，把之前生成的<code>id_rsa.pub</code>的内容复制进去。</p><p>确认当前配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --list<br></code></pre></td></tr></table></figure><p>如果账户不对，就需要设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;用户名&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;邮箱&quot;</span><br></code></pre></td></tr></table></figure><p>然后在终端依次输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">eval</span> `ssh-agent`<br>ssh-add<br>ssh -T git@github.com<br></code></pre></td></tr></table></figure><p>一般这样做之后就没问题了，但是我到这里还是不能正常提交。</p></div></div><p>我遇到的问题是：在<code>git push</code>后，提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">No supported authentication methods available (server sent: publickey)<br></code></pre></td></tr></table></figure><p>想到可能是这个仓库原来是用https下载的，查看<code>.git/gitconfig</code>里的<code>[remote &quot;origin&quot;]</code>，果然是https的，所以要先改成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">url = git@github.com:用户名/仓库.git<br></code></pre></td></tr></table></figure><p>然后再次提交，依然报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">Could not <span class="hljs-built_in">read</span> from remote repository.<br>Please make sure you have the correct access rights<br>and the repository exists.<br></code></pre></td></tr></table></figure><p>而且报错信息来自一个叫做<code>TortoiseGitPlink</code>的程序。在网上查找一番后知道要改小乌龟的<code>ssh.exe</code>，但是检查后发现已经设置成git里的ssh了。感觉问题就出在小乌龟的<code>TortoiseGitPlink</code>上，明明已经改了可执行文件，但是用git提交还是会调用它。</p><p>我也不知道怎么改变git的设置。于是只好将<code>Tortoise Git</code>和<code>Git</code>都卸载了。卸载之后在原来Git的安装目录里发现还残留了个文件<code>etc/gitcofig</code>，里面有一条设置也是含有<code>TortoiseGitPlink</code>，于是也将这个文件删掉，这样才卸载干净。</p><p>重装<code>Git</code>的时候还特别留意了有一个选项就是选<code>TortoiseGitPlink</code>的，我自然就没有选它，还是用了Git自带的。</p><p>最后再次push，终于成功了。</p>]]></content>
      
      
      <categories>
          
          <category> Error </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷歌在线字体不生效</title>
      <link href="posts/ebb7c955/"/>
      <url>posts/ebb7c955/</url>
      
        <content type="html"><![CDATA[<div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>背景</span></div>    <div class="hide-content"><p>之前博客字体一直是保持默认，也就是常见的黑体，而且字号很小，但是自己一直没怎么去读过，也就没发现问题。直到最近放假，我自己读了几篇文章才发现读起来很难受，不说内容如何，就是这字体看起来是真的费劲。于是赶紧把默认字体调大了一些，但还是感觉不太行。</p><p>经常看到很多人的博客用的是那种类似于宋体的字，看起来挺舒服的。查了一些资料后才知道这是衬线字体的功劳，具体可以看下这篇文章：<a href="http://www.sucaijishi.com/2018/worth_0418/239.html">区分衬线字体和无衬线字体</a></p><p>于是我也想换个衬线字体，然后又不经意间了解到<a href="https://zhuanlan.zhihu.com/p/52139651">Google的在线字体库支持思源宋体了</a>。个人感觉思源宋体正好满足我的需求，而且还<a href="https://source.typekit.com/source-han-serif/cn/">开源免费</a>，于是就开始尝试把字体换成思源宋体。</p><p>首先使用科学上网打开<a href="https://fonts.google.com/">谷歌字体库</a></p><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21/05/01/google-font.png" alt=""></p><p>在第一个红框选择简体中文，第二个红框就是要找的思源宋体，点进去，选择一个适合自己的字重，我这里选的是400的</p><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21/05/01/google-font-1.png" alt=""></p><p>选中后右边就会弹出边框（也可以点右上角的小方格），可以看到两个链接</p><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21/05/01/google-font-2.png" alt=""></p><p>所以要用到的<code>HTML</code>链接就是：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;preconnect&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://fonts.gstatic.com&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://fonts.googleapis.com/css2?family=Noto+Serif+SC&amp;display=swap&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>CSS</code>字体族：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">font-family: &#x27;Noto Serif SC&#x27;, serif;<br></code></pre></td></tr></table></figure><p>然后正常情况下嵌入到<code>HTML</code>里并指定全局字体就可以，但是却遇到了问题。</p></div></div><p>先按照从谷歌获取到的字体链接修改主题配置文件：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">font:</span><br>  <span class="hljs-attr">global-font-size:</span> <span class="hljs-string">16px</span><br>  <span class="hljs-attr">code-font-size:</span> <span class="hljs-string">16px</span><br>  <span class="hljs-attr">font-family:</span> <span class="hljs-string">-apple-system,</span> <span class="hljs-string">&quot;Noto Serif SC&quot;</span><span class="hljs-string">,</span> <span class="hljs-string">sans-serif</span><br>  <span class="hljs-attr">code-font-family:</span> <span class="hljs-string">consolas,</span> <span class="hljs-string">sans-serif</span><br><br><span class="hljs-attr">blog_title_font:</span><br>  <span class="hljs-attr">font_link:</span> <span class="hljs-string">https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@500&amp;display=swap</span> <br>  <span class="hljs-attr">font-family:</span> <span class="hljs-string">-apple-system,</span> <span class="hljs-string">&quot;Noto Serif SC&quot;</span><span class="hljs-string">,</span> <span class="hljs-string">sans-serif</span><br></code></pre></td></tr></table></figure><p>然后在本地测试运行可以如预期地正常显示，但是部署之后又变成默认字体。</p><p>也不知道是哪里出了问题，开始还以为是谷歌连接不上的原因，但是浏览器却可以在不科学上网的情况下打开字体链接…</p><p>感觉是部署后的代码问题，于是查看部署之后网页代码，发现<code>preconnect</code>不太对，按照谷歌给的链接应该是<code>https://fonts.gstatic.com</code>。</p><p>于是去找模板文件，在<code>preconnect.pug</code>中找到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pug">link(rel&#x3D;&quot;preconnect&quot; href&#x3D;&quot;&#x2F;&#x2F;fonts.googleapis.com&quot; crossorigin&#x3D;&#39;&#39;)<br></code></pre></td></tr></table></figure><p>把这一行改成:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pug">link(rel&#x3D;&quot;preconnect&quot; href&#x3D;&quot;&#x2F;&#x2F;fonts.gstatic.com&quot;)<br></code></pre></td></tr></table></figure><p>然后重新部署，问题就解决了。</p><div class="note danger simple"><p>不过问题好像还没有完全解决，我用Chrome还是不生效，Edge和Firefox却都没问题</p></div>]]></content>
      
      
      <categories>
          
          <category> Error </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Font </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Design Patterns: Observer 观察者模式</title>
      <link href="posts/4ea5f14a/"/>
      <url>posts/4ea5f14a/</url>
      
        <content type="html"><![CDATA[<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><blockquote><p>  行为型模式</p></blockquote><p>在观察者模式中主要有两大类对象：</p><p>一个是被观察的对象，叫做主题<code>Subject</code>，<code>Subject</code>具有数据，需要更新并提供给另一大类对象。</p><p>这另一大类对象就是观察者<code>Observer</code>，<code>Observer</code>不断获取<code>Subject</code>的数据更新，而且主要是处于一种被动的状态，也就是等待<code>Subject</code>主动推送<code>push</code>，少数时候需要自己向<code>Subject</code>拉取<code>pull</code>。</p><p>观察者和被观察者之间是<code>松耦合</code>的，因为被观察者并不需要知道具体是谁正在观察它，它只需要将观察者保存在列表里，然后统一向列表里的每个观察者进行推送即可。如果是不需要推送了的观察者，就直接从列表里删掉，新增观察者就添加到列表里。</p><h1 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h1><h2 id="已知的类和接口"><a href="#已知的类和接口" class="headerlink" title="已知的类和接口"></a>已知的类和接口</h2><ol><li><code>WeatherData</code>类有三个<code>gettter</code>方法可以用来获取湿度、温度和气压：<code>getTemperature</code>，<code>getHumidity</code>，<code>getPressure</code>，三个方法的具体实现未知。当数据发生变化时，应调用<code>measurementsChanged</code>方法。</li><li>三个用来显示天气数据的布告板类：<code>CurrentConditionsDisplay</code>，<code>StatisticsDisplay</code>，<code>ForecastDisplay</code>。它们都有一个<code>update</code>方法来接收数据更新。</li></ol><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ol><li>三个布告板都能及时收到数据更新，也就是要在<code>measurementsChanged</code>方法中调用这三个布告板的<code>update</code>方法。</li><li>以后可能会加入新种类的布告板或者去掉旧的布告板，所以实现中要考虑可扩展性。</li></ol><h2 id="最直观的实现"><a href="#最直观的实现" class="headerlink" title="最直观的实现"></a>最直观的实现</h2><p>按照需求1，最直观的实现方法自然是先在<code>measurementsChanged</code>中获取数据，然后直接对每个布告板调用<code>update</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> CurrentConditionsDisplay currentConditionsDisplay;<br><span class="hljs-keyword">private</span> StatisticsDisplay statisticsDisplay;<br><span class="hljs-keyword">private</span> ForecastDisplay forecastDisplay;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measurementsChanged</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">float</span> temp = getTemperature();<br>    <span class="hljs-keyword">float</span> humidity = getHumidity();<br>    <span class="hljs-keyword">float</span> pressure = getPressure();<br>    currentConditionsDisplay.update(temp, humidity, pressure);<br>    statisticsDisplay.update(temp, humidity, pressure);<br>    forecastDisplay.update(temp, humidity, pressure);<br>&#125;<br></code></pre></td></tr></table></figure><p>显然，这样的做法是<code>紧耦合</code>的。因为不仅需要在<code>WeatherData</code>类中分别保存每个布告板的引用，而且在数据更新的时候还要分别对每个布告板调用<code>update</code>。</p><p>现在只有三个布告板，代码量比较少，但是如果布告板比较多，代码量就会不断增加。而且还不符合需求2，可扩展性很差（只能通过修改源代码来进行增删）。</p><h2 id="使用观察者模式"><a href="#使用观察者模式" class="headerlink" title="使用观察者模式"></a>使用观察者模式</h2><p>首先需要实现三个接口:<code>Subject</code>, <code>Observer</code>, <code>DisplayElement</code>,分别对应了被观察者、观察者和布告板。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Observer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">float</span> temp, <span class="hljs-keyword">float</span> humidity, <span class="hljs-keyword">float</span> pressure)</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Subject</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerObserver</span><span class="hljs-params">(Observer o)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeObserver</span><span class="hljs-params">(Observer o)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObservers</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DisplayElement</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后将<code>WeatherData</code>实现为被观察者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeatherData</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Subject</span></span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> temperature;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> humidity;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> pressure;<br><span class="hljs-keyword">private</span> ArrayList&lt;Observer&gt; observers;<br>        <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WeatherData</span><span class="hljs-params">()</span> </span>&#123;<br>observers = <span class="hljs-keyword">new</span> ArrayList&lt;Observer&gt;();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerObserver</span><span class="hljs-params">(Observer o)</span> </span>&#123;<br>observers.add(o);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeObserver</span><span class="hljs-params">(Observer o)</span> </span>&#123;<br>observers.remove(o);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObservers</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (Observer o : observers) &#123;<br>            o.update(temperature, humidity, pressure);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measurementsChanged</span><span class="hljs-params">()</span></span>&#123;<br>notifyObservers();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 手动更新数据</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> temperature 温度</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> humidity 湿度</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> pressure 气压</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMeasurements</span><span class="hljs-params">(<span class="hljs-keyword">float</span> temperature, <span class="hljs-keyword">float</span> humidity, <span class="hljs-keyword">float</span> pressure)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.temperature = temperature;<br><span class="hljs-keyword">this</span>.humidity = humidity;<br><span class="hljs-keyword">this</span>.pressure = pressure;<br>measurementsChanged();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将布告板实现为观察者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CurrentConditionsDisplay</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span>, <span class="hljs-title">DisplayElement</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> temperature;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> humidity;<br>    <span class="hljs-keyword">private</span> Subject weatherData; <span class="hljs-comment">// 保存引用，方便取消注册</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CurrentConditionsDisplay</span><span class="hljs-params">(Subject weatherData)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.weatherData = weatherData;<br>        weatherData.registerObserver(<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">float</span> temperature, <span class="hljs-keyword">float</span> humidity, <span class="hljs-keyword">float</span> pressure)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.temperature = temperature;<br>        <span class="hljs-keyword">this</span>.humidity = humidity;<br>        display();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Current condition: &quot;</span> + temperature + <span class="hljs-string">&quot;F degrees, humidity: &quot;</span> + humidity + <span class="hljs-string">&quot;%&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Java内置的支持"><a href="#Java内置的支持" class="headerlink" title="Java内置的支持"></a>Java内置的支持</h1><p>在<code>java.util</code>中包含了<code>Observable</code>类和<code>Observer</code>接口，分别对应被观察者和观察者。与上面自行实现的不同之处在于：</p><ol><li><code>Observable</code>调用<code>setChanged</code>之后调用<code>notifyObservers</code>才会真的去通知观察者。</li><li><code>Observer</code>的<code>update</code>方法接收第一个参数是<code>Observable</code>，方便判断是哪个被观察者更新。</li><li><code>Observable</code>是一个类而不是接口，所以只能继承，不太符合面向接口编程的原则。</li></ol><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ol><li>当存在链式触发时，要小心可能出现循环引用。</li><li>上面的接口也可以定义成类</li><li>观察者可以实现为在运行时自主注册，而不一定要在构造方法里注册。</li></ol>]]></content>
      
      
      <categories>
          
          <category> DesignPatterns </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Design Patterns: 入门</title>
      <link href="posts/6e3384e4/"/>
      <url>posts/6e3384e4/</url>
      
        <content type="html"><![CDATA[<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><p>所谓设计模式，其实就是前辈们的经验总结。虽然看起来使用设计模式会使得代码量变多，但是实际上这是<strong>从平地到万丈高楼</strong>的过程，只有框架搭好了，后面需求再怎么变化，系统结构都不需要改动。</p><h1 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h1><h2 id="基本OOP"><a href="#基本OOP" class="headerlink" title="基本OOP"></a>基本OOP</h2><p>假如我们想要实现各种不同的鸭子。</p><p>为了实现<code>代码复用</code>，按照<code>继承</code>的思想，我们肯定会先抽象出一个超类<code>Duck</code>，然后把那些共有的属性和行为放到这个类里，比如<code>swim</code>方法。</p><p>为了实现各种不同的鸭子，按照<code>多态</code>思想，只需要对其进行派生各种子类，然后在各个子类中覆写需要的方法，比如实现各种<code>swim()</code>。</p><h2 id="使用接口"><a href="#使用接口" class="headerlink" title="使用接口"></a>使用接口</h2><p>这样实现看起来没有问题，但是如果增加了需求，比如<strong>有些</strong>鸭子能飞。</p><p>这时就不能把<code>fly</code>方法放到超类里，因为不是所有鸭子都会飞。于是想到用一个接口<code>Flyable</code>，只有实现了这个接口的鸭子才会飞。</p><p>新的需求看起来解决了，但是使用接口不能复用代码。子类一多，就会有很多重复的代码。要是<code>fly</code>的需求又变了，就需要改所有子类里重复的<code>fly</code>代码！</p><h2 id="提取行为"><a href="#提取行为" class="headerlink" title="提取行为"></a>提取行为</h2><p>为了继续实现<code>代码复用</code>，我们需要将这样总是变化的部分单独提取出来，也就是把<code>fly</code>方法的具体实现放到别的类里而不是写在每个鸭子类中。这些类都统一实现了一个接口<code>FlyBehaviour</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FlyBehaviour</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以后要实现不同的飞行行为，就对这个接口进行实现。比如<code>FlyWithWings</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlyWithWings</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FlyBehaviour</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;I&#x27;m flying with wings!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是不能飞的行为，那么就把<code>fly</code>方法实现为什么都不做就行了。</p><h2 id="组合实体与行为"><a href="#组合实体与行为" class="headerlink" title="组合实体与行为"></a>组合实体与行为</h2><p>现在已经可以自由实现各种行为了，各种鸭子类要用到飞行行为的时候就只需要绑定一个具体实现的引用即可。</p><p>这个引用是鸭子类都共有的，先在<code>Duck</code>超类中定义抽象行为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Duck</span></span>&#123;<br>    FlyBehaviour flyBehaviour;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performFly</span><span class="hljs-params">()</span></span>&#123;<br>        flyBehaviour.fly();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在子类构造方法中实例化特定的行为并保存一个引用，比如<code>WingDuck</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WingDuck</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Duck</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WingDuck</span><span class="hljs-params">()</span></span>&#123;<br>        flyBehaviour = <span class="hljs-keyword">new</span> FlyWithWings();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样一来，所有种类的鸭子想要飞行的时候都只需要调用<code>performFly()</code>就可以了。</p><p>这里鸭子类自己的行为实际上是调用其他类里的实现，这就叫做<code>委托</code>。</p><h2 id="动态行为"><a href="#动态行为" class="headerlink" title="动态行为"></a>动态行为</h2><p>既然上面的鸭子行为实际上只是保存了一个引用，那么通过改变这个引用就可以实现在运行时改变行为了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFlyBehaviour</span><span class="hljs-params">(FlyBehaviour fb)</span></span>&#123;<br>    flyBehaviour = fb;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>将可能经常改变的部分和不太变化的部分分开实现</li><li>面向接口编程，而不是面向具体实现。</li></ol>]]></content>
      
      
      <categories>
          
          <category> DesignPatterns </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python绘制语法分析树</title>
      <link href="posts/bed86e5b/"/>
      <url>posts/bed86e5b/</url>
      
        <content type="html"><![CDATA[<h1 id="安装graphviz库"><a href="#安装graphviz库" class="headerlink" title="安装graphviz库"></a>安装graphviz库</h1><ol><li><p>安装对应软件包</p><p><a href="https://graphviz.org/download/">graphviz官网</a></p><p>我选的是<a href="https://gitlab.com/graphviz/graphviz/-/package_files/9574245/download">stable_windows_10_cmake_Release_x64_graphviz-install-2.47.1-win64.exe</a></p></li><li><p>安装python库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install graphviz<br></code></pre></td></tr></table></figure></li></ol><h1 id="解析语法分析器输出"><a href="#解析语法分析器输出" class="headerlink" title="解析语法分析器输出"></a>解析语法分析器输出</h1><p>在<a href="/posts/bf30e3e0">LL(1)无回溯的递归下降语法分析器</a>里实现了语法分析器。要获取语法分析的输出，只需要将构建脚本中的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">parser.exe code.txt<br></code></pre></td></tr></table></figure><p>改为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">parser.exe code.txt &gt; output.txt<br></code></pre></td></tr></table></figure><p>这样就将输出的结果重定向到了<code>output.txt</code>。</p><p>得到的<code>output.txt</code>中每一行的格式类似于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">parent -&gt; child1 child2 child3 ...<br></code></pre></td></tr></table></figure><p>按照空格分隔，第一个是父节点名，第二个是<code>-&gt;</code>，之后是一系列子节点名。</p><p>按照<code>最左推导</code>的定义，如果<code>child1</code>是非终结符，则<code>child1</code>有子节点，并且一定就在下一行，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">parent -&gt; child1 child2 child3 ...<br>child1 -&gt; child11 child12 ...<br></code></pre></td></tr></table></figure><p>否则依次考虑<code>child2</code>、<code>child3</code>…</p><p>所以这是一个深度优先遍历语法分析树的过程，只要用一个栈就可以将这棵树建立起来。</p><h1 id="graphviz绘图"><a href="#graphviz绘图" class="headerlink" title="graphviz绘图"></a>graphviz绘图</h1><p><code>graphviz</code>中<code>Digraph</code>和<code>Graph</code>分别对应有向图和无向图，这里使用的是无向图。</p><p>其基本用法是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">dot = Graph()  <span class="hljs-comment"># 新建无向图</span><br>dot.node(<span class="hljs-string">&#x27;node_name0&#x27;</span>, <span class="hljs-string">&#x27;node_label0&#x27;</span>)  <span class="hljs-comment"># 添加节点，其中node_name是用来唯一标识节点的，node_label则用来显示</span><br>dot.node(<span class="hljs-string">&#x27;node_name1&#x27;</span>, <span class="hljs-string">&#x27;node_label1&#x27;</span>)<br>dot.edge(<span class="hljs-string">&#x27;node_name0&#x27;</span>, <span class="hljs-string">&#x27;node_name1&#x27;</span>)  <span class="hljs-comment"># 添加边: 从node_name0到node_name1</span><br>dot.render(<span class="hljs-string">&#x27;output_name&#x27;</span>, <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;svg&#x27;</span>, view=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 指定输出名、格式，并查看结果</span><br></code></pre></td></tr></table></figure><h1 id="完整代码-amp-测试运行"><a href="#完整代码-amp-测试运行" class="headerlink" title="完整代码&amp;测试运行"></a>完整代码&amp;测试运行</h1><p><code>test.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*-coding:utf-8 -*-</span><br><br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> graphviz <span class="hljs-keyword">import</span> Graph<br><br>dot = Graph()<br>nodes_cnt = <span class="hljs-number">0</span>  <span class="hljs-comment"># 用来标识节点</span><br><br>lines = []<br>words_stk = []  <span class="hljs-comment"># (node0, name)</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new_node</span>(<span class="hljs-params">label: <span class="hljs-built_in">str</span></span>) -&gt; str:</span>  <span class="hljs-comment"># 新建节点并返回其标识</span><br>    <span class="hljs-keyword">global</span> nodes_cnt<br>    new_node_name = <span class="hljs-string">&#x27;node&#x27;</span> + <span class="hljs-built_in">str</span>(nodes_cnt)<br>    dot.node(new_node_name, label)<br>    nodes_cnt += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> new_node_name<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw</span>():</span>  <span class="hljs-comment"># 构建语法分析树</span><br>    <span class="hljs-comment"># 树根</span><br>    words_stk.append((<span class="hljs-string">&#x27;Program&#x27;</span>, new_node(<span class="hljs-string">&#x27;Program&#x27;</span>)))<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines:<br>        words = line.split()<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(words) &gt; <span class="hljs-number">2</span>:<br>            parent = words[<span class="hljs-number">0</span>]<br>            <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(words_stk) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> words_stk[<span class="hljs-built_in">len</span>(words_stk) - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] != parent:  <span class="hljs-comment"># 之前的(如果有)一定都是叶子</span><br>                words_stk.pop()<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(words_stk) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> words_stk[<span class="hljs-built_in">len</span>(words_stk)-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] == parent:  <span class="hljs-comment"># 继续进入最左子树(此节点已经创建过)</span><br>                parent_name = words_stk.pop()[<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">else</span>:<br>                parent_name = new_node(parent)  <span class="hljs-comment"># parent一定是已经作为子节点创建过了，一定不会进入此分支，否则说明语法分析出错</span><br>                print(<span class="hljs-string">&#x27;Error at node: &#x27;</span> + parent_name + <span class="hljs-string">&#x27; &#x27;</span> + parent)<br>            tmp = []<br>            <span class="hljs-comment"># 从左到右创建子节点, words[0]为parent, words[1]为&#x27;-&gt;&#x27;</span><br>            <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> words[<span class="hljs-number">2</span>:]:  <span class="hljs-comment"># 添加子节点</span><br>                child_name = new_node(child)<br>                tmp.append((child, child_name))<br>                dot.edge(parent_name, child_name)<br>            <span class="hljs-comment"># 从右到左入栈</span><br>            <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(tmp) &gt; <span class="hljs-number">0</span>:<br>                words_stk.append(tmp.pop())<br>    dot.render(<span class="hljs-string">&#x27;test&#x27;</span>, <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;svg&#x27;</span>, view=<span class="hljs-literal">True</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">has_error</span>() -&gt; bool:</span>  <span class="hljs-comment"># 词法分析器输出错误或未知</span><br>    has_err = <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines:<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;Error&#x27;</span> <span class="hljs-keyword">in</span> line <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;Unknown&#x27;</span> <span class="hljs-keyword">in</span> line:<br>            has_err = <span class="hljs-literal">True</span><br>            print(line)<br>    <span class="hljs-keyword">return</span> has_err<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) &gt; <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> sys.argv[<span class="hljs-number">1</span>:]:  <span class="hljs-comment"># 对命令行参数里指定的每个文件进行处理</span><br>            print(<span class="hljs-string">&#x27;Processing file: &#x27;</span>+file)<br>            lines = <span class="hljs-built_in">open</span>(file, <span class="hljs-string">&#x27;r&#x27;</span>).readlines()<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> has_error():  <span class="hljs-comment"># 有错误就不进行处理</span><br>                draw()<br>    <span class="hljs-keyword">else</span>:<br>        print(<span class="hljs-string">&#x27;No input file!&#x27;</span>)<br><br><br></code></pre></td></tr></table></figure><p><code>output.txt</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs plain">Program-&gt; Block<br>Block-&gt; &#123; Decls Stmts &#125;<br>Decls-&gt; Decl Decls<br>Decl-&gt; Type id ;<br>Type-&gt; int<br>Decls-&gt; epsilon<br>Stmts-&gt; Stmt Stmts<br>Stmt-&gt; id &#x3D; Expr ;<br>Expr-&gt; Term Expr1<br>Term-&gt; Factor Term1<br>Factor-&gt; num<br>Term1-&gt; epsilon<br>Expr1-&gt; epsilon<br>Stmts-&gt; Stmt Stmts<br>Stmt-&gt; while ( Bool ) Stmt<br>Bool-&gt; Expr Bool1<br>Expr-&gt; Term Expr1<br>Term-&gt; Factor Term1<br>Factor-&gt; id<br>Term1-&gt; epsilon<br>Expr1-&gt; epsilon<br>Bool1-&gt; &lt;&#x3D; Expr<br>Expr-&gt; Term Expr1<br>Term-&gt; Factor Term1<br>Factor-&gt; num<br>Term1-&gt; epsilon<br>Expr1-&gt; epsilon<br>Stmt-&gt; Block<br>Block-&gt; &#123; Decls Stmts &#125;<br>Decls-&gt; epsilon<br>Stmts-&gt; Stmt Stmts<br>Stmt-&gt; id &#x3D; Expr ;<br>Expr-&gt; Term Expr1<br>Term-&gt; Factor Term1<br>Factor-&gt; id<br>Term1-&gt; epsilon<br>Expr1-&gt; + Term Expr1<br>Term-&gt; Factor Term1<br>Factor-&gt; id<br>Term1-&gt; epsilon<br>Expr1-&gt; epsilon<br>Stmts-&gt; Stmt Stmts<br>Stmt-&gt; id &#x3D; Expr ;<br>Expr-&gt; Term Expr1<br>Term-&gt; Factor Term1<br>Factor-&gt; id<br>Term1-&gt; epsilon<br>Expr1-&gt; + Term Expr1<br>Term-&gt; Factor Term1<br>Factor-&gt; num<br>Term1-&gt; epsilon<br>Expr1-&gt; epsilon<br>Stmts-&gt; epsilon<br>Stmts-&gt; epsilon<br><br></code></pre></td></tr></table></figure><p>在构建脚本中添加或手动运行:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python test.py output.txt<br></code></pre></td></tr></table></figure><p>输出：</p><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21/04/11/test.svg" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Complier </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>板子基础总结</title>
      <link href="posts/a4ac75aa/"/>
      <url>posts/a4ac75aa/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>说明<ol><li>用C库中的输入输出更快。</li><li>1s的时间复杂度限制大约可以进行 $10^7$ 的运算，再根据输入数据的规模可以猜到应该使用什么复杂度的算法。</li><li>要用到的空间用类似于<code>constexpr int N = 1e5</code>的方法进行静态开辟。</li><li>同样根据数据规模确定<code>int</code>会不会溢出</li><li>命名规则都比较简洁，用自己喜欢的风格就行。</li></ol></li></ul><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>用两个数组，<code>e</code>， <code>ne</code>，头<code>h</code>，个数<code>idx</code>，第k个插入的数在k-1</p><ul><li><code>e[N]</code>：数组元素。<code>ne[N]</code>下一个元素的数组下标。</li><li>不添加额外的头节点，<code>h</code>：第一个节点的数组下标。</li><li>数组中的元素个数为<code>idx</code>，也是下一个可以用来存放新元素的数组下标</li></ul><p><a href="https://www.acwing.com/problem/content/828/">单链表</a></p><p><em>注意题中的<code>k</code>是插入的第<code>k</code>个而不是从前向后遍历到的第<code>k</code>个。所以这里的<code>k-1</code>正好就是对应元素的数组下标</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e5</span>;<br><span class="hljs-keyword">int</span> e[N], ne[N], h, idx;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span>&#123;<br>    h = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 第一个节点</span><br>    idx = <span class="hljs-number">0</span>; <span class="hljs-comment">// 下一个存储位</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Head</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    e[idx] = x;<br>    ne[idx] = h;<br>    h = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    k--;<br>    e[idx] = x;<br>    ne[idx] = ne[k];<br>    ne[k] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span>&#123;<br>    k--;<br>    ne[k] = ne[ne[k]];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> M;<br>    <span class="hljs-keyword">char</span> op;<br>    <span class="hljs-keyword">int</span> k, x;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; M;<br>    Init();<br>    <span class="hljs-keyword">while</span>(M--)&#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; op;<br>        <span class="hljs-keyword">switch</span>(op)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;H&#x27;</span>:<br>                <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>                Head(x);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;D&#x27;</span>:<br>                <span class="hljs-built_in">cin</span> &gt;&gt; k;<br>                <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>)&#123;<br>                    h = ne[h]; <span class="hljs-comment">// 删除头部</span><br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    Delete(k);<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;I&#x27;</span>:<br>                <span class="hljs-built_in">cin</span> &gt;&gt; k &gt;&gt; x;<br>                Insert(k, x);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = h; i != <span class="hljs-number">-1</span>; i = ne[i])&#123; <span class="hljs-comment">// h开始，-1结束</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, e[i]);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><p><a href="https://www.acwing.com/problem/content/829/">双链表</a></p><ul><li><code>e</code>：数组元素，<code>l</code>：左边的下标，<code>r</code>：右边的下标。加入额外的<code>头节点0</code>和<code>尾节点1</code>。第k个插入的数在<code>k+1</code>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span>;<br><br><span class="hljs-keyword">int</span> l[N], r[N], e[N], idx;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span>&#123;<br>    r[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 头-&gt;尾</span><br>    l[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 尾-&gt;头</span><br>    idx = <span class="hljs-number">2</span>; <span class="hljs-comment">// 下一个存储位</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InsertL</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123; <span class="hljs-comment">// 头插</span><br>    e[idx] = x; <span class="hljs-comment">// 存储</span><br>    l[idx] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 左指向头</span><br>    r[idx] = r[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 右指向第一个</span><br>    r[<span class="hljs-number">0</span>] = idx;<br>    l[r[idx]] = idx;<br>    idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InsertR</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123; <span class="hljs-comment">// 尾插</span><br>    e[idx] = x;<br>    l[idx] = l[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 左指向最后一个</span><br>    r[idx] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 右指向尾</span><br>    r[l[idx]] = idx;<br>    l[<span class="hljs-number">1</span>] = idx;<br>    idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span>&#123;<br>    k++;<br>    r[l[k]] = r[k];<br>    l[r[k]] = l[k];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InsertKL</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    k++;<br>    e[idx] = x;<br>    l[idx] = l[k];<br>    r[idx] = k;<br>    r[l[idx]] = idx;<br>    l[k] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InsertKR</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    k++;<br>    e[idx] = x;<br>    l[idx] = k;<br>    r[idx] = r[k];<br>    l[r[idx]] = idx;<br>    r[k] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> M, k, x;<br>    <span class="hljs-built_in">string</span> s;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; M;<br>    Init();<br>    <span class="hljs-keyword">while</span>(M--)&#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; s;<br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;L&quot;</span>)&#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>            InsertL(x);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;R&quot;</span>)&#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>            InsertR(x);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;D&quot;</span>)&#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; k;<br>            Delete(k);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;IL&quot;</span>)&#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; k &gt;&gt; x;<br>            InsertKL(k, x);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; k &gt;&gt; x;<br>            InsertKR(k, x);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = r[<span class="hljs-number">0</span>]; i != <span class="hljs-number">1</span>; i = r[i])&#123; <span class="hljs-comment">// r[0]开始，1结束</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, e[i]);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><ul><li><code>stk</code>：栈。 <code>e</code>：栈中元素在原序列中的下标。 <code>tt</code>：栈顶元素下标，0号不存。</li><li><code>q</code>：队列。<code>hh</code>：队头。 <code>tt</code>：队尾。</li></ul><p><a href="https://www.luogu.com.cn/problem/P5788">单调栈</a></p><p>从后向前扫描，比较栈顶，如果大则就是后面最靠近的大数，否则一直出栈，如果空，则表明后面没有大的数，结果为0（结果保存在数组<code>q</code>中，要逆序输出）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">3000000</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> stk[N], e[N], tt, a[N], q[N], qq;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">while</span> (tt &amp;&amp; stk[tt] &lt;= a[i]) &#123; <span class="hljs-comment">// 将小的都出栈</span><br>            tt--;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (tt == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 栈空，没有大的</span><br>            q[qq++] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 结果为0</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            q[qq++] = e[tt]; <span class="hljs-comment">// 否则就是 对应元素的下标</span><br>        &#125;<br>        stk[++tt] = a[i]; <span class="hljs-comment">// 将这个元素也入栈</span><br>        e[tt] = i; <span class="hljs-comment">// 同时保存其原下标</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = qq - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123; <span class="hljs-comment">// 逆序输出</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, q[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p><a href="https://www.acwing.com/file_system/file/content/whole/index/content/118289/">Trie字符统计</a></p><p><code>p[N][27]</code>：保存下一个节点在数组中的下标，根为<code>p[0]</code>，每个节点可以保存26个字母，从而保存一系列字符串，对应字符串最后一节点加标记。<code>cnt[N]</code>记录每个节点对应字符串出现次数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> p[N][<span class="hljs-number">27</span>], cnt[N], idx = <span class="hljs-number">1</span>; <span class="hljs-comment">// idx为下一个可存储节点的数组下标</span><br><span class="hljs-keyword">char</span> s[N]; <span class="hljs-comment">// 输入的字符串</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; s[i]; i++) &#123;<br>        <span class="hljs-keyword">int</span> u = s[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (p[j][u] == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 没有存储这个字符</span><br>            p[j][u] = idx++; <span class="hljs-comment">// “开辟新节点”以表示存储(u对应存到idx)</span><br>        &#125;<br>        j = p[j][u]; <span class="hljs-comment">// 进入到下一个节点</span><br>    &#125;<br>    cnt[j]++; <span class="hljs-comment">// 到最后一个字符节点之后添加标记</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; s[i]; i++) &#123;<br>        <span class="hljs-keyword">int</span> u = s[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (p[j][u] == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 字符串中这个字符未被存储</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 就不存在这个字符串</span><br>        &#125;<br>        j = p[j][u];<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt[j]; <span class="hljs-comment">// 返回标记值（累积存储字符串次数）</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">char</span> op[<span class="hljs-number">2</span>];<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">while</span> (n--) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%s&quot;</span>, op, s); <span class="hljs-comment">// op中有&#x27;\0&#x27;所以要%s而不是%c</span><br>        <span class="hljs-keyword">if</span> (op[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;I&#x27;</span>) &#123;<br>            Add(s);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, Find(s));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="快速排序模板"><a href="#快速排序模板" class="headerlink" title="快速排序模板"></a>快速排序模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> arr[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> x = arr[l+((r-l)&gt;&gt;<span class="hljs-number">1</span>)], i = l<span class="hljs-number">-1</span>, j = r+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(arr[i] &lt; x); <span class="hljs-comment">// 不会越界，因为最多到达x，会因为相等而停下</span><br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(arr[j] &gt; x);<br>        <span class="hljs-keyword">if</span>(i &lt; j) swap(arr[i], arr[j]);<br>    &#125;<br>    QuickSort(l, j);<br>    QuickSort(j+<span class="hljs-number">1</span>, r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, arr+i);<br>    &#125;<br>    QuickSort(<span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, arr[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通常还是用<code>&lt;algorithm&gt;</code>中的<code>std::sort()</code>，如果要从大到小排：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br>...<br>sort(arr, arr+n, cmp);<br></code></pre></td></tr></table></figure><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><p>扫描一遍并保存在<code>S</code>中之后，快速求指定范围的和</p><p>递归公式：（0号下标保持为0，这样不会溢出）</p><ul><li><p>一维数组递推：<script type="math/tex">S_i=S_{i-1}+a_i</script></p><p>快速求指定范围数组和：<script type="math/tex">Sum_{i,j}=S_j-S_{i-1}</script></p></li><li><p>二维数组递推：<script type="math/tex">S_{i,j}=S_{i-1,j}+S_{i,j-1}-S_{i-1,j-1}+a_{i,j}</script></p><p>快速求指定两点之间形成的矩形：<script type="math/tex">Sum_{(x,y),(i,j)}=S_{i,j}-S_{x-1,j}-S_{i,y-1}+S_{x-1,y-1}</script></p><p><em>边界部分要根据题意取舍</em></p></li></ul><p><strong>注意：如果要求的范围超出原数组，则结果是整个数组的和</strong></p><p>为了优化空间，实际<code>Sum</code>和<code>S</code>共用一个数组</p><p><a href="https://www.acwing.com/problem/content/description/101/">激光炸弹</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">5000</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> f[N][N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n, r;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; r;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        <span class="hljs-keyword">int</span> x, y, w;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;w);<br>        f[x+<span class="hljs-number">1</span>][y+<span class="hljs-number">1</span>] += w; <span class="hljs-comment">// 0号不存</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; N; j++)&#123; <span class="hljs-comment">// 求前缀和</span><br>            f[i][j] = f[i<span class="hljs-number">-1</span>][j] + f[i][j<span class="hljs-number">-1</span>] - f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + f[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(r &gt;= N)&#123; <span class="hljs-comment">// 涵盖原数组</span><br>        ans = f[N<span class="hljs-number">-1</span>][N<span class="hljs-number">-1</span>];<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = r; i &lt; N; i++)&#123; <span class="hljs-comment">// 从r开始遍历，1.防越界，2.避免不必要的搜索</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = r; j &lt; N; j++)&#123;<br>                <span class="hljs-comment">// x=i-r+1，画图易得</span><br>                ans = max(ans, f[i][j] - f[i-r][j] - f[i][j-r] + f[i-r][j-r]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><p>相邻两项之差（0号下标恒为0）</p><p>递推：<script type="math/tex">b_i=a_i-a_{i-1}</script></p><p>用于快速将指定范围内的数加上同一个数<code>c</code>：<script type="math/tex">b_l += c; b_{r+1} -= c</script></p><p>(<script type="math/tex">b_l=a_l-a_{l-1}, b_{l+1}=a_{l+1}-a_l...b_{r+1}=a_{r+1}-a_{r}</script>刚好中间的都消掉了，只需要改变首尾)</p><p>改变之后的原数组元素：<script type="math/tex">a_i=\sum_{1}^{i}b_i</script>，用一个数累加即可。</p><p><a href="https://www.acwing.com/problem/content/799/">差分</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> b[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n, m;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, b+i);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n; i &gt;= <span class="hljs-number">2</span>; i--)&#123;<br>        b[i] -= b[i<span class="hljs-number">-1</span>];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-keyword">int</span> l, r, c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;c);<br>        b[l] += c;<br>        b[r+<span class="hljs-number">1</span>] -= c;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, a = <span class="hljs-number">0</span>; i &lt;= n; i++)&#123;<br>        a += b[i];<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>两种方法，结合可用来查找相同值所在的范围（而不是只查找一个）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> t)</span> </span>&#123; <span class="hljs-comment">// 第一个t</span><br>    <span class="hljs-keyword">if</span> (l &gt; r) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (arr[mid] &lt; t) l = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> r = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> t)</span> </span>&#123; <span class="hljs-comment">// 最后一个t</span><br>    <span class="hljs-keyword">if</span> (l &gt; r) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (arr[mid] &gt; t) r = mid - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br>...<br><span class="hljs-keyword">int</span> arr[] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span> ,<span class="hljs-number">3</span> ,<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span> ,<span class="hljs-number">5</span> &#125;;<br><span class="hljs-built_in">cout</span> &lt;&lt; Find1(arr, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>) &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 3 第一个在3</span><br><span class="hljs-built_in">cout</span> &lt;&lt; Find2(arr, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>) &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 5 最后一个在5</span><br></code></pre></td></tr></table></figure><h3 id="其他应用"><a href="#其他应用" class="headerlink" title="其他应用"></a>其他应用</h3><ul><li>解立方根</li></ul><p><a href="https://www.acwing.com/problem/content/792/">数的三次方根</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">double</span> n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">double</span> l = <span class="hljs-number">-10000</span>, r = <span class="hljs-number">10000</span>;<br>    <span class="hljs-keyword">while</span>(r-l &gt; <span class="hljs-number">1e-7</span>)&#123; <span class="hljs-comment">// 1e-6精度不足</span><br>        <span class="hljs-keyword">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(mid * mid * mid &lt; n) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid;<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.6f&quot;</span>, l);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="搜索问题答案"><a href="#搜索问题答案" class="headerlink" title="搜索问题答案"></a>搜索问题答案</h3><p><a href="https://www.acwing.com/problem/content/description/104/">最佳牛围栏</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100005</span>;<br><span class="hljs-keyword">int</span> cows[N]; <span class="hljs-keyword">double</span> sum[N];<br><span class="hljs-keyword">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">double</span> avg)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        sum[i] = sum[i - <span class="hljs-number">1</span>] + (cows[i] - avg); <span class="hljs-comment">//计算前缀和(与均值之差)</span><br>    &#125;<br><br>    <span class="hljs-keyword">double</span> minv = <span class="hljs-number">0</span>; <span class="hljs-comment">//设置最小值(圈地范围前面的)</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = m; j &lt;= n; j++, i++) &#123; <span class="hljs-comment">// 圈地为i+1~j(共m块)</span><br>        minv = <span class="hljs-built_in">std</span>::min(minv, sum[i]); <span class="hljs-comment">//找最优极小值(与均值之差的累积)</span><br>        <span class="hljs-keyword">if</span>(sum[j] - minv &gt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//进行判断(从最小值那里到j区间中的均值&gt;=avg)</span><br>         <span class="hljs-comment">// avg小了</span><br>    &#125; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//如果所有的都不满足，那么这个平均数就一定不满足(avg大了)</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m); <span class="hljs-comment">// 共n块地，至少围m块地</span><br>    <span class="hljs-keyword">double</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123; <span class="hljs-comment">//最小左区间 最大右区间</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;cows[i]); <br>        r = <span class="hljs-built_in">std</span>::max(r, (<span class="hljs-keyword">double</span>)cows[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(r - l &gt; <span class="hljs-number">1e-5</span>) &#123; <span class="hljs-comment">//开始二分 因为是实数所以这里还搞个精度</span><br>        <span class="hljs-keyword">double</span> mid = (l + r) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 不是&gt;&gt;1 这里是实数</span><br>        <span class="hljs-keyword">if</span>(check(mid)) l = mid; <span class="hljs-comment">//将问题转变为判定问题</span><br>        <span class="hljs-keyword">else</span> r = mid;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, (<span class="hljs-keyword">int</span>)(r * <span class="hljs-number">1000</span>)); <span class="hljs-comment">//因为我们找的极大值 所以要右端点*1000 否则可能会出错</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="二进制运算"><a href="#二进制运算" class="headerlink" title="二进制运算"></a>二进制运算</h2><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>&amp;, |, ^, ~, &lt;&lt;, &gt;&gt;</p><ol><li>第k位(最低位为第0位)：<code>x &gt;&gt; k &amp; 1</code></li><li>从右向左第一个1：<code>x &amp; -x</code></li></ol><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// a^b % p</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> p)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(b)&#123;<br>        <span class="hljs-keyword">if</span>(b &amp; <span class="hljs-number">1</span>)&#123;<br>            res = (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)res * a % p;<br>        &#125;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>        a = (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)a * a %p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>快速判断集合合并以及判断两元素是否属于同一集合。用一个数组实现（保存其所在集合中的父），类似一棵树。</p><p>如果是二维则通过换算坐标转换成一维数组。</p><p>如果要统计集合中的总数，另设一个数组，合并时合并集合中的总个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> p[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a != p[a]) p[a] = find(p[a]); <span class="hljs-comment">// 路径压缩</span><br>    <span class="hljs-keyword">return</span> p[a];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> m, n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123; <span class="hljs-comment">// 初始化为每个集合一个</span><br>        p[i] = i;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-keyword">char</span> op[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%d%d&quot;</span>, op, &amp;a, &amp;b);<br>        <span class="hljs-keyword">if</span>(op[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;M&#x27;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(find(a) != find(b))&#123;<br>                p[find(a)] = find(b); <span class="hljs-comment">// 集合合并(合并根)</span><br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(find(a) == find(b))&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="DFS-amp-BFS"><a href="#DFS-amp-BFS" class="headerlink" title="DFS &amp; BFS"></a>DFS &amp; BFS</h2><p>DFS，栈或递归，回溯</p><h3 id="n皇后"><a href="#n皇后" class="headerlink" title="n皇后"></a>n皇后</h3><p><a href="https://www.acwing.com/problem/content/845/">n-皇后问题</a></p><p>不能同行，同列，同斜线</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">char</span> mp[N][N]; <span class="hljs-comment">// 棋盘</span><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">bool</span> col[N], g[<span class="hljs-number">2</span>*N], ug[<span class="hljs-number">2</span>*N]; <span class="hljs-comment">// 判断同列，同斜线(2N条!)，同反斜线（由于按行遍历，不需要增加行的）</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span>&#123; <span class="hljs-comment">// 枚举到第u行(共0~n-1行)</span><br>    <span class="hljs-keyword">if</span>(n == u)&#123; <span class="hljs-comment">// 一个完整的方案</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, mp[i]); <span class="hljs-comment">// 有0，所以可当字符串输出</span><br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ;i &lt; n; i++)&#123; <span class="hljs-comment">// 当前行u，遍历可能的列（0~n-1）</span><br>        <span class="hljs-keyword">if</span>(col[i] || g[i+u] || ug[n+u-i])&#123; <span class="hljs-comment">// 以左上角建坐标，同斜线的x+y相同</span><br>            <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 同反斜线的x-y相同(防止负数，统一加n)</span><br>        &#125;<br>        col[i] = g[i+u] = ug[n+u-i] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记</span><br>        mp[u][i] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>        dfs(u+<span class="hljs-number">1</span>); <span class="hljs-comment">// 放下一行</span><br>        col[i] = g[i+u] = ug[n+u-i] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 回溯</span><br>        mp[u][i] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i= <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n ; j++)&#123;<br>            mp[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>; <span class="hljs-comment">// 初始化</span><br>        &#125;<br>    &#125;<br>    dfs(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>BFS</p><p>队列，最短路径(权值相同)</p><h3 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h3><p>n*m的二维数组，0可走，1不可走。从左上角(0,0)开始，可以按上下左右移动，到达(n-1,m-1)最少需要移动多少次？((0,0)和(n-1,m-1)处数字必为0，且至少有一条路，数据规模1~100)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">110</span>;<br><br><span class="hljs-keyword">int</span> qx[N*N], qy[N*N]; <span class="hljs-comment">// 队列</span><br><span class="hljs-keyword">int</span> n, m, dd, tt=<span class="hljs-number">-1</span>; <span class="hljs-comment">// dd, tt为队头队尾</span><br><br><span class="hljs-keyword">int</span> mp[N][N], d[N][N]; <span class="hljs-comment">// 地图，距离（-1为没有走过）</span><br><br><span class="hljs-keyword">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<br>    qx[++tt] = <span class="hljs-number">0</span>; qy[tt] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 入队</span><br>    d[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(dd &lt;= tt)&#123; <span class="hljs-comment">// 队列非空</span><br>        <span class="hljs-keyword">int</span> x = qx[dd], y = qy[dd++]; <span class="hljs-comment">// 出队</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt; <span class="hljs-number">4</span>;i++)&#123;<br>            <span class="hljs-keyword">int</span> ix=x+dx[i], iy=y+dy[i];<br>            <span class="hljs-comment">// 越界，走过，不可走</span><br>            <span class="hljs-keyword">if</span>(ix&lt;<span class="hljs-number">0</span>||iy&lt;<span class="hljs-number">0</span>|| ix&gt;=n||iy&gt;=m || d[ix][iy]!=<span class="hljs-number">-1</span> || mp[ix][iy]==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            qx[++tt]=ix; qy[tt]=iy; <span class="hljs-comment">// 入队</span><br>            d[ix][iy]=d[x][y]+<span class="hljs-number">1</span>; <span class="hljs-comment">// 到起点的距离（步数）</span><br>            <span class="hljs-keyword">if</span>(ix==n<span class="hljs-number">-1</span>&amp;&amp;iy==m<span class="hljs-number">-1</span>)&#123; <span class="hljs-comment">// 已到达终点，那么这就是最小值！</span><br>                <span class="hljs-keyword">return</span> d[ix][iy]; <span class="hljs-comment">// 广度搜索，之后的路径距离更大</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j &lt; m;j++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, mp[i]+j);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d); <span class="hljs-comment">// 初始化为没有走过（距离-1）</span><br>       <span class="hljs-comment">// 只能初始化字节相同的int，如0，-1，0x3f3f3f3f,0x7f7f7f7f</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; bfs();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中队列可以用STL的<code>push</code>,<code>front</code>,<code>pop</code>,<code>size</code>,<code>empty</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-keyword">int</span> x, y;<br>&#125;Node;<br><br>q.push(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;); <span class="hljs-comment">// 临时结构体</span><br></code></pre></td></tr></table></figure><h3 id="八数码"><a href="#八数码" class="headerlink" title="八数码"></a>八数码</h3><p><a href="https://www.acwing.com/problem/content/847/">八数码</a></p><p>保存网格状态：用<code>string</code></p><p>网格状态对应交换的次数：用<code>map&lt;string, int&gt;</code>，<code>map.count</code>判断状态不重复</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-built_in">string</span> start;<span class="hljs-comment">// 初始状态</span><br><span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; d; <span class="hljs-comment">// 用map会超时</span><br><br><span class="hljs-keyword">int</span> dx[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span> &#125;;<br><span class="hljs-keyword">int</span> dy[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span> &#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-built_in">string</span>&gt; q;<br>    q.push(start); <span class="hljs-comment">// 初始入队</span><br>    d[start] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 移动了0步</span><br>    <span class="hljs-keyword">while</span> (!q.empty()) &#123;<br>        <span class="hljs-built_in">string</span> t = q.front(); <span class="hljs-comment">// 取出一个状态</span><br>        q.pop();<br>        <span class="hljs-keyword">int</span> x, y; <span class="hljs-comment">// 此状态中&#x27;x&#x27;坐标</span><br>        <span class="hljs-keyword">int</span> id = d[t]; <span class="hljs-comment">// 此状态已经交换的次数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (t[i] == <span class="hljs-string">&#x27;x&#x27;</span>) &#123;<br>                x = i / <span class="hljs-number">3</span>;<br>                y = i % <span class="hljs-number">3</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123; <span class="hljs-comment">// 尝试四个方向</span><br>            <span class="hljs-keyword">int</span> ix = x + dx[i], iy = y + dy[i];<br>            <span class="hljs-keyword">if</span> (ix &lt; <span class="hljs-number">0</span> || ix&gt;<span class="hljs-number">2</span> || iy &lt; <span class="hljs-number">0</span> || iy&gt;<span class="hljs-number">2</span>) &#123; <span class="hljs-comment">// 越界</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            swap(t[x * <span class="hljs-number">3</span> + y], t[ix * <span class="hljs-number">3</span> + iy]); <span class="hljs-comment">// 将x与下一步的格子交换，进入下一个状态</span><br>            <span class="hljs-keyword">if</span> (d.count(t)) &#123; <span class="hljs-comment">// 状态存在过</span><br>                swap(t[x * <span class="hljs-number">3</span> + y], t[ix * <span class="hljs-number">3</span> + iy]);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            q.push(t); <span class="hljs-comment">// 入队</span><br>            d[t] = id + <span class="hljs-number">1</span>; <span class="hljs-comment">// 计算距离</span><br>            <span class="hljs-keyword">if</span> (t == <span class="hljs-string">&quot;12345678x&quot;</span>) &#123; <span class="hljs-comment">// 已结束</span><br>                <span class="hljs-keyword">return</span> d[t];<br>            &#125;<br>            swap(t[x * <span class="hljs-number">3</span> + y], t[ix * <span class="hljs-number">3</span> + iy]); <span class="hljs-comment">// 因为四个方向的尝试共用一个string，要记得恢复</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 没有路径</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> ch;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c &quot;</span>, &amp;ch); <span class="hljs-comment">// 输入有空格</span><br>        start += ch;<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; bfs() &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果不能使用<code>unordered_map</code>，使用<code>map</code>会超时,需要手动哈希</p><h4 id="手动映射-康托展开"><a href="#手动映射-康托展开" class="headerlink" title="手动映射-康托展开"></a>手动映射-康托展开</h4><p>对于全排列的哈希，可以使用<code>康托展开</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> fac[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">24</span>,<span class="hljs-number">120</span>,<span class="hljs-number">720</span>,<span class="hljs-number">5040</span>,<span class="hljs-number">40320</span>,<span class="hljs-number">362880</span>&#125;;<br><span class="hljs-comment">//         0!1!2!3! 4! 5!  6!  7!   8!    9!</span><br><span class="hljs-comment">// 将一个全排列映射到其在所有排列中的次序</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cantor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s[])</span></span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++)&#123;<br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">// 小于当前位的个数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">9</span>; j++)&#123;<br>            <span class="hljs-keyword">if</span>(s[j] &lt; s[i]) cnt++;<br>        &#125;<br>        sum += (cnt * fac[<span class="hljs-number">9</span>-i<span class="hljs-number">-1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum+<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">decantor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v;  <span class="hljs-comment">// 存放当前可选数</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; a;  <span class="hljs-comment">// 所求排列组合</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        v.push_back(i);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> r = x % FAC[i<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">int</span> t = x / FAC[i<span class="hljs-number">-1</span>];<br>        x = r;<br>        sort(v.begin(),v.end());<span class="hljs-comment">// 从小到大排序</span><br>        a.push_back(v[t]);      <span class="hljs-comment">// 剩余数里第t+1个数为当前位</span><br>        v.erase(v.begin()+t);   <span class="hljs-comment">// 移除选做当前位的数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>另一种理解是变进制数，也就是转换成十进制时，<code>i</code>位的权值为<code>i!</code></p><p>9位字符串排列共<code>9!</code>个，而</p><script type="math/tex; mode=display">1\times1!+2\times2!+...+8\times8! \\= 1+1\times1!+2\times2!+...+8\times8!-1 \\= 2!+2\times2!+3\times3!+...+8\times8!-1 \\=...= 9!-1</script><p>所以变进制数恰好可以映射所有的字符串排列</p><p>首先用数组d统计每个数字前比其大的数字个数，分别对应权值<code>0!~8!</code>加权求和</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> f[<span class="hljs-number">10</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span>&#123;<br>    f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">9</span>; i++)&#123;<br>        f[i] = f[i<span class="hljs-number">-1</span>] * i;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Hash</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++)&#123;<br>        <span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>            <span class="hljs-keyword">if</span>(s[j] &gt; s[i]) col++;<br>        &#125;<br>        sum += f[i] * col; <span class="hljs-comment">// f[i] = i!</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>将字符串映射到<code>int</code>之后就可以用大小为9!=362880的数组保存对应状态的距离值，从而代替<code>unordered_map</code></p><h2 id="树与图的搜索"><a href="#树与图的搜索" class="headerlink" title="树与图的搜索"></a>树与图的搜索</h2><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>用邻接表（多个单链表）：<code>h[N]</code>是各个头节点，<code>e[N]</code>为元素，<code>ne</code>,<code>idx</code>与单链表定义相同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> h[N], e[N*<span class="hljs-number">2</span>], ne[N*<span class="hljs-number">2</span>], idx;<br><span class="hljs-keyword">bool</span> st[N]; <span class="hljs-comment">// 遍历过</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123; <span class="hljs-comment">// 添加一条边a-&gt;b</span><br>    e[idx] = b, ne[idx] = h[a], h[a] = idx++; <span class="hljs-comment">// 将这条边头插入a的邻接链表</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123; <span class="hljs-comment">// u当前节点，遍历其邻接链表</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>        <span class="hljs-keyword">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (st[j]) <span class="hljs-keyword">continue</span>;<br>        st[j] = <span class="hljs-literal">true</span>;<br>        dfs(j);<br>        st[j] = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="树的重心"><a href="#树的重心" class="headerlink" title="树的重心"></a>树的重心</h3><p>一棵树，n个节点（1~n），n-1条无向边，树的重心为：删除这个节点后，剩余各个连通块中节点数的最大值最小。找到其重心并输出删除重心之后剩余各个连通块中节点数的最大值。</p><p>输入n和n-1条边</p><p>遍历树，逐个尝试删除每个节点，其删除后的连通块为左子树、右子树和其余的，其中其余的可以通过n-左子树-右子树-1来算出。</p><p>这里的树可以看成是只有无向边的图，左右孩子就是其两个邻接节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n; <span class="hljs-comment">// 总节点数</span><br><span class="hljs-keyword">int</span> g[N]; <span class="hljs-comment">// 其余连通分支的节点最大数</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123; <span class="hljs-comment">// u当前节点，遍历其邻接链表，这里是左右孩子</span><br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">1</span>; <span class="hljs-comment">// 当前节点及其子树节点数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>        <span class="hljs-keyword">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (st[j]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//st[j] = true; // 因为遍历的是树，没有环，不会重复遍历节点</span><br>        <span class="hljs-keyword">int</span> col = dfs(j); <span class="hljs-comment">// col 累积左右孩子节点数</span><br>        <span class="hljs-keyword">if</span> (col &gt; g[u]) g[u] = col;<br>        sum += col;<br>        <span class="hljs-comment">//st[j] = false;</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (g[u] &lt; n - sum) g[u] = n - sum; <span class="hljs-comment">// 剩余节点数</span><br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123; <span class="hljs-comment">// n-1条边</span><br>        <span class="hljs-keyword">int</span> a, b;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b;<br>        add(a, b); <span class="hljs-comment">// 为了在邻接表中存储无向边，同时保存两有向边即可</span><br>        add(b, a);<br>    &#125;<br>    st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>    dfs(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">int</span> Min = <span class="hljs-number">0x3f3f3f3f</span>;<br>    <span class="hljs-comment">// 遍历g，得到Min</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>优化：改用一个Min全局记录，省去g数组。</p><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>有向无环图，BFS计算每个节点的入度。每去掉一个节点，就将其指向的每个节点的入度—，然后将其下入度为0的节点加入队列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> d[N]; <span class="hljs-comment">// 每个节点的入度</span><br><span class="hljs-keyword">int</span> q[N], dd, tt; <span class="hljs-comment">// 队列，队头，队尾</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">int</span> b;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; b &amp;&amp; b) &#123;<br>            add(i, b);<br>            d[b]++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (d[i] == <span class="hljs-number">0</span>) q[++tt] = i;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (dd &lt;= tt) &#123;<br>        <span class="hljs-keyword">int</span> t = q[dd++];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>            <span class="hljs-keyword">int</span> j = e[i];<br>            d[j]--;<br>            <span class="hljs-keyword">if</span> (d[j] == <span class="hljs-number">0</span>) q[++tt] = j;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123; <span class="hljs-comment">// 输出队列</span><br>        <span class="hljs-built_in">cout</span> &lt;&lt; q[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h3 id="无负权边"><a href="#无负权边" class="headerlink" title="无负权边"></a>无负权边</h3><h4 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h4><p>普通版</p><p><a href="https://www.acwing.com/problem/content/851/">Dijkstra求最短路</a></p><p>在还没有确定最短距离的点中选择dist最小的点，用它更新相邻且未确定的点的dist</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">510</span>;<br><br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> g[N][N], dist[N]; <span class="hljs-comment">// g为邻接矩阵，dist为距离起点的最短距离</span><br><span class="hljs-keyword">bool</span> st[N]; <span class="hljs-comment">//是否已经确定</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> t = n + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; dist[t] &gt; dist[j]) t = j; <span class="hljs-comment">// 找到未确定且距离最小的</span><br>        &#125;<br>        st[t] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; dist[t] + g[t][j] &lt; dist[j]) dist[j] = dist[t] + g[t][j]; <span class="hljs-comment">// 更新剩余点</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 路径不存在</span><br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> g);<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-keyword">int</span> x, y, z;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; z;<br>        <span class="hljs-keyword">if</span> (g[x][y] &gt; z) g[x][y] = z; <span class="hljs-comment">// 因为输入可能有重边，临界矩阵只保存最短的</span><br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; Dijkstra() &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>用邻接表更快</p><p><strong>堆优化</strong></p><p><a href="https://www.acwing.com/problem/content/852/">Dijkstra求最短路II</a></p><p>改用优先队列作为小顶堆，同时由于数据过大，不能用邻接矩阵，只能用邻接表存储。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PII pair<span class="hljs-meta-string">&lt;int, int&gt;</span></span><br>...<br><span class="hljs-comment">// 初始</span><br><span class="hljs-built_in">priority_queue</span>&lt;PII, <span class="hljs-built_in">vector</span>&lt;PII&gt;, greater&lt;PII&gt; &gt;Heap; <span class="hljs-comment">// 小顶堆，按照pair第一个元素排，注意写成&gt;&gt;可能编译错误</span><br>Heap.push(&#123; <span class="hljs-number">0</span>,<span class="hljs-number">1</span> &#125;); <span class="hljs-comment">// &#123;dist, id&#125;</span><br><br><span class="hljs-comment">// 之后取dist最小元素操作</span><br>PII t = Heap.top();<br>Heap.pop();<br><span class="hljs-keyword">int</span> id = t.second, d = t.first;<br><br><span class="hljs-comment">// 更新距离操作</span><br>dist[k] = d + w[j]; <span class="hljs-comment">// 为了方便遍历，仍需要dist数组</span><br>Heap.push(&#123;dist[k], k&#125;); <span class="hljs-comment">// 而原来的pair会因为dist较大而沉下（不需要删掉）</span><br></code></pre></td></tr></table></figure><h3 id="有负权边"><a href="#有负权边" class="headerlink" title="有负权边"></a>有负权边</h3><h4 id="Bellman-ford"><a href="#Bellman-ford" class="headerlink" title="Bellman-ford"></a>Bellman-ford</h4><p>只有当含有负权边并且题中指定了固定步数k时才可以使用</p><p>只保存图中的边，还需要备份dist的backup数组，与Dijkstra不同之处在于更新操作使用的是backup数组，</p><p><a href="https://www.acwing.com/problem/content/855/">有边数限制的最短路</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">int</span> dist[<span class="hljs-number">550</span>], bak[<span class="hljs-number">550</span>], n, m, k;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">N</span> &#123;</span><br>    <span class="hljs-keyword">int</span> a, b, c;<br>&#125;Ns[<span class="hljs-number">10010</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>        <span class="hljs-built_in">memcpy</span>(bak, dist, <span class="hljs-keyword">sizeof</span> dist);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-keyword">int</span> a = Ns[j].a, b = Ns[j].b, c = Ns[j].c;<br>            <span class="hljs-keyword">if</span> (bak[a] + c &lt; dist[b]) dist[b] = bak[a] + c; <span class="hljs-comment">// 使用bak更新</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dist[n] &gt; <span class="hljs-number">0x3f3f3f3f</span> / <span class="hljs-number">2</span>) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt; dist[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">int</span> a, b, c;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        Ns[i] = &#123; a,b,c &#125;;<br>    &#125;<br>    bellman_ford();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h4><p>类似于BFS，起点入队，一个点的dist被更新时，如果没有在队列里，则入队列。</p><p><a href="https://www.acwing.com/problem/content/853/">spfa求最短路</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> n, m, e[N], ne[N], h[N], w[N], idx, dist[N];<br><span class="hljs-keyword">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>    e[idx] = b; ne[idx] = h[a];<br>    w[idx] = c; h[a] = idx++; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;q;<br>    q.push(<span class="hljs-number">1</span>);<br>    st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span> (q.size()) &#123;<br>        <span class="hljs-keyword">int</span> t = q.front();<br>        q.pop();<br>        st[t] = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123; <span class="hljs-comment">// 更新t的相邻点</span><br>            <span class="hljs-keyword">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i]) &#123;<br>                dist[j] = dist[t] + w[i];<br>                <span class="hljs-keyword">if</span> (!st[j]) &#123;<br>                    q.push(j);<br>                    st[j] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 在队列中</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dist[n] &gt; <span class="hljs-number">0x3f3f3f3f</span> / <span class="hljs-number">2</span>) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt; dist[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">int</span> a, b, c;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        add(a, b, c);<br>    &#125;<br>    spfa();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>判断是否有负权回路</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> cnt[N];<br>...<br>    <span class="hljs-comment">// 开始时将所有点入队列</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)&#123;<br>        q.push(i);<br>        st[i] = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i]) &#123;<br>        dist[j] = dist[t] + w[i];<br>        cnt[j] = cnt[t] + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (cnt[j] &gt; n - <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 存在负权回路</span><br><br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="多源点"><a href="#多源点" class="headerlink" title="多源点"></a>多源点</h3><p>Floyd</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2e2</span> + <span class="hljs-number">5</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">int</span> g[N][N], n, m, k;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (i == j) g[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> g[i]][j] = INF;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-keyword">int</span> a, b, c;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        <span class="hljs-keyword">if</span> (g[a][b] &gt; c) &#123;<br>            g[a][b] = c;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (g[i][j] &gt; g[i][k] + g[k][j]) &#123;<br>                    g[i][j] = g[i][k] + g[k][j];<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (k--) &#123;<br>        <span class="hljs-keyword">int</span> x, y;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; x &gt;&gt; y;<br>        <span class="hljs-keyword">if</span> (g[x][y] &gt; INF / <span class="hljs-number">2</span>) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt; g[x][y] &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><h4 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h4><p>适用于点远少于边，找到集合外dist最小的，更新其他点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Prim</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (dist[t] &gt; dist[j] || t == <span class="hljs-number">-1</span>)) &#123;<br>                t = j;<br>            &#125;<br>        &#125;<br>        st[t] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (i) &#123;<br>            res += dist[t];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &amp;&amp; dist[t] == <span class="hljs-number">0x3f3f3f3f</span>) &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; g[t][j]) dist[j] = g[t][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h4><p>保存每条边，按照权值从小到大排序，连通用到并查集</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2e2</span> + <span class="hljs-number">5</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">int</span> g[N][N], n, m, k;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e2</span> + <span class="hljs-number">5</span>,<br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">2e2</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> p[M], n, m, res, cnt; <span class="hljs-comment">// p为并查集</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-keyword">int</span> a, b, c;<br>&#125;Ns[M];<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Node a, Node b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.c &lt; b.c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p[a] != a) &#123;<br>        p[a] = find(p[a]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> p[a];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        p[i] = i; <span class="hljs-comment">//并查集初始化</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">int</span> a, b, c;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        Ns[i] = &#123; a,b,c &#125;;<br>    &#125;<br>    sort(Ns, Ns + m, cmp); <span class="hljs-comment">// 边排序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">int</span> a = Ns[i].a, b = Ns[i].b, c = Ns[i].c;<br>        <span class="hljs-keyword">if</span> (find(a) != find(b)) &#123;<br>            p[find(a)] = find(b);<br>            res += c;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cnt != n - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; res;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h2><h3 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h3><p><strong>判断n是否为质数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 试除法判断n是否为质数</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>, up = <span class="hljs-built_in">sqrt</span>(n); i &lt;= up; i++) &#123;<br>        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>筛选出1~n的质数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 埃式筛1~n的质数 O(nloglogn)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!st[i]) &#123;<br>            prime[cnt++] = i;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + i; j &lt;= n; j += i) &#123; <span class="hljs-comment">// i的倍数肯定都不是质数</span><br>                st[j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 线性筛质数O(n) (按照每一个数的最小质因数来筛，每个数都只会筛一次)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!st[i]) &#123;<br>            prime[cnt++] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>, up = n / i; prime[j] &lt;= up; j++) &#123; <span class="hljs-comment">// 枚举之前选的质数</span><br>            st[prime[j] * i] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 两个质数乘积prime[j]*i肯定不是质数</span><br>            <span class="hljs-keyword">if</span> (i % prime[j] == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// prime[j]是i的质因数?，不需要再重复筛</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>对n分解质因数</strong></p><script type="math/tex; mode=display">n=P_1^{a_1}{\times}P_2^{a_2}\times...{\times}P_n^{a_n}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>, up = <span class="hljs-built_in">sqrt</span>(n); i &lt;= up; i++) &#123;<br>        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 只要满足则i一定是质数(因为如果i不是质数，则前面就已经把n中i的质因子除掉了)</span><br>            <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (n % i == <span class="hljs-number">0</span>) &#123;<br>                cnt++;<br>                n /= i;<br>            &#125;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; cnt &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 一个因子i^cnt</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (n != <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h3><p><strong>求约数</strong></p><p>数字n可能很大，数组静态开辟不能太大，可以改用<code>std::vector</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, up = <span class="hljs-built_in">sqrt</span>(n); i &lt;= up; i++) &#123;<br>        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) &#123;<br>            q[cnt++] = i; <br>            <span class="hljs-keyword">if</span> (i != n / i) &#123;<br>                q[cnt++] = n / i; <span class="hljs-comment">// 对称的另一个</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>约数个数</strong></p><p>先分解质因数<script type="math/tex">n=P_1^{a_1}{\times}P_2^{a_2}\times...{\times}P_n^{a_n}</script>，约数个数为<script type="math/tex">(a_1+1){\times}(a_2+1){\times}...{\times}(a_n+1)</script>。<strong>注意是相乘</strong>。</p><p>例：给定n个正数ai，输出这些数的乘积的约数个数，答案对1e9+7取模。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; h; <span class="hljs-comment">// 保存质因数的底和指数</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n--) &#123;<br>        <span class="hljs-keyword">int</span> a;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; a;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= a / i; i++) &#123;<br>            <span class="hljs-keyword">if</span> (a % i == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">while</span> (a % i == <span class="hljs-number">0</span>) &#123;<br>                    a /= i;<br>                    h[i]++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (a != <span class="hljs-number">1</span>) &#123;<br>            h[a]++; <span class="hljs-comment">// a没有被除完?</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> i : h) &#123;<br>        <span class="hljs-keyword">int</span> b = i.second;<br>        res = res * (b + <span class="hljs-number">1</span>) % MOD; <span class="hljs-comment">// 约数个数公式</span><br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; res;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>约数和</strong></p><p>先分解质因数<script type="math/tex">n=P_1^{a_1}{\times}P_2^{a_2}\times...{\times}P_n^{a_n}</script>，约数和为<script type="math/tex">\sum_0^{a_1}P_1^i{\times}...{\times}\sum_0^{a_n}P^i</script>，<strong>注意也是相乘</strong>。</p><p>每一部分都可以使用等比数列求和公式进行快速计算，而且还可以使用快速幂。</p><p>例：给定n个正数ai，输出这些数的乘积的约数个数，答案对1e9+7取模。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fastpow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> p)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(b)&#123;<br>        <span class="hljs-keyword">if</span>(b &amp; <span class="hljs-number">1</span>)&#123;<br>            res = (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)res * a % p;<br>        &#125;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>        a = (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)a * a %p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-comment">// 基本同上，不同之处</span><br><span class="hljs-keyword">int</span> a = i.first, b = i.second;<br>res = (res * ((<span class="hljs-number">1</span>-fastpow(a, b+<span class="hljs-number">1</span>, MOD)) / (<span class="hljs-number">1</span> - a))) % MOD;<br></code></pre></td></tr></table></figure><p><strong>最大公约数</strong></p><p><code>b != 0，(a, b) = (b, a%b)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : gcd(b, a%b);<br>&#125;<br><br><span class="hljs-comment">// 最小公倍数</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lcm</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a * b / gcd(a, b);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p>函数值为为小于等于n的正整数中与n互质的数的个数。</p><p>先分解质因数<script type="math/tex">n=P_1^{a_1}{\times}P_2^{a_2}\times...{\times}P_n^{a_n}</script></p><p>则<script type="math/tex">\phi(n)=n{\times}(1-\frac{1}{P_1})\times(1-\frac{1}{P_2})\times...\times(1-\frac{1}{P_n})</script></p><p>其实展开就是<script type="math/tex">n-\frac{n}{P_1}-...-\frac{n}{P_n}+\frac{n}{P_1P_2}+...+\frac{n}{P_{n-1}P_{n}}-\frac{n}{P_1P_2P_3}-...</script></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// O(n)</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Euler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> ans = n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">if</span>(n%i == <span class="hljs-number">0</span>)&#123;<br>            ans = ans / i * (i<span class="hljs-number">-1</span>);<br>            <span class="hljs-keyword">while</span>(n%i==<span class="hljs-number">0</span>)&#123;<br>                n /= i;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-comment">// O(n^0.5)</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Euler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> ans = n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">if</span>(n%i == <span class="hljs-number">0</span>)&#123;<br>            ans = ans / i * (i<span class="hljs-number">-1</span>); <br>            <span class="hljs-keyword">while</span>(n%i == <span class="hljs-number">0</span>)&#123;<br>                n /= i;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">1</span>)&#123;<br>        ans = ans / n * (n<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>性质</strong></p><p><script type="math/tex">\phi(m{\times}n)=\phi(m)\times\phi(n)</script>，其中m和n互质。</p><p><strong>线性筛</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 在线性筛素数基础上添加</span><br><span class="hljs-keyword">int</span> euler[N]; <span class="hljs-comment">// 保存对应的欧拉函数值</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!st[i]) &#123;<br>            prime[cnt++] = i;<br>            euler[i] = i<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>, up = n / i; prime[j] &lt;= up; j++) &#123;<br>            st[prime[j] * i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % prime[j] == <span class="hljs-number">0</span>) &#123;<br>                euler[i*prime[j]] = euler[i] * prime[j];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            euler[i*prime[j]] = euler[i] * euler[prime[j]]; <span class="hljs-comment">// 欧拉函数性质</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>某个问题可以转换成N个子问题，并且子问题还可以转换，而且存在着重复。</p><p>流程：反推、正推-状态表示-分类讨论-状态方程-优化</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="闰年"><a href="#闰年" class="headerlink" title="闰年"></a>闰年</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isLeapYear</span><span class="hljs-params">(<span class="hljs-keyword">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> y%<span class="hljs-number">400</span>==<span class="hljs-number">0</span> || (y%<span class="hljs-number">100</span>!=<span class="hljs-number">0</span> &amp;&amp; y%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="输入挂"><a href="#输入挂" class="headerlink" title="输入挂"></a>输入挂</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 读整数</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">scan_d</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;num)</span>  </span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">char</span> in; <span class="hljs-keyword">bool</span> IsN=<span class="hljs-literal">false</span>;<br>        in=getchar();<br>        <span class="hljs-keyword">if</span>(in==EOF) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span>(in!=<span class="hljs-string">&#x27;-&#x27;</span>&amp;&amp;(in&lt;<span class="hljs-string">&#x27;0&#x27;</span>||in&gt;<span class="hljs-string">&#x27;9&#x27;</span>)) in=getchar();<br>        <span class="hljs-keyword">if</span>(in==<span class="hljs-string">&#x27;-&#x27;</span>)&#123; IsN=<span class="hljs-literal">true</span>;num=<span class="hljs-number">0</span>;&#125;<br>        <span class="hljs-keyword">else</span> num=in-<span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">while</span>(in=getchar(),in&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;in&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>                num*=<span class="hljs-number">10</span>,num+=in-<span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(IsN) num=-num;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 读实数</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">scan_lf</span><span class="hljs-params">(<span class="hljs-keyword">double</span> &amp;num)</span>  </span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">char</span> in; <span class="hljs-keyword">double</span> Dec=<span class="hljs-number">0.1</span>;<br>        <span class="hljs-keyword">bool</span> IsN=<span class="hljs-literal">false</span>, IsD=<span class="hljs-literal">false</span>;<br>        in=getchar();<br>        <span class="hljs-keyword">if</span>(in==EOF) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span>(in!=<span class="hljs-string">&#x27;-&#x27;</span>&amp;&amp;in!=<span class="hljs-string">&#x27;.&#x27;</span>&amp;&amp;(in&lt;<span class="hljs-string">&#x27;0&#x27;</span>||in&gt;<span class="hljs-string">&#x27;9&#x27;</span>))<br>        in=getchar();<br>        <span class="hljs-keyword">if</span>(in==<span class="hljs-string">&#x27;-&#x27;</span>)&#123;IsN=<span class="hljs-literal">true</span>;num=<span class="hljs-number">0</span>;&#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(in==<span class="hljs-string">&#x27;.&#x27;</span>)&#123;IsD=<span class="hljs-literal">true</span>;num=<span class="hljs-number">0</span>;&#125;<br>        <span class="hljs-keyword">else</span> num=in-<span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(!IsD)&#123;<br>            <span class="hljs-keyword">while</span>(in=getchar(),in&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;in&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>                num*=<span class="hljs-number">10</span>;num+=in-<span class="hljs-string">&#x27;0&#x27;</span>;&#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(in!=<span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(IsN) num=-num;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">while</span>(in=getchar(),in&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;in&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>                num+=Dec*(in-<span class="hljs-string">&#x27;0&#x27;</span>);Dec*=<span class="hljs-number">0.1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(IsN) num=-num;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h3><ol><li>01</li><li>完全</li></ol><p>。。。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LL(1)无回溯的递归下降语法分析器</title>
      <link href="posts/bf30e3e0/"/>
      <url>posts/bf30e3e0/</url>
      
        <content type="html"><![CDATA[<h1 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h1><p>使用递归下降法实现<code>LL(1)</code>文法的语法分析器，为了实现不回溯，需要使用预测分析表。结合词法分析器对输入进行分析，输出最左推导。</p><h2 id="原文法"><a href="#原文法" class="headerlink" title="原文法"></a>原文法</h2><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21/04/11/原文法.PNG" style="zoom:80%;" /></p><h1 id="改写文法"><a href="#改写文法" class="headerlink" title="改写文法"></a>改写文法</h1><h2 id="提取左公因子"><a href="#提取左公因子" class="headerlink" title="提取左公因子"></a>提取左公因子</h2><script type="math/tex; mode=display">A\rightarrow\alpha\beta_1\ |\ \alpha\beta_2\ |\ ...\ |\ \alpha\beta_n\ |\ \gamma</script><p>改写成</p><script type="math/tex; mode=display">A\rightarrow{\alpha}A^{'}\ |\ \gamma \\A^{'}\rightarrow\beta_1\ |\ \beta_2\ |\ ...\ |\ \beta_n</script><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21/04/11/提取左公因子.PNG" style="zoom:80%;" /></p><h2 id="消除左递归"><a href="#消除左递归" class="headerlink" title="消除左递归"></a>消除左递归</h2><script type="math/tex; mode=display">A{\rightarrow}A\alpha_1\ |\ A\alpha_2\ |\ ...\ |\ A\alpha_n\ |\ \beta_1\ |\ \beta_2\ |\ ...\ |\ \beta_n</script><p>改写成</p><script type="math/tex; mode=display">A{\rightarrow}\beta_1A^{'}\ |\ \beta_2A^{'}\ |\ ...\ |\ \beta_nA^{'}\\A^{'}{\rightarrow}\alpha_1A^{'}\ |\ \alpha_2A^{'}\ |\ ...\ |\ \alpha_nA^{'}\ |\ \varepsilon</script><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21/04/11/消除左递归.PNG" style="zoom:80%;" /></p><h2 id="新文法"><a href="#新文法" class="headerlink" title="新文法"></a>新文法</h2><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21/04/11/新文法.PNG" style="zoom:80%;" /></p><h1 id="构造预测分析表"><a href="#构造预测分析表" class="headerlink" title="构造预测分析表"></a>构造预测分析表</h1><h2 id="计算FIRST集"><a href="#计算FIRST集" class="headerlink" title="计算FIRST集"></a>计算FIRST集</h2><p>找到对应所有产生式中的第一个终结符，如果是非终结符则递归进去。</p><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21/04/11/FIRST.PNG" style="zoom:80%;" /></p><h2 id="计算FOLLOW集"><a href="#计算FOLLOW集" class="headerlink" title="计算FOLLOW集"></a>计算FOLLOW集</h2><ol><li>若$S$为开始符号，则$FOLLOW(S)$包含$ {$} $</li><li>若$A{\rightarrow}{\alpha}B$，则$FOLLOW(A)$也加入$FOLLOW(B)$</li><li>若$A{\rightarrow}{\alpha}B{\beta}$，将$FIRST({\beta})-\varepsilon$加入$FOLLOW(B)$。如果确实有$\varepsilon{\in}FIRST(\beta)$，则$FOLLOW(A)$也加入$FOLLOW(B)$</li></ol><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21/04/11/FOLLOW.PNG" style="zoom:80%;" /></p><h2 id="计算SELECT集"><a href="#计算SELECT集" class="headerlink" title="计算SELECT集"></a>计算SELECT集</h2><p>为了构造预测分析表，需要使用上面计算得到的$FIRST$和$FOLLOW$。预测分析表第一维是非终结符，第二维是输入的终结符。一种直接构造分析表的方法是按照下面两个步骤：</p><p>对于任意$A\rightarrow \alpha$:</p><ol><li><p>对$FIRST(\alpha)$中的每个终结符$a$，将$A\rightarrow \alpha$加入$M[A,a]$</p></li><li><p>如果$\varepsilon \in FIRST(\alpha)$，则对于$FOLLOW(A)$中的每个终结符$b$，将$A\rightarrow \alpha$加入$M[A,b]$。</p><p>如果$\varepsilon \in FIRST(\alpha)$且$ {$} \in FOLLOW(A)$，则将$A {\rightarrow} {\alpha}$加入$M[A,{$}]$。</p></li></ol><p>按照上面的步骤会比较容易出错，一种比较直观的做法是先计算$SELECT$集：</p><p>对于一个产生式$A\rightarrow \alpha$，其$SELECT(A\rightarrow \alpha)$就是可以使用这个产生式进行推导的输入符号的集合。</p><p>对于任意$A\rightarrow \alpha$：</p><ol><li>如果$\epsilon \notin FIRST(A)$，则$SELECT(A\rightarrow \alpha)=FIRST(A) $</li><li>如果$\epsilon \in FIRST(A)$，则$SELECT(A\rightarrow \alpha)=FIRST(A)-{\epsilon}+FOLLOW(A) $</li></ol><p>计算过程与上面的差不多，其中把额外判断$ $ $的一步省掉了，计算起来更加方便。</p><h2 id="预测分析表"><a href="#预测分析表" class="headerlink" title="预测分析表"></a>预测分析表</h2><p>比如$SELECT(A\rightarrow \alpha)={+, )} $，则预测分析表$M$中：$M[A, +]=M[A, )]=A\rightarrow \alpha $。</p><p>为了方便书写，可以对产生式编号，比如:$A_1$就表示$A$的第一条产生式。</p><p>最后得到的预测分析表：</p><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21/04/11/预测分析表1.PNG" style="zoom:80%;" /></p><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21/04/11/预测分析表2.PNG" style="zoom:80%;" /></p><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21/04/11/预测分析表3.PNG" style="zoom:80%;" /></p><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21/04/11/预测分析表4.PNG" style="zoom:80%;" /></p><h1 id="处理二义性的if语句"><a href="#处理二义性的if语句" class="headerlink" title="处理二义性的if语句"></a>处理二义性的if语句</h1><p>由预测分析表1可知该文法中的if语句还存在着二义性，有三种方法可以进行处理。</p><ol><li><p>方法一</p><p>将</p><script type="math/tex; mode=display">\begin{align*}stmt \rightarrow &\ \ \mathbf{if} \mathbf{(}bool\mathbf{)}\ stmt \\&|\ \mathbf{if} \mathbf{(}bool\mathbf{)}\ stmt \ \mathbf{else}\ stmt\end{align*}</script><p>改写成</p><script type="math/tex; mode=display">\begin{align*}stmt \rightarrow &\ \ matched\_stmt\\&|\ unmatched\_stmt \\matched\_stmt\rightarrow &\ \ \mathbf{if}\mathbf{(}bool \mathbf{)}\ matched\_stmt\ \mathbf{else}\ matched\_stmt\\&|\ other \\unmatched\_stmt\rightarrow &\ \ \mathbf{if}\mathbf{(}bool \mathbf{)}\ stmt\\&|\ \mathbf{if}\mathbf{(}bool \mathbf{)}\ matched\_stmt\ \mathbf{else}\ unmatched\_stmt\\\end{align*}</script><p>然后要重新计算$FIRST$集和$FOLLOW$集以及预测分析表，再加两个函数，总之比较繁琐。</p></li><li><p>方法二</p><p>先提取左公因子</p><script type="math/tex; mode=display">\begin{align*}stmt\rightarrow &\ \mathbf{if} \mathbf{(}bool\mathbf{)}\ stmt\ else\_part\\&|\  other\\else\_part\rightarrow&\ \mathbf{else}\ stmt\\&|\ \varepsilon\end{align*}</script><p>然后查看$lookahead$，如果是$else$就使用$elsepart$第一个产生式，否则选第二个。</p></li><li><p>方法三</p><p>观察发现$stmt$的第一个产生式是第二个产生式的前缀，于是不需要提取公因子，只要先进行$if(bool)\ stmt$的匹配，然后再看$lookahead$。如果是$else$，则继续匹配$else\ stmt$即可。这里需要注意因为先进行了其他部分匹配，在代码实现时需要对输出进行控制，否则输出的推到序列就是混乱的。</p></li></ol><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="词法分析器"><a href="#词法分析器" class="headerlink" title="词法分析器"></a>词法分析器</h2><p><code>test.l</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c++">%option yylineno<br><br>%&#123;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;myyacc.tab.h&quot;</span>  <span class="hljs-comment">/*对终结符的常量定义*/</span></span><br><br><span class="hljs-keyword">int</span> yylval;<br><br>%&#125;<br><br>delim[ \t\n]<br>ws    &#123;delim&#125;+<br>letter    [A-Za-z]<br>digit[<span class="hljs-number">0</span><span class="hljs-number">-9</span>]<br>id    (&#123;letter&#125;|_)(&#123;letter&#125;|&#123;digit&#125;|_)*<br>number    &#123;digit&#125;+(\.&#123;digit&#125;+)?(E[+-]?&#123;digit&#125;+)?<br><br>%%<br>&#123;ws&#125;&#123;&#125;<br>\/\/([^\n])+&#123;<span class="hljs-comment">/*printf(&quot;line comments : %s\n&quot;,yytext);*/</span>&#125;<br><br>\/\*([^\*])*\*([\*]|[^\*\/]([^\*])*[\*])*\/      &#123; <span class="hljs-comment">/*printf(&quot;Comments:%s\n&quot;,yytext); */</span>&#125;<br><span class="hljs-string">&quot;if&quot;</span>&#123;   <span class="hljs-keyword">return</span>(IF);&#125;<br><span class="hljs-string">&quot;else&quot;</span>      &#123;   <span class="hljs-keyword">return</span>(ELSE);&#125;<br><span class="hljs-string">&quot;while&quot;</span>     &#123;   <span class="hljs-keyword">return</span>(WHILE);&#125;<br><span class="hljs-string">&quot;do&quot;</span>        &#123;   <span class="hljs-keyword">return</span>(DO);&#125;<br><span class="hljs-string">&quot;break&quot;</span>     &#123;   <span class="hljs-keyword">return</span>(BREAK);&#125;<br><span class="hljs-string">&quot;true&quot;</span>    &#123;   <span class="hljs-keyword">return</span>(TRUE);&#125;<br><span class="hljs-string">&quot;false&quot;</span>     &#123;   <span class="hljs-keyword">return</span>(FALSE);&#125;<br><span class="hljs-string">&quot;int&quot;</span>&#123;   <span class="hljs-keyword">return</span>(INT);&#125;<br><span class="hljs-string">&quot;char&quot;</span>&#123;   <span class="hljs-keyword">return</span>(CHAR);&#125;<br><span class="hljs-string">&quot;float&quot;</span>&#123;   <span class="hljs-keyword">return</span>(FLOAT);&#125;<br><span class="hljs-string">&quot;bool&quot;</span>&#123;   <span class="hljs-keyword">return</span>(BOOL);&#125;<br><br>&#123;id&#125;&#123; <span class="hljs-built_in">sscanf</span>( yytext, <span class="hljs-string">&quot;%s&quot;</span>, &amp;yylval ); <span class="hljs-keyword">return</span>(ID);&#125;<br>&#123;number&#125;&#123;   <span class="hljs-built_in">sscanf</span>( yytext, <span class="hljs-string">&quot;%lf&quot;</span>, &amp;yylval); <span class="hljs-keyword">return</span>(NUMBER);&#125;<br><span class="hljs-string">&quot;&lt;&quot;</span>&#123;   <span class="hljs-keyword">return</span>(RELOP_LT);&#125;<br><span class="hljs-string">&quot;=&quot;</span>&#123;   <span class="hljs-keyword">return</span>(<span class="hljs-string">&#x27;=&#x27;</span>);&#125;<br><span class="hljs-string">&quot;&gt;&quot;</span>&#123;   <span class="hljs-keyword">return</span>(RELOP_GT);&#125;<br><span class="hljs-string">&quot;!=&quot;</span>    &#123;   <span class="hljs-keyword">return</span>(RELOP_NE);&#125;<br><span class="hljs-string">&quot;==&quot;</span>    &#123;   <span class="hljs-keyword">return</span>(RELOP_EE);&#125;<br><span class="hljs-string">&quot;&lt;=&quot;</span>    &#123;   <span class="hljs-keyword">return</span>(RELOP_LE);&#125;<br><span class="hljs-string">&quot;&gt;=&quot;</span>    &#123;   <span class="hljs-keyword">return</span>(RELOP_GE);&#125;<br><span class="hljs-string">&quot;||&quot;</span>&#123;   <span class="hljs-keyword">return</span>(OR);&#125;<br><span class="hljs-string">&quot;&amp;&amp;&quot;</span>&#123;   <span class="hljs-keyword">return</span>(AND);&#125;<br><span class="hljs-string">&quot;+&quot;</span>    &#123;   <span class="hljs-keyword">return</span> (<span class="hljs-string">&#x27;+&#x27;</span>);&#125;<br><span class="hljs-string">&quot;-&quot;</span>     &#123;   <span class="hljs-keyword">return</span> (<span class="hljs-string">&#x27;-&#x27;</span>);&#125;<br><span class="hljs-string">&quot;*&quot;</span>     &#123;   <span class="hljs-keyword">return</span> (<span class="hljs-string">&#x27;*&#x27;</span>);&#125;<br><span class="hljs-string">&quot;/&quot;</span>     &#123;   <span class="hljs-keyword">return</span> (<span class="hljs-string">&#x27;/&#x27;</span>);&#125;<br><span class="hljs-string">&quot;,&quot;</span>&#123;<span class="hljs-keyword">return</span> (<span class="hljs-string">&#x27;,&#x27;</span>);&#125;<br><span class="hljs-string">&quot;(&quot;</span>&#123;<span class="hljs-keyword">return</span> (<span class="hljs-string">&#x27;(&#x27;</span>);&#125;<br><span class="hljs-string">&quot;)&quot;</span>&#123;<span class="hljs-keyword">return</span> (<span class="hljs-string">&#x27;)&#x27;</span>);&#125;<br><span class="hljs-string">&quot;;&quot;</span>&#123;<span class="hljs-keyword">return</span> (<span class="hljs-string">&#x27;;&#x27;</span>);&#125;<br><span class="hljs-string">&quot;&#123;&quot;</span>&#123;<span class="hljs-keyword">return</span> (<span class="hljs-string">&#x27;&#123;&#x27;</span>);&#125;<br><span class="hljs-string">&quot;&#125;&quot;</span>&#123;<span class="hljs-keyword">return</span> (<span class="hljs-string">&#x27;&#125;&#x27;</span>);&#125;<br><span class="hljs-string">&quot;[&quot;</span>&#123;<span class="hljs-keyword">return</span> (<span class="hljs-string">&#x27;[&#x27;</span>);&#125;<br><span class="hljs-string">&quot;]&quot;</span>&#123;<span class="hljs-keyword">return</span> (<span class="hljs-string">&#x27;]&#x27;</span>);&#125;<br><span class="hljs-string">&quot;.&quot;</span>&#123;<span class="hljs-keyword">return</span> (<span class="hljs-string">&#x27;.&#x27;</span>);&#125;<br>.       &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Unknown : %s\n&quot;</span>,yytext);&#125;<br>%%<br><br><span class="hljs-comment">/*该函数设置yyin变量，fflex对yyin变量所对应的文件进行词法分析*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BeginCompileOneFile</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * filename )</span></span><br><span class="hljs-function"></span>&#123;  <br>   yyin = fopen( filename, <span class="hljs-string">&quot;r&quot;</span>);<br>   fseek( yyin, <span class="hljs-number">0</span>, SEEK_SET );<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EndCompileOneFile</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span><br><span class="hljs-function"></span>&#123;<br>   fclose(yyin);<br>   yyin = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">yywrap</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="产生式声明"><a href="#产生式声明" class="headerlink" title="产生式声明"></a>产生式声明</h2><p>根据新文法和预测分析表进行命名：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// MyProduction.h 产生式定义</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;myyacc.tab.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Program</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Block</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Decls</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Decl</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Type</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Stmts</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Stmt</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Bool</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Bool1</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Expr</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Expr1</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Term</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Term1</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Factor</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Match</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PN(x)       printf(x<span class="hljs-meta-string">&quot;\n&quot;</span>);</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PROGRAM_1   PN(<span class="hljs-meta-string">&quot;Program\t-&gt; Block&quot;</span>) Block();</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BLOCK_1     PN(<span class="hljs-meta-string">&quot;Block\t-&gt; &#123; Decls Stmts &#125;&quot;</span>) Match(<span class="hljs-meta-string">&#x27;&#123;&#x27;</span>); Decls(); Stmts(); Match(<span class="hljs-meta-string">&#x27;&#125;&#x27;</span>);</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DECLS_1     PN(<span class="hljs-meta-string">&quot;Decls\t-&gt; Decl Decls&quot;</span>) Decl(); Decls();</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DECLS_2     PN(<span class="hljs-meta-string">&quot;Decls\t-&gt; epsilon&quot;</span>) </span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DECL_1      PN(<span class="hljs-meta-string">&quot;Decl\t-&gt; Type id ;&quot;</span>) Type(); Match(ID); Match(<span class="hljs-meta-string">&#x27;;&#x27;</span>);</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TYPE_1      PN(<span class="hljs-meta-string">&quot;Type\t-&gt; int&quot;</span>) Match(INT);</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TYPE_2      PN(<span class="hljs-meta-string">&quot;Type\t-&gt; float&quot;</span>) Match(FLOAT);</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TYPE_3      PN(<span class="hljs-meta-string">&quot;Type\t-&gt; char&quot;</span>) Match(CHAR);</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STMTS_1     PN(<span class="hljs-meta-string">&quot;Stmts\t-&gt; Stmt Stmts&quot;</span>) Stmt(); Stmts();</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STMTS_2     PN(<span class="hljs-meta-string">&quot;Stmts\t-&gt; epsilon&quot;</span>)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STMT_1      PN(<span class="hljs-meta-string">&quot;Stmt\t-&gt; id = Expr ;&quot;</span>) Match(ID); Match(<span class="hljs-meta-string">&#x27;=&#x27;</span>); Expr(); Match(<span class="hljs-meta-string">&#x27;;&#x27;</span>);</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STMT_2      PN(<span class="hljs-meta-string">&quot;Stmt\t-&gt; if ( Bool ) Stmt&quot;</span>) Match(IF); Match(<span class="hljs-meta-string">&#x27;(&#x27;</span>); Bool(); Match(<span class="hljs-meta-string">&#x27;)&#x27;</span>); Stmt();</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STMT_3      PN(<span class="hljs-meta-string">&quot;Stmt\t-&gt; if ( Bool ) Stmt else Stmt&quot;</span>) Match(IF); Match(<span class="hljs-meta-string">&#x27;(&#x27;</span>); Bool(); Match(<span class="hljs-meta-string">&#x27;)&#x27;</span>); Stmt(); Match(ELSE); Stmt();</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STMT_4      PN(<span class="hljs-meta-string">&quot;Stmt\t-&gt; while ( Bool ) Stmt&quot;</span>) Match(WHILE); Match(<span class="hljs-meta-string">&#x27;(&#x27;</span>); Bool(); Match(<span class="hljs-meta-string">&#x27;)&#x27;</span>); Stmt(); </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STMT_5      PN(<span class="hljs-meta-string">&quot;Stmt\t-&gt; do Stmt while ( Bool ) ;&quot;</span>) Match(DO); Stmt(); Match(WHILE); Match(<span class="hljs-meta-string">&#x27;(&#x27;</span>); Bool(); Match(<span class="hljs-meta-string">&#x27;)&#x27;</span>); Match(<span class="hljs-meta-string">&#x27;;&#x27;</span>); </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STMT_6      PN(<span class="hljs-meta-string">&quot;Stmt\t-&gt; break ;&quot;</span>) Match(BREAK); Match(<span class="hljs-meta-string">&#x27;;&#x27;</span>); </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STMT_7      PN(<span class="hljs-meta-string">&quot;Stmt\t-&gt; Block&quot;</span>) Block();</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BOOL_1      PN(<span class="hljs-meta-string">&quot;Bool\t-&gt; Expr Bool1&quot;</span>) Expr(); Bool1();</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BOOL1_1     PN(<span class="hljs-meta-string">&quot;Bool1\t-&gt; &lt; Expr&quot;</span>) Match(RELOP_LT); Expr();</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BOOL1_2     PN(<span class="hljs-meta-string">&quot;Bool1\t-&gt; &lt;= Expr&quot;</span>) Match(RELOP_LE); Expr();</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BOOL1_3     PN(<span class="hljs-meta-string">&quot;Bool1\t-&gt; &gt; Expr&quot;</span>) Match(RELOP_GT); Expr();</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BOOL1_4     PN(<span class="hljs-meta-string">&quot;Bool1\t-&gt; &gt;= Expr&quot;</span>) Match(RELOP_GE); Expr();</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BOOL1_5     PN(<span class="hljs-meta-string">&quot;Bool1\t-&gt; epsilon&quot;</span>) </span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EXPR_1      PN(<span class="hljs-meta-string">&quot;Expr\t-&gt; Term Expr1&quot;</span>) Term(); Expr1();</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EXPR1_1     PN(<span class="hljs-meta-string">&quot;Expr1\t-&gt; + Term Expr1&quot;</span>) Match(<span class="hljs-meta-string">&#x27;+&#x27;</span>); Term(); Expr1();</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EXPR1_2     PN(<span class="hljs-meta-string">&quot;Expr1\t-&gt; - Term Expr1&quot;</span>) Match(<span class="hljs-meta-string">&#x27;-&#x27;</span>); Term(); Expr1();</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EXPR1_3     PN(<span class="hljs-meta-string">&quot;Expr1\t-&gt; epsilon&quot;</span>) </span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TERM_1      PN(<span class="hljs-meta-string">&quot;Term\t-&gt; Factor Term1&quot;</span>) Factor(); Term1();</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TERM1_1     PN(<span class="hljs-meta-string">&quot;Term1\t-&gt; * Factor Term1&quot;</span>) Match(<span class="hljs-meta-string">&#x27;*&#x27;</span>); Factor(); Term1();</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TERM1_2     PN(<span class="hljs-meta-string">&quot;Term1\t-&gt; / Factor Term1&quot;</span>) Match(<span class="hljs-meta-string">&#x27;/&#x27;</span>); Factor(); Term1();</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TERM1_3     PN(<span class="hljs-meta-string">&quot;Term1\t-&gt; epsilon&quot;</span>) </span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FACTOR_1    PN(<span class="hljs-meta-string">&quot;Factor\t-&gt; ( Expr )&quot;</span>) Match(<span class="hljs-meta-string">&#x27;(&#x27;</span>); Expr(); Match(<span class="hljs-meta-string">&#x27;)&#x27;</span>);</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FACTOR_2    PN(<span class="hljs-meta-string">&quot;Factor\t-&gt; id&quot;</span>) Match(ID);</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FACTOR_3    PN(<span class="hljs-meta-string">&quot;Factor\t-&gt; num&quot;</span>) Match(NUMBER);</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h2 id="语法分析器"><a href="#语法分析器" class="headerlink" title="语法分析器"></a>语法分析器</h2><p>基本按照预测分析表写<code>switch</code>语句即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// parser.cpp 语法分析器</span><br><br><span class="hljs-comment">// 直接调用用词法分析的函数</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;lex.yy.c&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;MyProduction.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">int</span> lookahead; <span class="hljs-comment">// 向前看符号</span><br><br><span class="hljs-comment">// 提示错误信息</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Error</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error at line %d:%s\n&quot;</span>, yylineno, yytext);<br>&#125;<br><br><span class="hljs-comment">// 匹配终结符，并取下一个</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Match</span><span class="hljs-params">(<span class="hljs-keyword">int</span> TokenID)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( lookahead == TokenID )&#123;<br>lookahead = yylex();<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>        Error();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Program</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">switch</span>(lookahead)&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#123;&#x27;</span>:PROGRAM_1 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:Error();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Block</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">switch</span>(lookahead)&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#123;&#x27;</span>:BLOCK_1 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:Error();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Decls</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">switch</span>(lookahead)&#123;<br><span class="hljs-keyword">case</span> ID:DECLS_2 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> INT:DECLS_1 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> FLOAT:DECLS_1 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> CHAR:DECLS_1 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> IF:DECLS_2 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> WHILE:DECLS_2 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> DO:DECLS_2 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> BREAK:DECLS_2 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#123;&#x27;</span>:DECLS_2 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#125;&#x27;</span>:DECLS_2 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:Error();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Decl</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">switch</span> (lookahead)&#123;<br><span class="hljs-keyword">case</span> INT:DECL_1 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> FLOAT:DECL_1 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> CHAR:DECL_1 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:Error();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Type</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">switch</span>(lookahead)&#123;<br><span class="hljs-keyword">case</span> INT:TYPE_1 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> FLOAT:TYPE_2 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> CHAR:TYPE_3 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:Error();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Stmts</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">switch</span>(lookahead)&#123;<br><span class="hljs-keyword">case</span> ID:STMTS_1 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> IF:STMTS_1 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> WHILE:STMTS_1 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> DO:STMTS_1 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> BREAK:STMTS_1 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#123;&#x27;</span>:STMTS_1 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#125;&#x27;</span>:STMTS_2 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:Error();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Bool</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">switch</span> (lookahead)&#123;<br><span class="hljs-keyword">case</span> ID:BOOL_1 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> NUMBER:BOOL_1 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:BOOL_1 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:Error();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Bool1</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">switch</span>(lookahead)&#123; <br><span class="hljs-keyword">case</span> RELOP_LT:BOOL1_1 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> RELOP_LE:BOOL1_2 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> RELOP_GT:BOOL1_3 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> RELOP_GE:BOOL1_4 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:BOOL1_5 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:Error();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Expr</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">switch</span>(lookahead)&#123;<br><span class="hljs-keyword">case</span> ID:EXPR_1 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> NUMBER:EXPR_1 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:EXPR_1 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:Error();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Expr1</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">switch</span>(lookahead)&#123;<br><span class="hljs-keyword">case</span> RELOP_LT:EXPR1_3 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> RELOP_LE:EXPR1_3 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> RELOP_GT:EXPR1_3 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:EXPR1_1 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:EXPR1_2 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> RELOP_GE:EXPR1_3 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;;&#x27;</span>:EXPR1_3 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:EXPR1_3 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:Error();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Term</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">switch</span>(lookahead)&#123;<br><span class="hljs-keyword">case</span> ID:TERM_1 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> NUMBER:TERM_1 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:TERM_1 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:Error();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Term1</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">switch</span>(lookahead)&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:TERM1_1 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:TERM1_2 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> RELOP_LT:TERM1_3 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> RELOP_LE:TERM1_3 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> RELOP_GT:TERM1_3 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:TERM1_3 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:TERM1_3 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> RELOP_GE:TERM1_3 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;;&#x27;</span>:TERM1_3 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:TERM1_3 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:Error();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Factor</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">switch</span>(lookahead)&#123;<br><span class="hljs-keyword">case</span> ID:FACTOR_2 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> NUMBER:FACTOR_3 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:FACTOR_1 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:Error();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123; <br><span class="hljs-keyword">char</span> filename[<span class="hljs-number">1000</span>];<br><br><span class="hljs-keyword">if</span>(argc &lt;= <span class="hljs-number">1</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入要编译的源程序文件名：&quot;</span>); <br>gets(filename);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">strcpy</span>(filename, argv[<span class="hljs-number">1</span>]);<br>&#125;<br><br>BeginCompileOneFile( filename ); <span class="hljs-comment">// 在lex.yy.c</span><br>   <br><span class="hljs-comment">//当flex扫描到文件末尾，yylex函数返回0</span><br>    lookahead = yylex();<br><br>Program();<br><br>EndCompileOneFile();<br><br><span class="hljs-comment">// getchar();</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>还有一个$Stmt$的函数需要特殊处理，也就是将输出延迟。</p><p>首先在<code>MyProduction</code>中修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> delay = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">queue</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; outputQ;<br><br><span class="hljs-comment">// 延迟输出（将暂存到队列中）</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DelayOutput</span><span class="hljs-params">()</span></span>&#123;<br>    delay = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 刷新输出（将队列中的全部输出）</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FlushOutput</span><span class="hljs-params">()</span></span>&#123;<br>    delay = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">while</span>(outputQ.size())&#123;<br>        <span class="hljs-built_in">printf</span>(outputQ.front().c_str());<br>        outputQ.pop();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PN(x)       <span class="hljs-meta-keyword">if</span>(delay) outputQ.push(x<span class="hljs-meta-string">&quot;\n&quot;</span>); <span class="hljs-meta-keyword">else</span> printf(x<span class="hljs-meta-string">&quot;\n&quot;</span>);</span><br></code></pre></td></tr></table></figure><p>然后实现<code>Stmt</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Stmt</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">switch</span>(lookahead)&#123;<br><span class="hljs-keyword">case</span> ID:STMT_1 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> IF:<br>            <span class="hljs-comment">// 先将输出延迟，匹配左公因子</span><br>            DelayOutput(); Match(IF); Match(<span class="hljs-string">&#x27;(&#x27;</span>); Bool(); Match(<span class="hljs-string">&#x27;)&#x27;</span>); Stmt();<br>            <span class="hljs-comment">// 然后比较向前看符号</span><br>            <span class="hljs-keyword">if</span>(lookahead == ELSE)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Stmt\t-&gt; if ( Bool ) Stmt else Stmt\n&quot;</span>); FlushOutput(); Match(ELSE); Stmt();<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Stmt\t-&gt; if ( Bool ) Stmt\n&quot;</span>); FlushOutput();<br>            &#125;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> WHILE:STMT_4 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> DO:STMT_5 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> BREAK:STMT_6 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#123;&#x27;</span>:STMT_7 <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:Error();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p>构建脚本<code>build.bat</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">flex.exe test.l<br>g++ parser.cpp -o parser.exe<br>parser.exe code.txt<br></code></pre></td></tr></table></figure><p>输入<code>code.txt</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">&#123;<br><span class="hljs-keyword">int</span> i ;<br>i = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span>)&#123;<br>i = i - <span class="hljs-number">1</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>i = i + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">while</span>(i &gt; <span class="hljs-number">0</span>)&#123;<br>i = i - <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出<code>output.txt</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs plain">Program-&gt; Block<br>Block-&gt; &#123; Decls Stmts &#125;<br>Decls-&gt; Decl Decls<br>Decl-&gt; Type id ;<br>Type-&gt; int<br>Decls-&gt; epsilon<br>Stmts-&gt; Stmt Stmts<br>Stmt-&gt; id &#x3D; Expr ;<br>Expr-&gt; Term Expr1<br>Term-&gt; Factor Term1<br>Factor-&gt; num<br>Term1-&gt; epsilon<br>Expr1-&gt; epsilon<br>Stmts-&gt; Stmt Stmts<br>Stmt-&gt; if ( Bool ) Stmt else Stmt<br>Bool-&gt; Expr Bool1<br>Expr-&gt; Term Expr1<br>Term-&gt; Factor Term1<br>Factor-&gt; id<br>Term1-&gt; epsilon<br>Expr1-&gt; epsilon<br>Bool1-&gt; &gt; Expr<br>Expr-&gt; Term Expr1<br>Term-&gt; Factor Term1<br>Factor-&gt; num<br>Term1-&gt; epsilon<br>Expr1-&gt; epsilon<br>Stmt-&gt; Block<br>Block-&gt; &#123; Decls Stmts &#125;<br>Decls-&gt; epsilon<br>Stmts-&gt; Stmt Stmts<br>Stmt-&gt; id &#x3D; Expr ;<br>Expr-&gt; Term Expr1<br>Term-&gt; Factor Term1<br>Factor-&gt; id<br>Term1-&gt; epsilon<br>Expr1-&gt; - Term Expr1<br>Term-&gt; Factor Term1<br>Factor-&gt; num<br>Term1-&gt; epsilon<br>Expr1-&gt; epsilon<br>Stmts-&gt; epsilon<br>Stmt-&gt; Block<br>Block-&gt; &#123; Decls Stmts &#125;<br>Decls-&gt; epsilon<br>Stmts-&gt; Stmt Stmts<br>Stmt-&gt; id &#x3D; Expr ;<br>Expr-&gt; Term Expr1<br>Term-&gt; Factor Term1<br>Factor-&gt; id<br>Term1-&gt; epsilon<br>Expr1-&gt; + Term Expr1<br>Term-&gt; Factor Term1<br>Factor-&gt; num<br>Term1-&gt; epsilon<br>Expr1-&gt; epsilon<br>Stmts-&gt; epsilon<br>Stmts-&gt; Stmt Stmts<br>Stmt-&gt; while ( Bool ) Stmt<br>Bool-&gt; Expr Bool1<br>Expr-&gt; Term Expr1<br>Term-&gt; Factor Term1<br>Factor-&gt; id<br>Term1-&gt; epsilon<br>Expr1-&gt; epsilon<br>Bool1-&gt; &gt; Expr<br>Expr-&gt; Term Expr1<br>Term-&gt; Factor Term1<br>Factor-&gt; num<br>Term1-&gt; epsilon<br>Expr1-&gt; epsilon<br>Stmt-&gt; Block<br>Block-&gt; &#123; Decls Stmts &#125;<br>Decls-&gt; epsilon<br>Stmts-&gt; Stmt Stmts<br>Stmt-&gt; id &#x3D; Expr ;<br>Expr-&gt; Term Expr1<br>Term-&gt; Factor Term1<br>Factor-&gt; id<br>Term1-&gt; epsilon<br>Expr1-&gt; - Term Expr1<br>Term-&gt; Factor Term1<br>Factor-&gt; num<br>Term1-&gt; epsilon<br>Expr1-&gt; epsilon<br>Stmts-&gt; epsilon<br>Stmts-&gt; epsilon<br></code></pre></td></tr></table></figure><p>还可以使用<code>python</code>将构建的语法分析树画出来：</p><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21/04/11/test.svg" style="zoom:80%;" /></p><p>详细实现见<a href="/posts/bed86e5b">用Python绘制语法分析树</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Complier </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>waline启用邮件通知</title>
      <link href="posts/1f1a97ee/"/>
      <url>posts/1f1a97ee/</url>
      
        <content type="html"><![CDATA[<h1 id="基本设置"><a href="#基本设置" class="headerlink" title="基本设置"></a>基本设置</h1><p>详见<a href="https://waline.js.org/server/notification.html#%E9%82%AE%E4%BB%B6%E9%80%9A%E7%9F%A5">官网文档</a></p><p>这里主要说下官网没有提到的。</p><h1 id="如何设置vercel环境变量"><a href="#如何设置vercel环境变量" class="headerlink" title="如何设置vercel环境变量"></a>如何设置vercel环境变量</h1><p>登录<a href="https://vercel.com">vercel官网</a></p><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21-04-10/vercel-login.PNG" alt=""></p><p>我之前创建的项目名为<code>hexo-comment</code>，点击上图红框里的项目名。</p><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21-04-10/vercel-comment.PNG" alt=""></p><p>点击上图红框里的<code>Edit</code></p><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21-04-10/vercel-settings.PNG" alt=""></p><p>点击上图红框里的<code>Environment Variables</code>，然后就可以创建环境变量了。</p><p>需要注意的是，一般都是用<code>Plaintext</code>就可以，但是邮箱密码或授权码最好使用<code>Secret</code>。创建<code>Secret</code>时，对应的值是用一个另外的名字代替的，想要改变<code>Secret</code>对应的值就选<code>Create a new Secret for null</code>，名字要与之前的不同（原来的值改不了，删掉也很麻烦）。</p><h1 id="环境变量设置"><a href="#环境变量设置" class="headerlink" title="环境变量设置"></a>环境变量设置</h1><h2 id="评论模板相关"><a href="#评论模板相关" class="headerlink" title="评论模板相关"></a>评论模板相关</h2><p>官网上说的<code>MAIL_SUBJECT</code>，<code>MAIL_TEMPLATE</code>，<code>MAIL_SUBJECT_ADMIN</code>，<code>MAIL_TEMPLATE_ADMIN</code>这几个环境变量都可以不用设置，有自带的默认模板就可以了</p><h2 id="回复邮件相关"><a href="#回复邮件相关" class="headerlink" title="回复邮件相关"></a>回复邮件相关</h2><p>最好另外创建一个不常用的邮箱，免得被当成垃圾邮箱。我另外注册了一个网易的<a href="https://mail.163.com">163邮箱</a>。有需要几点注意的：</p><ol><li><p>官网上也没说<code>SMTP_SERVICE</code>该填什么，我就设置了<code>SMTP_HOST</code>和<code>SMTP_PORT</code>这两个环境变量，可以在<a href="https://github.com/nodemailer/nodemailer/blob/master/lib/well-known/services.json">官网推荐的链接</a>找到：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&quot;163&quot;: &#123;<br>        &quot;host&quot;: &quot;smtp.163.com&quot;,<br>        &quot;port&quot;: 465,<br>        &quot;secure&quot;: true<br>    &#125;<br></code></pre></td></tr></table></figure><p>所以这两个变量分别就是<code>smtp.163.com</code>和<code>465</code>。</p></li><li><p>开启IMAP服务</p><p>可以登录网易邮箱，<code>设置&gt;POP3/SMTP/IMAP</code>，然后点击开启IMAP/SMTP服务（会发条短信），需要记住生成的授权码。</p><p>在页面底端还可以看到：</p><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21-04-10/mail.163.imap.PNG" alt=""></p><p>虽然这里写着IMAP服务器是<code>imap.163.com</code>，但是我们设置的环境变量里还是SMPT服务器的。</p></li><li><p>设置邮箱密码</p><p>准确来说是<code>授权码</code>，也就是上面开启IMAP服务后生成的那个，将<code>SMTP_USER</code>设置为邮箱账号，<code>SMTP_PASS</code>设置为授权码（而不是在<a href="https://mail.163.com">网页端</a>登录邮箱用的密码，否则登录不上，自然也不会发邮件）。</p></li><li><p>官网上说<code>AUTHOR_EMAIL</code>是用来区分评论是否是博主自己发的，是的话就不发邮件。但是测试发现，如果<code>AUTHOR_EMAIL</code>和<code>SMTP_USER</code>设置的不一样（比如发评论填的是常用的邮箱，用来邮件通知的是另外注册的163邮箱），会导致别人的评论也不发邮件。所以<code>AUTHOR_EMAIL</code>也填163邮箱，跟<code>SMTP_USER</code>保持一致就没问题了。</p></li></ol><h1 id="如何重新发布vercel项目"><a href="#如何重新发布vercel项目" class="headerlink" title="如何重新发布vercel项目"></a>如何重新发布vercel项目</h1><p>不知道重新发布是不是必须的，但是改了环境变量设置，最好还是重新发布一下。</p><p>回到<a href="https://vercel.com">vercel</a></p><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21-04-10/vercel-redeploy1.PNG" alt=""></p><p>点击上图中的<code>Deployments</code></p><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21-04-10/vercel-redeploy2.PNG" alt=""></p><p>然后点击图中的三个小点，选择<code>redeploy</code>，等待重新发布完成（大概半分钟）。</p>]]></content>
      
      
      <categories>
          
          <category> Error </category>
          
      </categories>
      
      
        <tags>
            
            <tag> waline </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eclipse启动报错:An error has occurred.See the log file</title>
      <link href="posts/f99ba628/"/>
      <url>posts/f99ba628/</url>
      
        <content type="html"><![CDATA[<p>查看log</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ini">!SESSION Fri Apr 02 17:04:21 CST 2021 ------------------------------------------<br>!ENTRY org.eclipse.equinox.launcher 4 0 2021-04-02 17:04:21.998<br>!MESSAGE Exception launching the Eclipse Platform:<br>!STACK<br>java.lang.ClassNotFoundException: org.eclipse.core.runtime.adaptor.EclipseStarter<br>        at java.net.URLClassLoader.findClass(URLClassLoader.java:381)<br>        at java.lang.ClassLoader.loadClass(ClassLoader.java:424)<br>        at java.lang.ClassLoader.loadClass(ClassLoader.java:357)<br>        at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:626)<br>        at org.eclipse.equinox.launcher.Main.basicRun(Main.java:584)<br>        at org.eclipse.equinox.launcher.Main.run(Main.java:1438)<br>        at org.eclipse.equinox.launcher.Main.main(Main.java:1414)<br></code></pre></td></tr></table></figure><p>环境为Ubuntu18.04，eclipse为商店里的，在网上试过许多方法，都没成功，但应该还是缺少必须的组件。</p><p>所以可以用<code>snap</code>(软件相关依赖全在包中)进行安装。</p><p>首先卸载原来的，然后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo snap install eclipse --classic<br></code></pre></td></tr></table></figure><p>这时直接<code>eclipse</code>启动的可能还是原来<code>/usr/bin/</code>里的，需要到已安装软件界面选择进行启动。</p><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21-04-02/eclipse.PNG" alt=""></p><p><strong>左边的图标是商店里的，右边的是snap下载的</strong></p>]]></content>
      
      
      <categories>
          
          <category> Error </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> Eclipse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VirtualBox虚拟机扩容</title>
      <link href="posts/c5008ea5/"/>
      <url>posts/c5008ea5/</url>
      
        <content type="html"><![CDATA[<h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><ol><li><p><code>cmd</code>进入VirtualBox安装路径</p></li><li><p>首先尝试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">VBoxManage modifyhd E:\TFT\VirtualMachine\Ubuntu18\Ubuntu18.vdi --resize 30720<br></code></pre></td></tr></table></figure><p>可能报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">Progress state: VBOX_E_NOT_SUPPORTED<br>VBoxManage.exe: error: Failed to resize medium<br></code></pre></td></tr></table></figure><p>如果没有错误就可以直接进入第7步</p></li><li><p>在原来虚拟机路径下创建空介质（大小为需要的）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">VBoxManage createhd -filename &quot;E:\TFT\VirtualMachine\Ubuntu18\Ubuntu18_30GB.vdi&quot; -size 30720 -format VDI -variant Standard<br></code></pre></td></tr></table></figure></li><li><p>克隆到新介质</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">VBoxManage clonehd &quot;E:\TFT\VirtualMachine\Ubuntu18\Ubuntu18.vdi&quot; &quot;E:\TFT\VirtualMachine\Ubuntu18\Ubuntu18_30GB.vdi&quot; --existing<br></code></pre></td></tr></table></figure></li><li><p>给新介质扩容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">VBoxManage modifyhd &quot;E:\TFT\VirtualMachine\Ubuntu18\Ubuntu18_30GB.vdi&quot; --resize 30720<br></code></pre></td></tr></table></figure></li><li><p>在VirtualBox里设置&gt;存储，单击控制器，右边有添加虚拟硬盘的选项，添加上面的新介质，并移除原来的介质（右键&gt;删除盘片）</p><p>如果添加新介质时提示打开虚拟盘文件失败，查看明细:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Cannot register the hard disk &#x27;E:\TFT\VirtualMachine\Ubuntu18\Ubuntu18_30G.vdi&#x27;<br></code></pre></td></tr></table></figure><p>可以手动注册：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">VBoxManage internalcommands sethduuid &quot;E:\TFT\VirtualMachine\Ubuntu18_30GB.vdi&quot;<br></code></pre></td></tr></table></figure><p>如果失败：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">VBoxManage.exe: error: Format autodetect failed: VERR_FILE_NOT_FOUND<br></code></pre></td></tr></table></figure><p>可以将vdi移动到其他文件夹里再次尝试，直到成功后再去设置里添加虚拟硬盘。</p></li><li><p>开启虚拟机，打开终端，安装gparted</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install gparted<br></code></pre></td></tr></table></figure><p>启动gparted：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo gparted<br></code></pre></td></tr></table></figure><p>进入图形界面后，对已分配的部分右键&gt;更改大小/移动。设置好大小后，菜单栏&gt;编辑&gt;应用全部操作。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Error </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>丑数 &amp; n个骰子的点数 &amp; 构建乘积数组</title>
      <link href="posts/73645ce2/"/>
      <url>posts/73645ce2/</url>
      
        <content type="html"><![CDATA[<h1 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h1><p>题目：<a href="https://leetcode-cn.com/problems/chou-shu-lcof/">Leetcode</a></p><p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>丑数只由2， 3， 5倍数生成，使用三指针法逐个生成（实际上只需要一个数组）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// int dp[n+1];</span><br>        <span class="hljs-keyword">int</span>* dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">int</span> p2 = <span class="hljs-number">1</span>, p3 = <span class="hljs-number">1</span>, p5 = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">int</span> n2 = dp[p2] * <span class="hljs-number">2</span>, n3 = dp[p3] * <span class="hljs-number">3</span>, n5 = dp[p5] * <span class="hljs-number">5</span>;<br>            <span class="hljs-keyword">int</span> mn = min(min(n2, n3), n5);<br>            dp[i] = mn;<br>            <span class="hljs-keyword">if</span>(mn == n2) p2++; <span class="hljs-comment">// 考虑产生相同元素，则指针都要移动</span><br>            <span class="hljs-keyword">if</span>(mn == n3) p3++;<br>            <span class="hljs-keyword">if</span>(mn == n5) p5++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="n个骰子的点数"><a href="#n个骰子的点数" class="headerlink" title="n个骰子的点数"></a>n个骰子的点数</h1><p>题目：<a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/">Leetcode</a></p><p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p><p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率</p><h2 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h2><p>所有组合有<code>6^n</code>种，点数之和的取值范围为<code>[n, 6n]</code>，先计算每种取值的可能种数，再除以总的组合数，就是相应概率。</p><p><code>dp[i][j]</code>，<code>i</code>个骰子得到点数之和为<code>j</code>的种数。对最后一个骰子的取值<code>1~6</code>，累加剩下的<code>n-1</code>骰子对应的种数即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">dicesProbability</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">5</span>*n+<span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// n~6n共5n+1种取值</span><br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; dp(n+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">6</span>*n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)); <span class="hljs-comment">// 第一维和第二维的0号都保持为0</span><br>        <span class="hljs-keyword">double</span> all = <span class="hljs-built_in">pow</span>(<span class="hljs-number">6</span>, n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123; <span class="hljs-comment">// 最小值都只有一种</span><br>            dp[i][i] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">6</span>; i++)&#123; <span class="hljs-comment">// 只有一个骰子时，6种取值各一种</span><br>            dp[<span class="hljs-number">1</span>][i] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123; <span class="hljs-comment">// i个骰子</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>, maxDice = <span class="hljs-number">6</span>*i; j &lt;= maxDice; j++)&#123; <span class="hljs-comment">// 计算其取值之和分别为i+1~6*i的种数</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = max(i<span class="hljs-number">-1</span>, j<span class="hljs-number">-6</span>); k &lt;= j<span class="hljs-number">-1</span>; k++)&#123; <span class="hljs-comment">// 其余i-1个骰子的点数之和k</span><br>                        <span class="hljs-comment">//   其余点数之和最小的情况:</span><br>                        <span class="hljs-comment">//    1.最后一个骰子取6</span><br>                        <span class="hljs-comment">//    2.最小就是i-1</span><br>                    dp[i][j] += dp[i<span class="hljs-number">-1</span>][k];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, dice = n, nDices = <span class="hljs-number">5</span> * n + <span class="hljs-number">1</span>; i &lt; nDices; i++, dice++)&#123;<br>            ans[i] = dp[n][dice] / all;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="构建乘积数组"><a href="#构建乘积数组" class="headerlink" title="构建乘积数组"></a>构建乘积数组</h1><p>题目：<a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/">Leetcode</a></p><p>给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</p><h2 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h2><p>双向遍历各一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">constructArr</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; a)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(a.size())</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, prod = <span class="hljs-number">1</span>; i &lt; a.size(); i++)&#123;<br>            ans[i] = prod; <span class="hljs-comment">// 此时prod = a[0]x...xa[i-1]</span><br>            prod *= a[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = a.size()<span class="hljs-number">-1</span>, prod = <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            ans[i] *= prod; <span class="hljs-comment">// 此时prod = a[i+1]x...xa[n-1]</span><br>            prod *= a[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>连续子数组的最大和 &amp; 礼物的最大价值 &amp; 最长不含重复字符的子字符串</title>
      <link href="posts/2a83dd90/"/>
      <url>posts/2a83dd90/</url>
      
        <content type="html"><![CDATA[<h1 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h1><p>题目：<a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">Leetcode</a></p><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>一开始想到前缀和，但是复杂度仍是O(n^2)，要用这个转移方程：<code>dp[i]=max(dp[i-1]+nums[i],nums[i])</code>，也就是要么接着累加，要么重新开始子数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size())</span></span>;<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.size(); i++)&#123;<br>            dp[i] = max(dp[i<span class="hljs-number">-1</span>]+nums[i], nums[i]);<br>            <span class="hljs-keyword">if</span>(dp[i] &gt; ans) ans = dp[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="礼物的最大价值"><a href="#礼物的最大价值" class="headerlink" title="礼物的最大价值"></a>礼物的最大价值</h1><p>题目：<a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">Leetcode</a></p><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p><h2 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h2><p>首先想到递归：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        m = grid.size(), n = grid[<span class="hljs-number">0</span>].size();<br>        <span class="hljs-keyword">return</span> maxV(grid, m<span class="hljs-number">-1</span>, n<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxV</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>||y&lt;<span class="hljs-number">0</span>||x&gt;=m||y&gt;=n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> max(maxV(grid, x, y<span class="hljs-number">-1</span>), maxV(grid, x<span class="hljs-number">-1</span>, y)) + grid[x][y];<br>    &#125;<br>    <span class="hljs-keyword">int</span> m, n;<br>&#125;;<br></code></pre></td></tr></table></figure><p>但是超时了。。还是得用数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = grid.size(), n = grid[<span class="hljs-number">0</span>].size();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(i<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;j<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>)&#123;<br>                    grid[i][j] += max(grid[i<span class="hljs-number">-1</span>][j], grid[i][j<span class="hljs-number">-1</span>]);<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>)&#123;<br>                    grid[i][j] += grid[i<span class="hljs-number">-1</span>][j];<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>)&#123;<br>                    grid[i][j] += grid[i][j<span class="hljs-number">-1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> grid[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="最长不含重复字符的子字符串"><a href="#最长不含重复字符的子字符串" class="headerlink" title="最长不含重复字符的子字符串"></a>最长不含重复字符的子字符串</h1><p>题目：<a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">Leetcode</a></p><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p><ul><li><code>s.length &lt;= 40000</code></li></ul><h2 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h2><p>滑动窗口，<code>l~r</code>之间不含重复字符，用pos数组记录字符出现的位置，注意字符不只是<code>a-z</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.size() &lt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> pos[<span class="hljs-number">256</span>]; <span class="hljs-comment">// 记录字符出现位置</span><br>        <span class="hljs-built_in">memset</span>(pos, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> pos);<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>, l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(r &lt; s.size())&#123;<br>            <span class="hljs-keyword">if</span>(pos[s[r]] &lt; l)&#123; <span class="hljs-comment">// 新加字符s[r]不在l~r-1中</span><br>                ans = max(ans, r-l+<span class="hljs-number">1</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                l = pos[s[r]]+<span class="hljs-number">1</span>; <span class="hljs-comment">// 否则向右滑动窗口使得l~r-1不含s[r]</span><br>            &#125;<br>            pos[s[r]] = r; <span class="hljs-comment">// 加入s[r]</span><br>            r++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斐波那契数列 &amp; 矩形覆盖</title>
      <link href="posts/9c96a387/"/>
      <url>posts/9c96a387/</url>
      
        <content type="html"><![CDATA[<h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><p>题目：<a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">Leetcode</a></p><p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项（即 <code>F(N)</code>）。</p><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> mod = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>;<br>        n--;<br>        <span class="hljs-keyword">while</span>(n--)&#123;<br>            <span class="hljs-keyword">int</span> t = b;<br>            b = ((<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)b+a) % mod;<br>            a = t;<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="矩形覆盖"><a href="#矩形覆盖" class="headerlink" title="矩形覆盖"></a>矩形覆盖</h1><p>题目：<a href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;tqId=11163&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&amp;from=cyc_github&amp;tab=answerKey">牛客网</a></p><p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p><p>比如n=3时，2*3的矩形块有3种覆盖方法</p><h2 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h2><p>仍然是斐波那契数列，先放第一块，竖着(<code>f(n-1)</code>)或横着（<code>f(n-2)</code>）（因为第二块也只能横着放）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rectCover</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(number &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(number &lt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> number;<br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">2</span>, b = <span class="hljs-number">3</span>;<br>        number -= <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">while</span>(number--)&#123;<br>            <span class="hljs-keyword">int</span> t = b;<br>            b += a;<br>            a = t;<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="青蛙跳台阶"><a href="#青蛙跳台阶" class="headerlink" title="青蛙跳台阶"></a>青蛙跳台阶</h1><p>题目：<a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">Leetcode</a></p><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><h2 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h2><p>同上</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> mod = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">2</span>, b = <span class="hljs-number">3</span>;<br>        n -= <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">while</span>(n--)&#123;<br>            <span class="hljs-keyword">int</span> t = b;<br>            b = ((<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)b+a) % mod;<br>            a = t;<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="跳台阶扩展问题"><a href="#跳台阶扩展问题" class="headerlink" title="跳台阶扩展问题"></a>跳台阶扩展问题</h1><p>题目：<a href="https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&amp;from=cyc_github&amp;tab=answerKey">牛客网</a></p><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><h2 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h2><p>尝试第一步的n种跳法即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">jumpFloorII</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(number &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(number &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> number;<br>        <span class="hljs-keyword">if</span>(number == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">int</span> dp[<span class="hljs-number">1000</span>]&#123;<span class="hljs-number">0</span>&#125;;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>, dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>, dp[<span class="hljs-number">3</span>] = <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">4</span>; i &lt;= number; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++)&#123;<br>                dp[i] += dp[i-j];<br>            &#125;<br>            dp[i]++; <span class="hljs-comment">// 一次性跳n阶</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[number];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组中的逆序对</title>
      <link href="posts/6d820329/"/>
      <url>posts/6d820329/</url>
      
        <content type="html"><![CDATA[<h1 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h1><p>题目：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">Leetcode</a></p><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数</p><p><strong>限制：</strong></p><p><code>0 &lt;= 数组长度 &lt;= 50000</code></p><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>根据输入规模，如果使用暴力遍历(<code>O(n^2)</code>)肯定会超时，一种方法是<code>二分法</code>。构成结果有三个组成部分：左半边+右半边+横跨左右的。利用<code>二路归并排序</code>，当左右两边均有序时，可以通过逐个比较两边的元素可以得到横跨两边的。</p><p>具体实现就是在累加左右两边的并在进行<code>Merge</code>时统计。</p><p><strong>注意不可重复统计</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">reversePairs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> tmp = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(nums.size());<br>        <span class="hljs-keyword">return</span> Sort(nums, <span class="hljs-number">0</span>, nums.size()<span class="hljs-number">-1</span>, tmp);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Sort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; tmp)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(low &lt; high)&#123;<br>            <span class="hljs-keyword">int</span> mid = low + ((high-low)&gt;&gt;<span class="hljs-number">1</span>);<br>            cnt += Sort(nums, low, mid, tmp) + Sort(nums, mid+<span class="hljs-number">1</span>, high, tmp);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = low; i &lt;= high; i++)&#123;<br>                tmp[i] = nums[i];<br>            &#125;<br>            <span class="hljs-keyword">int</span> i, j, k;<br>            <span class="hljs-keyword">for</span>(i = low, j = mid+<span class="hljs-number">1</span>, k = low; i &lt;= mid &amp;&amp; j &lt;= high;)&#123;<br>                <span class="hljs-keyword">if</span>(tmp[i] &lt;= tmp[j])&#123;<br>                    nums[k++] = tmp[i++];<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    cnt += mid-i+<span class="hljs-number">1</span>;<br>                    nums[k++] = tmp[j++];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">int</span> t = high - mid;<br>            <span class="hljs-keyword">while</span>(i &lt;= mid)&#123;<br>                nums[k++] = tmp[i++];<br>                <span class="hljs-comment">// cnt += t; // 之前比较时已经统计过了</span><br>            &#125;<br>            <span class="hljs-keyword">while</span>(j &lt;= high)&#123;<br>                nums[k++] = tmp[j++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p>二分索引树(BIT)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BIT</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; tree;<br>    <span class="hljs-keyword">int</span> n;<br><br><span class="hljs-keyword">public</span>:<br>    BIT(<span class="hljs-keyword">int</span> _n): n(_n), tree(_n + <span class="hljs-number">1</span>) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> x &amp; (-x);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (x) &#123;<br>            ret += tree[x];<br>            x -= lowbit(x);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (x &lt;= n) &#123;<br>            ++tree[x];<br>            x += lowbit(x);<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">reversePairs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.size();<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; tmp = nums;<br>        <span class="hljs-comment">// 离散化</span><br>        sort(tmp.begin(), tmp.end());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>&amp; num: nums) &#123;<br>            num = lower_bound(tmp.begin(), tmp.end(), num) - tmp.begin() + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 树状数组统计逆序对</span><br>        <span class="hljs-function">BIT <span class="hljs-title">bit</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            ans += bit.query(nums[i] - <span class="hljs-number">1</span>);<br>            bit.update(nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>调整数组顺序使奇数位于偶数前面 &amp; 把数组排成最小的数</title>
      <link href="posts/3031e5f3/"/>
      <url>posts/3031e5f3/</url>
      
        <content type="html"><![CDATA[<h1 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h1><p>题目：<a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">Leetcode</a></p><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>将偶数与后面的奇数交换即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">exchange</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.size() &lt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> nums;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = nums.size()<span class="hljs-number">-1</span>; i &lt; j;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &amp; <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">while</span>(!(nums[j] &amp; <span class="hljs-number">1</span>) &amp;&amp; j &gt; i)&#123;<br>                j--;<br>            &#125;<br>            <span class="hljs-keyword">int</span> tmp = nums[i];<br>            nums[i] = nums[j];<br>            nums[j] = tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h1><p>题目：<a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">Leetcode</a></p><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><ul><li>输出结果可能非常大，所以你需要返回一个字符串而不是整数</li><li>拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0</li></ul><h2 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h2><p><code>a</code>和<code>b</code>都是<code>std::string</code>，利用字符串排序（<code>std::string</code>重载了<code>&lt;</code>） <code>a + b &lt; b + a</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">minNumber</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">numss</span><span class="hljs-params">(nums.size())</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++)&#123;<br>            numss[i] = to_string(nums[i]);<br>        &#125;<br>        sort(numss.begin(), numss.end(), [](<span class="hljs-built_in">string</span>&amp; a, <span class="hljs-built_in">string</span>&amp; b)&#123;<br>            <span class="hljs-keyword">return</span> a + b &lt; b + a;<br>        &#125;);<br>        <span class="hljs-built_in">string</span> ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; s : numss)&#123;<br>            ans += s;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器人的运动范围 &amp; 字符串的排列</title>
      <link href="posts/e75214e9/"/>
      <url>posts/e75214e9/</url>
      
        <content type="html"><![CDATA[<h1 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h1><p>题目：<a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">Leetcode</a></p><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。</p><ul><li>1 &lt;= n,m &lt;= 100</li><li>0 &lt;= k &lt;= 20</li></ul><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>回溯。因为<code>m</code>和<code>n</code>都不超过100，所以只要计算个位和十位上的数字之和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        cnt = <span class="hljs-number">0</span>;<br>        mm = m; nn = n; kk = k;<br>        tr(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tr</span><span class="hljs-params">(<span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!trd[r][c] &amp;&amp; r/<span class="hljs-number">10</span> + r%<span class="hljs-number">10</span> + c/<span class="hljs-number">10</span> + c%<span class="hljs-number">10</span> &lt;= kk)&#123;<br>            cnt++;<br>            trd[r][c] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> d = <span class="hljs-number">0</span>; d &lt; <span class="hljs-number">4</span>; d++)&#123;<br>                <span class="hljs-keyword">int</span> rd = r + dr[d], cd = c + dc[d];<br>                <span class="hljs-keyword">if</span>(rd &gt;= <span class="hljs-number">0</span> &amp;&amp; rd &lt; mm &amp;&amp; cd &gt;= <span class="hljs-number">0</span> &amp;&amp; cd &lt; nn)&#123;<br>                    tr(rd, cd);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> mm, nn, kk, cnt;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> dr[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> dc[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">bool</span> trd[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>] = &#123;<span class="hljs-literal">false</span>&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h1><p>题目：<a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">Leetcode</a></p><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><h2 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h2><p>回溯。</p><ul><li>用临时数组<code>tmp</code>保存当前拼成的字符串，用<code>placed</code>数组记录原字符串中对应字符是否已经放到<code>tmp</code>里了，<code>nPlaced</code>就是当前<code>tmp</code>里拼成的字符串长度。</li><li>在回溯过程中，逐个将还没有放置的字符放到<code>tmp</code>拼成的字符串后面，当<code>tmp</code>里放置了<code>s.size()</code>个字符时就代表完成一种排列。（可以手工枚举<code>abc</code>的排列组合）</li></ul><p>但是不能有重复元素，有两种解决方法：</p><ol><li>利用集合中元素不重复的性质</li><li>在放置每个字符前都先检查字符串前面有没有跟这个字符相同的，有相同的的就不用再放置当前字符了。</li></ol><p>这里用第一种方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">permutation</span><span class="hljs-params">(<span class="hljs-built_in">string</span>&amp; s)</span> </span>&#123;<br>        <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-built_in">string</span>&gt; ans;<br>        tr(ans, s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;(ans.begin(), ans.end());<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tr</span><span class="hljs-params">(<span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; ans, <span class="hljs-built_in">string</span>&amp; s, <span class="hljs-keyword">int</span> nPlaced)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(nPlaced == s.size())&#123;<br>            tmp[s.size()] = <span class="hljs-number">0</span>;<br>            ans.insert(<span class="hljs-built_in">string</span>(tmp));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.size(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(!placed[i])&#123;<br>                tmp[nPlaced] = s[i];<br>                placed[i] = <span class="hljs-literal">true</span>;<br>                tr(ans, s, nPlaced+<span class="hljs-number">1</span>);<br>                placed[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">char</span> tmp[<span class="hljs-number">9</span>];<br>    <span class="hljs-keyword">bool</span> placed[<span class="hljs-number">8</span>];<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵中的路径</title>
      <link href="posts/386d387d/"/>
      <url>posts/386d387d/</url>
      
        <content type="html"><![CDATA[<h1 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h1><p>题目：<a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">Leetcode</a></p><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>回溯。有一个特殊优化点：矩阵小于字符串长肯定为<code>false</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; word)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>((row = board.size()) &lt;= <span class="hljs-number">0</span> || <br>            (col = board[<span class="hljs-number">0</span>].size()) &lt;= <span class="hljs-number">0</span> || <br>            (size = word.size()) &lt;= <span class="hljs-number">0</span> ||<br>            row * col &lt; size)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// const int idx = size - 1;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; col; j++)&#123;<br>                <span class="hljs-keyword">if</span>(tr(board, i, j, word, <span class="hljs-number">0</span>))&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-comment">// if(tr(board, i, j, word, idx))&#123;</span><br>                <span class="hljs-comment">//     return true;</span><br>                <span class="hljs-comment">// &#125;</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">tr</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; word, <span class="hljs-keyword">int</span> idx)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(board[r][c] == word[idx])&#123;<br>            <span class="hljs-keyword">if</span>(idx == size<span class="hljs-number">-1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            idx++;<br>            <span class="hljs-comment">// if(idx == 0)&#123;</span><br>            <span class="hljs-comment">//     return true;</span><br>            <span class="hljs-comment">// &#125;</span><br>            <span class="hljs-comment">// idx--;</span><br>            <span class="hljs-keyword">char</span> tmp = board[r][c];<br>            board[r][c] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> d = <span class="hljs-number">0</span>; d &lt; <span class="hljs-number">4</span>; d++)&#123;<br>                <span class="hljs-keyword">int</span> rd = r + dir[d][<span class="hljs-number">0</span>], cd = c + dir[d][<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(rd &gt;= <span class="hljs-number">0</span> &amp;&amp; cd &gt;= <span class="hljs-number">0</span> &amp;&amp; rd &lt; row &amp;&amp; cd &lt; col &amp;&amp;<br>                    tr(board, rd, cd, word, idx))&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>            board[r][c] = tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;&#125;;<span class="hljs-comment">// 右下左上</span><br>    <span class="hljs-keyword">int</span> row, col, size;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>上面代码里注释掉的是按照对字符串倒序遍历进行搜索的，开始一直使用这个方法，但是一直超时，还以为是<code>std::vector</code>的缘故，试了下改成<code>C语言</code>版的，但还是超时。。。后来又看了很多题解，感觉都写得差不多，唯一的不同点就是正序还是逆序遍历字符串。然后就改了几行代码试了下，一下就过了，而且时间和内存都击败了<code>90%</code>多。这才意识到逆序的坏处。这应该是跟地址索引也有计算量有关，尤其是数组很长的时候。</p><p>我之所以习惯用倒序遍历数组，是因为喜欢下面这种写法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = arr.Length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>觉得这样又能省空间（<code>Length</code>都不用暂存了），还能省时间（获取长度也是有消耗的）。。。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值的整数次方</title>
      <link href="posts/a5d3b8f/"/>
      <url>posts/a5d3b8f/</url>
      
        <content type="html"><![CDATA[<h1 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h1><p>题目：<a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">Leetcode</a></p><p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>分治法快速求幂</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> x;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">-1</span>)&#123; <span class="hljs-comment">// 要考虑负指数</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / x;<br>        &#125;<br>        <span class="hljs-keyword">return</span> myPow(x * x, n &gt;&gt; <span class="hljs-number">1</span>) * ((n &amp; <span class="hljs-number">1</span>) ? x : <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序数组中查找 &amp; 0~n-1缺失的数字 &amp; 旋转数组的最小数字</title>
      <link href="posts/23209fd9/"/>
      <url>posts/23209fd9/</url>
      
        <content type="html"><![CDATA[<h1 id="在排序数组中查找数字"><a href="#在排序数组中查找数字" class="headerlink" title="在排序数组中查找数字"></a>在排序数组中查找数字</h1><p>题目：<a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">Leetcode</a></p><p>统计一个数字在排序数组中出现的次数。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>可以直接遍历一次，但是因为数组有序，可以使用二分法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> size = nums.size();<br>        <span class="hljs-keyword">if</span>(size &lt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>, low = <span class="hljs-number">0</span>, high = size<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(low &lt;= high)&#123;<br>            <span class="hljs-keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = mid<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] == target; i--)&#123;<br>                    ans++;<br>                &#125;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = mid; i &lt; size &amp;&amp; nums[i] == target; i++)&#123;<br>                    ans++;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target)&#123;<br>                low = mid+<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                high = mid<span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="0-n-1中缺失的数字"><a href="#0-n-1中缺失的数字" class="headerlink" title="0~n-1中缺失的数字"></a>0~n-1中缺失的数字</h1><p>题目：<a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">Leetcode</a></p><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><h2 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h2><p>同样可以直接遍历一次，第一次出现<code>nums[i] != i</code>的位置就是缺失的数字。但是同样考虑到数组有序，可以使用二分法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.size() &lt;= <span class="hljs-number">0</span> || nums[<span class="hljs-number">0</span>] != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> low = <span class="hljs-number">1</span>, high = nums.size()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(low &lt;= high)&#123;<br>            <span class="hljs-keyword">int</span> mid = low + ((high - low)&gt;&gt;<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(mid == nums[mid])&#123;<br>                low = mid + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid<span class="hljs-number">-1</span>] == mid<span class="hljs-number">-1</span>)&#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                high = mid<span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums.size();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h1><p>题目：<a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">Leetcode</a></p><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。</p><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>按照题意，数组中的元素应该先非递减，然后断崖式减小到最小值，之后又是非递减。可以直接遍历一遍找到这个突然减小的点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(numbers.size() &lt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> ans = numbers[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n : numbers)&#123;<br>            <span class="hljs-keyword">if</span>(n &lt; ans)&#123;<br>                ans = n;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>使用二分法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> size = numbers.size();<br>        <span class="hljs-keyword">if</span>(size &lt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(size == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> numbers[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(numbers[<span class="hljs-number">0</span>] &lt; numbers[size<span class="hljs-number">-1</span>])&#123;<br>            <span class="hljs-keyword">return</span> numbers[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">int</span> low = <span class="hljs-number">1</span>, high = size<span class="hljs-number">-1</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(low &lt; high)&#123; <span class="hljs-comment">// low == high时找到最低点</span><br>            <span class="hljs-keyword">int</span> mid = low + ((high-low)&gt;&gt;<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(numbers[mid] &gt; numbers[high])&#123;<br>                low = mid + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(numbers[mid] &lt; numbers[high])&#123;<br>                high = mid;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                high--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> numbers[low];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>也可以用<code>mid</code>和<code>low</code>相比较，但是可能出现<code>low</code>对应的就是最小值的情况（也就是前一个更大），需要在循环中提前判断。因为不是直接递增有序时<code>low</code>起始值为<code>1</code>，所以不会越界。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> size = numbers.size();<br>        <span class="hljs-keyword">if</span>(size &lt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(size == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> numbers[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(numbers[<span class="hljs-number">0</span>] &lt; numbers[size<span class="hljs-number">-1</span>])&#123; <span class="hljs-comment">// 已经递增有序</span><br>            <span class="hljs-keyword">return</span> numbers[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">int</span> low = <span class="hljs-number">1</span>, high = size<span class="hljs-number">-1</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(low &lt; high)&#123; <span class="hljs-comment">// low == high时找到最低点</span><br>            <span class="hljs-keyword">int</span> mid = low + ((high-low)&gt;&gt;<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(numbers[low<span class="hljs-number">-1</span>] &gt; numbers[low])&#123; <span class="hljs-comment">// low对应的就是最小值</span><br>                <span class="hljs-keyword">return</span> numbers[low];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(numbers[mid] &gt; numbers[low])&#123;<br>                low = mid + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(numbers[mid] &lt; numbers[low])&#123;<br>                high = mid;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                low++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> numbers[low];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上题目都是使用二分法进行优化，所以对于<code>有序</code>相关的问题都可以优先考虑使用二分法进行快速查找。在查找过程还要额外注意边界值的处理。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>股票的最大利润</title>
      <link href="posts/56546d44/"/>
      <url>posts/56546d44/</url>
      
        <content type="html"><![CDATA[<h1 id="股票的最大利润"><a href="#股票的最大利润" class="headerlink" title="股票的最大利润"></a>股票的最大利润</h1><p>题目：<a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">Leetcode</a></p><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>暴力遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> size = prices.size();<br>        <span class="hljs-keyword">if</span>(size &lt;= <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size - <span class="hljs-number">1</span>; i++)&#123; <span class="hljs-comment">// i时购买</span><br>            <span class="hljs-keyword">if</span>(prices[i+<span class="hljs-number">1</span>] &gt; prices[i])&#123; <span class="hljs-comment">// 剪枝</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; size; j++)&#123; <span class="hljs-comment">// j时卖出</span><br>                    ans = max(ans, prices[j] - prices[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>解法一存在重复遍历的情况，其实只需要遍历一次，同时保存前面的最小值即可（可以认为是一种贪心思想，在当前这个时间点，要得到最大利润，肯定是假定在之前价格最低的时候买入了）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> size = prices.size();<br>        <span class="hljs-keyword">if</span>(size &lt;= <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>, minP = prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; size; i++)&#123;<br>            ans = max(ans, prices[i] - minP);<br>            minP = min(minP, prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剪绳子</title>
      <link href="posts/1e19723b/"/>
      <url>posts/1e19723b/</url>
      
        <content type="html"><![CDATA[<h1 id="剪绳子"><a href="#剪绳子" class="headerlink" title="剪绳子"></a>剪绳子</h1><p>题目：<a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">Leetcode</a></p><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><ul><li><p>数学推导：</p><p>绳子长为<code>n</code>，假设分成<code>m</code>段，要求的就是 <script type="math/tex">{(\frac{n}{m})}^m</script> 的最大值。</p><p>先取对数可得 <script type="math/tex">m\ln{\frac{n}{m}}</script> ， 然后求导可得 <script type="math/tex">\ln{\frac{n}{m}}+m\times\frac{m}{n}\times{-\frac{n}{m^2}}=\ln{\frac{n}{m}}-1</script> 。</p><p>从而当 <script type="math/tex">\ln{\frac{n}{m}} > 1 => \frac{n}{m} > e => m < \frac{n}{e}</script> 时结果会随<code>m</code>的增大而递增，因此每段长度为 <script type="math/tex">e</script> 时取得极值，而 <script type="math/tex">e\approx2.7</script> ，所以极值附近每段长度可以取<code>2</code>或<code>3</code>，带入 <script type="math/tex">{(\frac{n}{m})}^m</script> 可知，每段长为<code>3</code>时更大。</p></li><li><p>贪心：</p><p>根据推导结果，要尽量剪出长度为<code>3</code>的部分，但是如果剩余部分长为<code>1</code>，根据 <script type="math/tex">3\times1<2\times2</script> ，则最后一部分不要剪成<code>3</code>，而是跟剩余的部分组成两段长度为<code>2</code>的。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> n<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">4</span>)&#123;<br>            ans *= <span class="hljs-number">3</span>;<br>            n -= <span class="hljs-number">3</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans * n;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>动态规划：<code>dp[i]</code>表示长为<code>i</code>的绳子剪掉后的最大乘积。</p><p>假设剪掉第一段长度为<code>j</code>，剩余长度为<code>i-j</code>的绳子如果不剪，则乘积为<code>j*(i-j)</code>，否则为<code>j*dp[i-j]</code>。</p><p>第一段的长度一定不是<code>1</code>，因为<code>1</code>对乘积没有贡献，所以<code>j</code>的值需要遍历<code>[2, i/2]</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> n<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-comment">//vector&lt;int&gt; dp(n+1, 0);</span><br>        <span class="hljs-keyword">int</span>* dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>]&#123;<span class="hljs-number">0</span>&#125;;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>; dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>; dp[<span class="hljs-number">3</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">4</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>, u = i &gt;&gt; <span class="hljs-number">1</span>; j &lt;= u; j++)&#123;<br>                dp[i] = max(dp[i], max(j*(i-j), j * dp[i-j]));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><em>注意：用<code>std::vector</code>会明显慢很多</em></p><h1 id="剪绳子II"><a href="#剪绳子II" class="headerlink" title="剪绳子II"></a>剪绳子II</h1><p>题目：<a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/">Leetcode</a></p><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m - 1] 。请问 k[0]<em>k[1]</em>…*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>改用<code>long</code>并对<code>1000000007</code>取余</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> n<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">long</span> ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">4</span>)&#123;<br>            ans *= <span class="hljs-number">3</span>;<br>            <span class="hljs-keyword">if</span>(ans &gt; <span class="hljs-number">1000000007</span>)&#123;<br>                ans %= <span class="hljs-number">1000000007</span>;<br>            &#125;<br>            n -= <span class="hljs-number">3</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (ans * n)%<span class="hljs-number">1000000007</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树的最近公共祖先 &amp; 二叉树的最近公共祖先</title>
      <link href="posts/24715217/"/>
      <url>posts/24715217/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h1><p>题目：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">Leetcode</a></p><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p><code>DFS</code>同时记录两个结点是否在左子树和右子树中，利用搜索树的性质进行剪枝</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root || !p || !q) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        pVal = p-&gt;val;<br>        qVal = q-&gt;val;<br>        <span class="hljs-keyword">if</span>(pVal &gt; qVal) swap(pVal, qVal);<br>        ans = <span class="hljs-literal">nullptr</span>;<br>        DFS(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(ans)&#123;<br>            <span class="hljs-keyword">return</span> no;<br>        &#125;<br>        <span class="hljs-keyword">int</span> state = no;<br>        <span class="hljs-keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;val &gt; pVal) state += DFS(root-&gt;left);<br>        <span class="hljs-keyword">if</span>(root-&gt;right &amp;&amp; root-&gt;val &lt; qVal) state += DFS(root-&gt;right);<br>        <span class="hljs-keyword">if</span>(!ans)&#123;<br>            <span class="hljs-keyword">if</span>(root-&gt;val == pVal)&#123;<br>                state += hasP;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;val == qVal)&#123;<br>                state += hasQ;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(state == (hasP | hasQ))&#123;<br>                ans = root;<br>            &#125;<br>            <span class="hljs-keyword">return</span> state;<br>        &#125;<br>        <span class="hljs-keyword">return</span> no;<br>    &#125;<br><br>    TreeNode* ans;<br>    <span class="hljs-keyword">int</span> pVal, qVal;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> no = <span class="hljs-number">0</span>, hasP = <span class="hljs-number">1</span>, hasQ = <span class="hljs-number">2</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>其实根据二叉搜索树的性质还可以更进一步得到：如果这两个结点分别在左右子树中（包括根），那么根节点就是最近的公共祖先！否则就分别到左右子树中进行递归判断。根本不用担心是不是深度最大的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val)&#123;<br>            <span class="hljs-keyword">return</span> lowestCommonAncestor(root-&gt;right, p, q);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val)&#123;<br>            <span class="hljs-keyword">return</span> lowestCommonAncestor(root-&gt;left, p, q);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>其实这里的遍历指挥涉及左右子树中的一边，于是可以改成迭代形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = p-&gt;val &lt; q-&gt;val ? p-&gt;val : q-&gt;val;<br>        <span class="hljs-keyword">int</span> right = p-&gt;val &gt; q-&gt;val ? p-&gt;val : q-&gt;val;<br>        <span class="hljs-keyword">while</span>(root)&#123;<br>            <span class="hljs-keyword">if</span>(root-&gt;val &lt; left) root = root-&gt;right;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;val &gt; right) root = root-&gt;left;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h1><p>题目：<a href="[剑指 Offer 68 - II. 二叉树的最近公共祖先 - 力扣（LeetCode） (leetcode-cn.com">Leetcode</a>](<a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/</a>))</p><p>相对于上一题就是变成了普通的二叉树</p><h2 id="解法一-1"><a href="#解法一-1" class="headerlink" title="解法一"></a>解法一</h2><p>将上一题<code>DFS</code>的解法里剪枝的部分去掉</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root || !p || !q) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        pVal = p-&gt;val;<br>        qVal = q-&gt;val;<br>        ans = <span class="hljs-literal">nullptr</span>;<br>        DFS(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(ans) <span class="hljs-keyword">return</span> no;<br>        <span class="hljs-keyword">int</span> state = no;<br>        <span class="hljs-keyword">if</span>(root-&gt;left) state += DFS(root-&gt;left);<br>        <span class="hljs-keyword">if</span>(root-&gt;right) state += DFS(root-&gt;right);<br>        <span class="hljs-keyword">if</span>(!ans)&#123;<br>            <span class="hljs-keyword">if</span>(root-&gt;val == pVal) state += hasP;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;val == qVal) state += hasQ;<br>            <span class="hljs-keyword">if</span>(state == (hasP | hasQ)) ans = root;<br>            <span class="hljs-keyword">return</span> state;<br>        &#125;<br>        <span class="hljs-keyword">return</span> no;<br>    &#125;<br><br>    TreeNode* ans;<br>    <span class="hljs-keyword">int</span> pVal, qVal;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> no = <span class="hljs-number">0</span>, hasP = <span class="hljs-number">1</span>, hasQ = <span class="hljs-number">2</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二-1"><a href="#解法二-1" class="headerlink" title="解法二"></a>解法二</h2><p>后序遍历，判断左右子树中的存在情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root || root == p || root == q)&#123; <span class="hljs-comment">// nullptr则没有，否则找到一个</span><br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> l = lowestCommonAncestor(root-&gt;left, p, q); <span class="hljs-comment">// 左子树中找</span><br>        <span class="hljs-keyword">auto</span> r = lowestCommonAncestor(root-&gt;right, p, q);<span class="hljs-comment">// 右子树中找</span><br>        <span class="hljs-keyword">if</span>(l &amp;&amp; r)&#123;  <span class="hljs-comment">// 左右子树各有一个</span><br>            <span class="hljs-keyword">return</span> root;  <span class="hljs-comment">// 那么root就是最近的祖先</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> l ? l : r; <span class="hljs-comment">// 否则一定是全在左子树或全在右子树</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h1><p>使用前序遍历把从<code>root</code>到<code>p</code> 和<code>q</code>的路径都求出来，然后求路径上最后一个公共点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;TreeNode*&gt; pathP, pathQ;<br>        GetPath(root, p, pathP);<br>        GetPath(root, q, pathQ);<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> u = min(pathP.size(), pathQ.size()); i &lt; u; i++)&#123;<br>            <span class="hljs-keyword">if</span>(pathP[i] != pathQ[i])&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pathP[--i];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GetPath</span><span class="hljs-params">(TreeNode* root, TreeNode* p, <span class="hljs-built_in">vector</span>&lt;TreeNode*&gt;&amp; path)</span></span>&#123;<br>        path.push_back(root);<br>        <span class="hljs-keyword">if</span>(root == p)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root-&gt;left &amp;&amp; path[path.size()<span class="hljs-number">-1</span>] != p)&#123;<br>            GetPath(root-&gt;left, p, path);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root-&gt;right &amp;&amp; path[path.size()<span class="hljs-number">-1</span>] != p)&#123;<br>            GetPath(root-&gt;right, p, path);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(path[path.size()<span class="hljs-number">-1</span>] != p)&#123;<br>            path.pop_back();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><em>非递归解法待续…</em></p>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树的第k大节点 &amp; 二叉树的深度 &amp; 平衡二叉树</title>
      <link href="posts/c031c80/"/>
      <url>posts/c031c80/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉搜索树的第k大节点"><a href="#二叉搜索树的第k大节点" class="headerlink" title="二叉搜索树的第k大节点"></a>二叉搜索树的第k大节点</h1><p>题目：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">Leetcode</a></p><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>先遍历右子树，然后是根，最后是左子树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kthLargest</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        cnt = <span class="hljs-number">0</span>;<br>        tk = k;<br>        ans = <span class="hljs-literal">nullptr</span>;<br>        DFS(root);<br>        <span class="hljs-keyword">return</span> ans ? ans-&gt;val : <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root-&gt;right) DFS(root-&gt;right);<br>        <span class="hljs-keyword">if</span>(++cnt == tk)&#123;<br>            ans = root;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root-&gt;left) DFS(root-&gt;left);<br>    &#125;<br>    <span class="hljs-keyword">int</span> cnt, tk;<br>    TreeNode* ans;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h1><p>题目：<a href="[剑指 Offer 55 - I. 二叉树的深度 - 力扣（LeetCode） (leetcode-cn.com">Leetcode</a>](<a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/</a>))</p><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p><h2 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h2><p><code>DFS</code>同时记录深度，遍历完左右子树后回溯</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        maxD = curD = <span class="hljs-number">0</span>;<br>        DFS(root);<br>        <span class="hljs-keyword">return</span> maxD;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        curD++;<br>        <span class="hljs-keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)&#123;<br>            maxD = curD &gt; maxD ? curD : maxD;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(root-&gt;left) DFS(root-&gt;left);<br>            <span class="hljs-keyword">if</span>(root-&gt;right) DFS(root-&gt;right);<br>        &#125;<br>        curD--;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> maxD, curD;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><p>题目：<a href="[剑指 Offer 55 - II. 平衡二叉树 - 力扣（LeetCode） (leetcode-cn.com">Leetcode</a>](<a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/</a>))</p><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p><code>DFS</code>判断左子树和右子树高度差，然后递归判断左右子树是否也平衡</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(depth(root-&gt;left) - depth(root-&gt;right)) &lt;= <span class="hljs-number">1</span> &amp;&amp; <br>            isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">depth</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + max(depth(root-&gt;left), depth(root-&gt;right));<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>将<code>depth</code>函数的返回值略加修改， 如果返回<code>-1</code>则表示不平衡，可以提前结束递归</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> depth(root) != <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">depth</span><span class="hljs-params">(TreeNode* root)</span></span>&#123; <span class="hljs-comment">// 平衡则返回深度，否则返回-1</span><br>        <span class="hljs-keyword">if</span>(!root)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> left = depth(root-&gt;left);<br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> right = depth(root-&gt;right);<br>        <span class="hljs-keyword">if</span>(right == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(left-right) &lt;= <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> + max(left,right) : <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><em>不过可能是用了中间变量的缘故，执行用时反而比解法一多</em></p>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序列化二叉树</title>
      <link href="posts/20229cfb/"/>
      <url>posts/20229cfb/</url>
      
        <content type="html"><![CDATA[<h1 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h1><p>题目：<a href="[剑指 Offer 37. 序列化二叉树 - 力扣（LeetCode） (leetcode-cn.com">Leetcode</a>](<a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/">https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/</a>))</p><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>用<code>BFS</code>进行序列化和反序列，与<code>BFS</code>模板不同的是，即使子树为空也要加入队列。而且在反序列化的队列中需要保存<code>二级指针</code>用于对原指针进行修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codec</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[]&quot;</span>;<br>        &#125;<br>        <span class="hljs-built_in">string</span> ans = <span class="hljs-string">&quot;[&quot;</span>;<br>        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; q;<br>        q.push(root);<br>        <span class="hljs-keyword">while</span>(!q.empty())&#123;<br>            <span class="hljs-keyword">int</span> size = q.size();<br>            TreeNode* node;<br>            <span class="hljs-keyword">while</span>(size--)&#123;<br>                node = q.front();<br>                q.pop();<br>                <span class="hljs-keyword">if</span>(node)&#123;<br>                    ans += to_string(node-&gt;val) + <span class="hljs-string">&quot;,&quot;</span>;<br>                    q.push(node-&gt;left);<br>                    q.push(node-&gt;right);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    ans += <span class="hljs-string">&quot;null,&quot;</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        ans += <span class="hljs-string">&quot;]&quot;</span>;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(<span class="hljs-built_in">string</span> data)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(data == <span class="hljs-string">&quot;[]&quot;</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        TreeNode* ans;<br>        <span class="hljs-built_in">queue</span>&lt;TreeNode**&gt; q;<br>        q.push(&amp;ans);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, u = data.size()<span class="hljs-number">-1</span>; i &lt; u;)&#123;<br>            TreeNode** node = q.front();<br>            q.pop();<br>            <span class="hljs-keyword">if</span>(data[i] != <span class="hljs-string">&#x27;n&#x27;</span>)&#123;<br>                <span class="hljs-keyword">int</span> j = i;<br>                <span class="hljs-keyword">while</span>(data[j] != <span class="hljs-string">&#x27;,&#x27;</span>) j++;<br>                <span class="hljs-keyword">int</span> val = stoi(data.substr(i, j-i));<br>                *node = <span class="hljs-keyword">new</span> TreeNode(val);<br>                q.push(&amp;((*node)-&gt;left));<br>                q.push(&amp;((*node)-&gt;right));<br>                i = j+<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                *node = <span class="hljs-literal">nullptr</span>;<br>                i += <span class="hljs-number">5</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>注意到题目下面有这样的注释</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Your Codec object will be instantiated and called as such:</span><br><span class="hljs-comment">// Codec codec;</span><br><span class="hljs-comment">// codec.deserialize(codec.serialize(root));</span><br></code></pre></td></tr></table></figure><p>所以可以…</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codec</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;r = root;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(<span class="hljs-built_in">string</span> data)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;r;<br>    &#125;<br>    TreeNode* r;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树中和为某一值的路径 &amp; 二叉搜索树与双向链表</title>
      <link href="posts/d98c3949/"/>
      <url>posts/d98c3949/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h1><p>题目：<a href="https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&amp;tqId=11177&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&amp;from=cyc_github&amp;tab=answerKey">牛客网</a></p><p>输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>首先想到用先序遍历，遍历时用<code>curPath</code>记录当前路径，用<code>curSum</code>记录当前路径总和。如果已经到达了叶子节点（没有左右孩子）并且<code>curSum==sum</code>，就将当前路径加入解集。</p><p>遍历完左右子树之后要向上<code>回溯</code>一个结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; FindPath(TreeNode* root,<span class="hljs-keyword">int</span> expectNumber) &#123;<br>        <span class="hljs-keyword">if</span>(!root)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;();<br>        &#125;<br>        ts = expectNumber;<br>        DFS(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode* node)</span></span>&#123;<br>        curSum += node-&gt;val;<br>        curPath.push_back(node-&gt;val);<br>        <span class="hljs-keyword">if</span>(!node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; curSum == ts)&#123;<br>            ans.push_back(curPath);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(node-&gt;left) DFS(node-&gt;left);<br>        <span class="hljs-keyword">if</span>(node-&gt;right) DFS(node-&gt;right);<br>        curSum -= node-&gt;val; <br>        curPath.pop_back();<br>    &#125;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; curPath;<br>    <span class="hljs-keyword">int</span> curSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> ts;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h1><p>题目：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">LeetCode</a></p><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p><h2 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h2><p>二叉搜索树中序遍历的结果就是顺序递增的，中序遍历时保存前一个结点的指针即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">treeToDoublyList</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        left = head = <span class="hljs-literal">nullptr</span>;<br>        DFS(root);<br>        head-&gt;left-&gt;right = head;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(Node* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root-&gt;left) DFS(root-&gt;left);<br>        <span class="hljs-keyword">if</span>(!head) head = root;<br>        <span class="hljs-keyword">else</span> left-&gt;right = root;<br>        root-&gt;left = left;<br>        left = root;<br>        head-&gt;left = root;<br>        <span class="hljs-keyword">if</span>(root-&gt;right) DFS(root-&gt;right);<br>    &#125;<br><br>    Node* left, *head;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树的后序遍历序列</title>
      <link href="posts/123e7ea7/"/>
      <url>posts/123e7ea7/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h1><p>题目：<a href="https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&amp;tqId=11176&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&amp;from=cyc_github&amp;tab=answerKey">牛客网</a></p><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。假设输入的数组的任意两个数字都互不相同。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>后序遍历序列的最后一个元素是树根，左边都大于树根的子序列就是右子树，再左边就是左子树。找到左子树后，判断是否都小于树根。然后递归判断左右子树是否也是后序遍历序列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">VerifySquenceOfBST</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(postorder.size() &lt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> verify(postorder, <span class="hljs-number">0</span>, postorder.size()<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">verify</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(L&gt;=R || L &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> idx = R;<br>        <span class="hljs-keyword">while</span>(idx &gt; <span class="hljs-number">0</span> &amp;&amp; arr[idx<span class="hljs-number">-1</span>] &gt; arr[R])&#123;<br>            idx--;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = L; i &lt; idx; i++)&#123;<br>            <span class="hljs-keyword">if</span>(arr[i] &gt; arr[R])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> verify(arr, L, idx<span class="hljs-number">-1</span>) &amp;&amp; verify(arr, idx, R<span class="hljs-number">-1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从上往下打印二叉树 &amp; 把二叉树打印成多行 &amp; 按之字形顺序打印二叉树</title>
      <link href="posts/34e01373/"/>
      <url>posts/34e01373/</url>
      
        <content type="html"><![CDATA[<h1 id="从上往下打印二叉树"><a href="#从上往下打印二叉树" class="headerlink" title="从上往下打印二叉树"></a>从上往下打印二叉树</h1><p>题目：<a href="https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&amp;tqId=11175&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&amp;from=cyc_github&amp;tab=answerKey">牛客网</a></p><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>层序遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">PrintFromTopToBottom</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;();<br>        &#125;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; q;<br>        q.push(root);<br>        <span class="hljs-keyword">while</span>(!q.empty())&#123;<br>            TreeNode* node = q.front();<br>            q.pop();<br>            ans.push_back(node-&gt;val);<br>            <span class="hljs-keyword">if</span>(node-&gt;left)&#123;<br>                q.push(node-&gt;left);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(node-&gt;right)&#123;<br>                q.push(node-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="把二叉树打印成多行"><a href="#把二叉树打印成多行" class="headerlink" title="把二叉树打印成多行"></a>把二叉树打印成多行</h1><p>题目：<a href="https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&amp;from=cyc_github&amp;tab=answerKey">牛客网</a></p><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p><h2 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h2><p>层序遍历，并用<code>nullptr</code>标记一层的结束</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; Print(TreeNode* pRoot) &#123;<br>        <span class="hljs-keyword">if</span>(!pRoot)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;();<br>        &#125;<br>        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; q;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;<br>        ans.push_back(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">1</span>, pRoot-&gt;val));<br>        q.push(pRoot);<br>        q.push(<span class="hljs-literal">nullptr</span>);<br>        <span class="hljs-keyword">while</span>(!q.empty())&#123;<br>            TreeNode* node = q.front();<br>            q.pop();<br>            <span class="hljs-keyword">if</span>(!node)&#123;<br>                <span class="hljs-keyword">if</span>(q.empty())&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">level</span><span class="hljs-params">(q.size())</span></span>;<br>                <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">tmp</span><span class="hljs-params">(q)</span></span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; !tmp.empty(); i++)&#123;<br>                    level[i] = tmp.front()-&gt;val;<br>                    tmp.pop();<br>                &#125;<br>                ans.push_back(level);<br>                q.push(<span class="hljs-literal">nullptr</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(node-&gt;left)&#123;<br>                    q.push(node-&gt;left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node-&gt;right)&#123;<br>                    q.push(node-&gt;right);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure><p>或者不进行标记，<code>BFS</code>模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; Print(TreeNode* pRoot) &#123;<br>        <span class="hljs-keyword">if</span>(!pRoot)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;();<br>        &#125;<br>        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; q;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;<br>        q.push(pRoot);<br>        <span class="hljs-keyword">while</span>(!q.empty())&#123;<br>            <span class="hljs-keyword">int</span> size = q.size();<br>            <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">level</span><span class="hljs-params">(size)</span></span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>                TreeNode* node = q.front();<br>                level[i] = node-&gt;val;<br>                q.pop();<br>                <span class="hljs-keyword">if</span>(node-&gt;left)&#123;<br>                    q.push(node-&gt;left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node-&gt;right)&#123;<br>                    q.push(node-&gt;right);<br>                &#125;<br>            &#125;<br>            ans.push_back(level);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="按之字形顺序打印二叉树"><a href="#按之字形顺序打印二叉树" class="headerlink" title="按之字形顺序打印二叉树"></a>按之字形顺序打印二叉树</h1><p>题目：<a href="https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&amp;tqId=11212&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&amp;from=cyc_github&amp;tab=answerKey">牛客网</a></p><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p><h2 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h2><p>设置一个标记<code>left</code>改变<code>BFS</code>遍历子孩子的顺序即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; Print(TreeNode* pRoot) &#123;<br>        <span class="hljs-keyword">if</span>(!pRoot)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;();<br>        &#125;<br>        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; q;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">bool</span> left = <span class="hljs-literal">true</span>;<br>        q.push(pRoot);<br>        <span class="hljs-keyword">while</span>(!q.empty())&#123;<br>            <span class="hljs-keyword">int</span> size = q.size();<br>            <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">level</span><span class="hljs-params">(size)</span></span>;<br>            left = !left;<br>            TreeNode* node;<br>            <span class="hljs-keyword">if</span>(left)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = size<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>                    node = q.front(); q.pop();<br>                    level[i] = node-&gt;val;<br>                    <span class="hljs-keyword">if</span>(node-&gt;left) q.push(node-&gt;left);<br>                    <span class="hljs-keyword">if</span>(node-&gt;right) q.push(node-&gt;right);<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>                    node = q.front(); q.pop();<br>                    level[i] = node-&gt;val;<br>                    <span class="hljs-keyword">if</span>(node-&gt;left) q.push(node-&gt;left);<br>                    <span class="hljs-keyword">if</span>(node-&gt;right) q.push(node-&gt;right);<br>                &#125;<br>            &#125;<br>            ans.push_back(level);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这三道题关键都是掌握<code>BFS</code>模板（之前一直使用层序遍历的模板，代码不够简洁，遍历完一层结点还需要设置标记）。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树的子结构 &amp; 二叉树的镜像 &amp; 对称的二叉树</title>
      <link href="posts/399c2d93/"/>
      <url>posts/399c2d93/</url>
      
        <content type="html"><![CDATA[<h1 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h1><p>题目：<a href="https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&amp;tqId=11170&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&amp;from=cyc_github&amp;tab=answerKey">牛客网</a></p><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>将两棵树的先序遍历序列保存下来，转为判断数组的子序列问题，而这个可以用<a href="/posts/5782a085/">KMP算法</a>解决</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct TreeNode *left;</span><br><span class="hljs-comment">struct TreeNode *right;</span><br><span class="hljs-comment">TreeNode(int x) :</span><br><span class="hljs-comment">val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">HasSubtree</span><span class="hljs-params">(TreeNode* pRoot1, TreeNode* pRoot2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!pRoot1 || !pRoot2)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; pre1, pre2;<br>        DFS(pRoot1, pre1);<br>        DFS(pRoot2, pre2);<br>        <span class="hljs-keyword">return</span> KMP(pre1, pre2) &gt;= <span class="hljs-number">0</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode* root, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; pre)</span></span>&#123;<br>        pre.push_back(root-&gt;val);<br>        <span class="hljs-keyword">if</span>(root-&gt;left)&#123;<br>            DFS(root-&gt;left, pre);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root-&gt;right)&#123;<br>            DFS(root-&gt;right, pre);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GetNextval</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; next, <span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; t)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> sizeT = t.size();<br>        next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; sizeT)&#123;<br>            <span class="hljs-keyword">if</span>(j == <span class="hljs-number">-1</span> || t[i] == t[j])&#123;<br>                i++; j++;<br>                next[i] = t[i] != t[j] ? j : next[j];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                j = next[j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">KMP</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; s, <span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; t)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> sSize = s.size(), tSize = t.size();<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">nextval</span><span class="hljs-params">(tSize)</span></span>;<br>        GetNextval(nextval, t);<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; sSize &amp;&amp; j &lt; tSize)&#123;<br>            <span class="hljs-keyword">if</span>(j == <span class="hljs-number">-1</span> || s[i] == t[j])&#123;<br>                i++; j++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                j = nextval[j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> j &gt;= tSize ? i - tSize : <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>递归判断：</p><ul><li><code>包含</code>的子树可能是从树根开始，或者在左子树里，或者在右子树里</li><li>判断<code>是子树</code>则需要树根相等并且左右子树都分别包含。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">HasSubtree</span><span class="hljs-params">(TreeNode* pRoot1, TreeNode* pRoot2)</span> </span>&#123; <span class="hljs-comment">// 判断包含子树</span><br>        <span class="hljs-keyword">if</span>(!pRoot1 || !pRoot2)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> DFS(pRoot1, pRoot2) || <br>            HasSubtree(pRoot1-&gt;left, pRoot2) || <br>            HasSubtree(pRoot1-&gt;right, pRoot2);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span>&#123; <span class="hljs-comment">// 判断是子树</span><br>        <span class="hljs-keyword">if</span>(!pRoot2) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(!pRoot1) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> pRoot1-&gt;val == pRoot2-&gt;val &amp;&amp; <br>            DFS(pRoot1-&gt;left, pRoot2-&gt;left) &amp;&amp; <br>            DFS(pRoot1-&gt;right, pRoot2-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h1><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>递归</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Mirror</span><span class="hljs-params">(TreeNode *pRoot)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(pRoot)&#123;<br>            <span class="hljs-keyword">auto</span> tmp = pRoot-&gt;left;<br>            pRoot-&gt;left = pRoot-&gt;right;<br>            pRoot-&gt;right = tmp;<br>            Mirror(pRoot-&gt;left);<br>            Mirror(pRoot-&gt;right);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h1><p>题目：<a href="https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&amp;tqId=11211&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&amp;from=cyc_github&amp;tab=answerKey">牛客网</a></p><p>请实现一个函数，用来判断一棵二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p><h2 id="解法一-1"><a href="#解法一-1" class="headerlink" title="解法一"></a>解法一</h2><p>用层序遍历，一层遍历完后判断队列中的元素（实际是下一层的所有结点）是否对称</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* pRoot)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!pRoot)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        TreeNode* q[<span class="hljs-number">500</span>];<br>        TreeNode* end = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">int</span> front = <span class="hljs-number">0</span>, rear = <span class="hljs-number">0</span>;<br>        q[rear++] = pRoot;<br>        q[rear++] = end;<br>        <span class="hljs-keyword">while</span>(front != rear)&#123;<br>            TreeNode* child = q[front++];<br>            <span class="hljs-keyword">if</span>(child == end)&#123; <span class="hljs-comment">// 一层结束</span><br>                <span class="hljs-keyword">if</span>(front == rear)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = front, j = rear<span class="hljs-number">-1</span>; i &lt;= j; i++, j--)&#123;<br>                    <span class="hljs-keyword">if</span>(!q[i] &amp;&amp; !q[j])&#123;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!(q[i] &amp;&amp; q[j]) || q[i]-&gt;val != q[j]-&gt;val)&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                &#125;<br>                q[rear++] = end;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(child)&#123;<br>                q[rear++] = child-&gt;left;<br>                q[rear++] = child-&gt;right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二-1"><a href="#解法二-1" class="headerlink" title="解法二"></a>解法二</h2><p>递归判断子树是否镜像：左右子树的根相等，并且左子树的左子树和右子树的右子树镜像，并且左子树的右子树和右子树的左子树镜像。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSymmetrical</span><span class="hljs-params">(TreeNode* left, TreeNode* right)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!left &amp;&amp; !right)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!left || !right)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left-&gt;val == right-&gt;val &amp;&amp;<br>            isSymmetrical(left-&gt;left, right-&gt;right) &amp;&amp; <span class="hljs-comment">// 左子树的左子树和右子树的右子树镜像</span><br>            isSymmetrical(left-&gt;right, right-&gt;left);   <span class="hljs-comment">// 左子树的右子树和右子树的左子树镜像</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSymmetrical</span><span class="hljs-params">(TreeNode* pRoot)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!pRoot)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> isSymmetrical(pRoot-&gt;left, pRoot-&gt;right);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于树的结构，尤其是二叉树，用递归的方法往往能简洁地解决问题，所以第一想法应该是能不能用递归解决，比如上面三道题都是非常典型的递归题。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内部排序算法</title>
      <link href="posts/3518881f/"/>
      <url>posts/3518881f/</url>
      
        <content type="html"><![CDATA[<div class="note info simple"><p>各排序算法默认按照递增的顺序</p></div><hr><h1 id="简单排序"><a href="#简单排序" class="headerlink" title="简单排序"></a>简单排序</h1><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><h3 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h3><p>数组前部分有序,后部分无序,每次将无序部分的第一个元素向前插入到合适的位置(将元素逐个后移)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InsertSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;  <span class="hljs-comment">// 开始时有序部分只有0号元素</span><br>        <span class="hljs-keyword">if</span> (arr[i] &lt; arr[i - <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-keyword">int</span> tmp = arr[i], j;<br>            <span class="hljs-keyword">for</span> (j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; tmp; j--) &#123;<br>                arr[j + <span class="hljs-number">1</span>] = arr[j];<br>            &#125;<br>            arr[j + <span class="hljs-number">1</span>] = tmp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><h3 id="主要思想-1"><a href="#主要思想-1" class="headerlink" title="主要思想"></a>主要思想</h3><p>数组前部分有序,后部分无序,每次从无序部分选择最值放到有序部分的后面,也就是无序部分的第一个.</p><p>这个<code>放</code>的操作可以有两种方法:</p><ol><li>将元素逐个后移从而空出位置.移动元素与<a href="/posts/3518881f/#直接插入排序">直接插入排序</a>的移动元素不同的是,这里移动的是无序部分,而<a href="/posts/3518881f/#直接插入排序">直接插入排序</a>移动的是有序部分</li><li>直接与无序部分的第一个元素交换,这比移动元素要高效,但是因为跳跃性地移动元素,会导致算法<code>不稳定</code></li></ol><blockquote><p>关于排序算法稳定性: 算法不稳定是指本来序列中关键字相同的元素,在排序之后顺序发生了改变</p></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SelectSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;  <span class="hljs-comment">// 开始时没有序部分</span><br>        <span class="hljs-keyword">int</span> minIdx = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIdx]) &#123;<br>                minIdx = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (minIdx != i) &#123;<br>            <span class="hljs-keyword">int</span> tmp = arr[i];<br>            arr[i] = arr[minIdx];<br>            arr[minIdx] = tmp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="起泡排序"><a href="#起泡排序" class="headerlink" title="起泡排序"></a>起泡排序</h2><h3 id="主要思想-2"><a href="#主要思想-2" class="headerlink" title="主要思想"></a>主要思想</h3><p>将数组扫描<code>n</code>遍,一边扫描一边将不符合顺序的相邻两个元素交换,每遍扫描最后都会将无序部分的最大值交换到无序部分的最后面,也就是前部分无序,后部分有序.</p><p>如果一边扫描中没有发生交换,则表明所有关键字都按照顺序排好了,可以提前结束.</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 这一遍扫描是否发生了交换</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n - i - <span class="hljs-number">1</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">int</span> tmp = arr[j];<br>                arr[j] = arr[j + <span class="hljs-number">1</span>];<br>                arr[j + <span class="hljs-number">1</span>] = tmp;<br>                flag = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!flag) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><h2 id="主要思想-3"><a href="#主要思想-3" class="headerlink" title="主要思想"></a>主要思想</h2><p><code>希尔排序</code>也叫<code>缩小增量排序</code>,是对<a href="/posts/3518881f/#直接插入排序">直接插入排序</a>的改进，主要是针对<a href="/posts/3518881f/#直接插入排序">直接插入排序</a>的两个缺点进行改进。</p><ol><li>当<code>n</code>值很大时,由于要移动元素,复杂度很高</li><li>元素无序时复杂度最高</li></ol><p><code>希尔排序</code>就是通过一定的<code>增量</code>,将原序列划分为小序列，先对小序列进行<a href="/posts/3518881f/#直接插入排序">直接插入排序</a>，然后逐步减小<code>增量</code>，继续<a href="/posts/3518881f/#直接插入排序">直接插入排序</a>.到最后<code>增量</code>为<code>1</code>时，序列已经基本有序，再进行<a href="/posts/3518881f/#直接插入排序">直接插入排序</a>，复杂度会低很多。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><p>就是在<a href="/posts/3518881f/#直接插入排序">直接插入排序</a>外面套了一层增量循环，并将原来所有的<code>1</code>都换成了增量<code>gap</code>(<code>j--</code>也要换成<code>j-=gap</code>)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShellSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> gap = (n &gt;&gt; <span class="hljs-number">1</span>); gap &gt; <span class="hljs-number">0</span>; gap &gt;&gt;= <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 初始增量为n/2,之后逐渐减半</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = gap; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] &lt; arr[i - gap]) &#123;<br>                <span class="hljs-keyword">int</span> tmp = arr[i], j;<br>                <span class="hljs-keyword">for</span> (j = i - gap; j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; tmp; j -= gap) &#123;<br>                    arr[j + gap] = arr[j];<br>                &#125;<br>                arr[j + gap] = tmp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="主要思想-4"><a href="#主要思想-4" class="headerlink" title="主要思想"></a>主要思想</h2><p><code>快速排序</code>可以看成是对<a href="/posts/3518881f/#起泡排序">起泡排序</a>的改进。</p><p><a href="/posts/3518881f/#起泡排序">起泡排序</a>每趟遍历都会使无序部分的最值被移动到正确位置，也就是最后面，从而加入有序部分，于是无序部分长度减一，所以<a href="/posts/3518881f/#起泡排序">起泡排序</a>中无序部分的减少是<code>线性</code>的。而<code>快速排序</code>是将一个<code>中等大小</code>的元素放到正确位置，然后用<code>分治</code>的思想，分别对这个<code>中等大小</code>的元素的前面和后面部分进行排序。而这个<code>中等大小</code>的元素被称为<code>枢轴(pivot)</code>。</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>        <span class="hljs-keyword">int</span> pivot = arr[low];<br>        <span class="hljs-keyword">int</span> i = low, j = high;<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= pivot) j--;<br>            <span class="hljs-keyword">if</span> (i &lt; j) &#123;<br>                arr[i++] = arr[j];<br>            &#125;<br>            <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt; pivot) i++;<br>            <span class="hljs-keyword">if</span> (i &lt; j) &#123;<br>                arr[j--] = arr[i];<br>            &#125;<br>        &#125;<br>        arr[i] = pivot;<br>        QuickSort(arr, low, i - <span class="hljs-number">1</span>);<br>        QuickSort(arr, i + <span class="hljs-number">1</span>, high);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>在序列基本有序时（比如这个正好按照递减的顺序），如果快速排序中的枢轴还是取当前序列的第一个，则最后这个枢轴会和<code>起泡排序</code>一样被放到序列的一端，也就是说这时的<code>快速排序</code>蜕化为了<code>起泡排序</code>！</p><p>为了解决这个问题，只需要选择中等大小的枢轴就行了，比较简单的做法是在序列第一个元素、中间元素和最后一个元素之中选择中等大小的。为了使代码不变，可以将这个中等大小的元素与序列第一个元素进行交换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">inline</span> <span class="hljs-title">Swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; a, <span class="hljs-keyword">int</span>&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> t = a;<br>    a = b;<br>    b = t;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>        <span class="hljs-keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="hljs-number">1</span>);  <span class="hljs-comment">// low+high可能会溢出</span><br>        <span class="hljs-keyword">if</span> (mid != low) &#123;<br>            <span class="hljs-keyword">if</span> (arr[low] &gt; arr[mid] &amp;&amp; arr[low] &gt; arr[high]) &#123;      <span class="hljs-comment">// arr[low]在三者中最大</span><br>                Swap(arr[low], arr[mid] &gt; arr[high] ? arr[mid] : arr[high]);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[low] &lt; arr[mid] &amp;&amp; arr[low] &lt; arr[high]) &#123; <span class="hljs-comment">// arr[low]在三者中最小</span><br>                Swap(arr[low], arr[mid] &lt; arr[high] ? arr[mid] : arr[high]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> pivot = arr[low];<br>        <span class="hljs-keyword">int</span> i = low, j = high;<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= pivot) j--;<br>            <span class="hljs-keyword">if</span> (i &lt; j) &#123;<br>                arr[i++] = arr[j];<br>            &#125;<br>            <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt; pivot) i++;<br>            <span class="hljs-keyword">if</span> (i &lt; j) &#123;<br>                arr[j--] = arr[i];<br>            &#125;<br>        &#125;<br>        arr[i] = pivot;<br>        QuickSort(arr, low, i - <span class="hljs-number">1</span>);<br>        QuickSort(arr, i + <span class="hljs-number">1</span>, high);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="主要思想-5"><a href="#主要思想-5" class="headerlink" title="主要思想"></a>主要思想</h2><p>在前面的<a href="/posts/3518881f/#简单选择排序">简单选择排序</a>中，每次都要通过遍历无序部分来查找最值，效率比较低，而<code>堆排序</code>就是针对这个找最值的过程进行优化，用到的数据结构是<code>堆</code>。这里的<code>堆</code>实际是一个用数组存储的<code>完全二叉树</code>。</p><p><code>完全二叉树</code>的性质：</p><ol><li>数组下标从<code>0</code>开始时，<code>完全二叉树</code>的一个结点<code>i</code>的左孩子的下标是<code>2i+1</code>（如果有左孩子），右孩子的下标是<code>2i+2</code>（如果有右孩子）。</li><li>完全二叉树的最后一个<code>非叶子结点</code>的下标为<code>n/2-1</code>（<code>n/2</code>向下去取整）。</li></ol><p>堆的每个结点的关键字都不小于其孩子节点称为<code>大顶堆</code>，堆的每个结点的关键字都不大于其孩子结点则称为<code>小顶堆</code>。</p><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// &lt;summary&gt;</span><br><span class="hljs-comment">/// 从上向下调整大顶堆</span><br><span class="hljs-comment">/// &lt;/summary&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;arr&quot;&gt;存储堆（完全二叉树）的数组&lt;/param&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;low&quot;&gt;数组起始（树根）下标&lt;/param&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;high&quot;&gt;数组结束（最后一个叶子）下标&lt;/param&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Shift</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = low, j = (i &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>; <span class="hljs-comment">// i为父结点，j为左孩子</span><br>    <span class="hljs-keyword">int</span> tmp = arr[i];        <span class="hljs-comment">// 暂存父节点的值</span><br>    <span class="hljs-keyword">while</span> (j &lt;= high) &#123;      <span class="hljs-comment">// i有左孩子j</span><br>        <span class="hljs-keyword">if</span> (j &lt; high &amp;&amp; arr[j] &lt; arr[j + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// i有右孩子并且右孩子更大</span><br>            j++;             <span class="hljs-comment">// 让j指向更大的右孩子</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (tmp &lt; arr[j]) &#123;  <span class="hljs-comment">// 暂存的父节点值小于最大的孩子，需要继续向下（子树）寻找</span><br>            arr[i] = arr[j]; <span class="hljs-comment">// 当前父节点放大孩子</span><br>            i = j;           <span class="hljs-comment">// 并且i和j进入子树，继续尝试找暂存的父节点正确的位置</span><br>            j = (i &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<span class="hljs-comment">// j是子树的左孩子</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 暂存的父节点值可以放在当前父节点</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    arr[i] = tmp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HeapSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 建堆</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123; <span class="hljs-comment">// 从最后一个非叶子结点开始调整子树</span><br>        Shift(arr, i, n - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 选择排序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123; <span class="hljs-comment">// 前部分无序(0~i)，后部分有序(i+1~n-1)</span><br>        Swap(arr[<span class="hljs-number">0</span>], arr[i]);  <span class="hljs-comment">// 从无序部分选择最大的放到后面(i)</span><br>        Shift(arr, <span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>);  <span class="hljs-comment">// 调整剩余无序部分(0~i-1)的大顶堆</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>另一种比较容易理解的调整函数为<code>下沉(Sink)</code>，通过递归进行处理，效率稍微差一些。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Sink</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> leftChild = (low &gt;&gt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> rightChild = leftChild + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> present = low;<br>    <span class="hljs-keyword">if</span> (leftChild &lt;= high &amp;&amp; arr[leftChild] &gt; arr[present]) &#123;  <span class="hljs-comment">// 有左孩子且左孩子大</span><br>        present = leftChild;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (rightChild &lt;= high &amp;&amp; arr[rightChild] &gt; arr[present]) &#123;<span class="hljs-comment">// 有右孩子且右孩子大</span><br>        present = rightChild;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (present != low) &#123;<br>        Swap(arr[low], arr[present]);<span class="hljs-comment">// 父与较大的孩子换</span><br>        Sink(arr, present, high);    <span class="hljs-comment">// 递归处理子树</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="主要思想-6"><a href="#主要思想-6" class="headerlink" title="主要思想"></a>主要思想</h2><p>归并排序就是纯粹的<code>分治思想</code>，先递归地将前半部分序列和后半部分序列排好，然后合并这两个序列就能完成整个序列的排序。</p><p>如果是<code>自底向上</code>（也就是递归到最后不可再分时）来看，归并排序是将初始的<code>n</code>个元素看成是<code>n</code>个有序的子序列，然后两两归并为有序序列，最后归并为一整个长为<code>n</code>的有序序列。</p><h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> tmp[], <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = low; i &lt;= high; i++) &#123;<br>        tmp[i] = arr[i];<br>    &#125;<br>    <span class="hljs-keyword">int</span> i = low, left = low, right = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= mid &amp;&amp; right &lt;= high) &#123;<br>        arr[i++] = tmp[left] &lt; tmp[right] ? tmp[left++] : tmp[right++];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (left &lt;= mid) &#123;<br>        arr[i++] = tmp[left++];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (right &lt;= high) &#123;<br>        arr[i++] = tmp[right++];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> tmp[], <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>        <span class="hljs-keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="hljs-number">1</span>); <br>        MergeSort(arr, tmp, low, mid);      <span class="hljs-comment">// 排左半部分</span><br>        MergeSort(arr, tmp, mid + <span class="hljs-number">1</span>, high); <span class="hljs-comment">// 排右半部分</span><br>        Merge(arr, tmp, low, mid, high);    <span class="hljs-comment">// 合并</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span>* <span class="hljs-keyword">const</span> tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>    MergeSort(arr, tmp, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">delete</span>[] tmp;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h2><p>如果用<code>自底向上</code>的方法，可以将<code>归并排序</code>改成迭代版本的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span>* tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> gap = <span class="hljs-number">1</span>; gap &lt; n; gap &lt;&lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>; low &lt; n; low += (gap &lt;&lt; <span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-keyword">int</span> high = low + (gap &lt;&lt; <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">int</span> mid = (low + high) &gt;&gt; <span class="hljs-number">1</span>;<br>            Merge(arr, tmp, low, mid &gt;= n ? n - <span class="hljs-number">1</span> : mid, high &gt;= n ? n - <span class="hljs-number">1</span> : high);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] tmp;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重建二叉树 &amp; 二叉树的下一个结点</title>
      <link href="posts/1043790f/"/>
      <url>posts/1043790f/</url>
      
        <content type="html"><![CDATA[<h1 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h1><p>题目：<a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tab=answerKey">牛客网</a></p><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>解题思路见之前的文章<a href="/posts/24bbeb69/#先序-中序">由遍历序列确定二叉树</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for binary tree</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">reConstructBinaryTree</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; pre,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vin)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> CreateTree(pre, vin, <span class="hljs-number">0</span>, pre.size()<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, vin.size()<span class="hljs-number">-1</span>);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">CreateTree</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; pre, <span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; vin, <span class="hljs-keyword">int</span> L1, <span class="hljs-keyword">int</span> R1, <span class="hljs-keyword">int</span> L2, <span class="hljs-keyword">int</span> R2)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(L1 &gt; R1)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> s = <span class="hljs-keyword">new</span> TreeNode(pre[L1]);<br>        <span class="hljs-keyword">int</span> k;<br>        <span class="hljs-keyword">for</span>(k = L2; k &lt;= R2; k++)&#123;<br>            <span class="hljs-keyword">if</span>(vin[k] == pre[L1])&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        s-&gt;left = CreateTree(pre, vin, L1+<span class="hljs-number">1</span>, L1+k-L2, L2, k<span class="hljs-number">-1</span>);<br>        s-&gt;right = CreateTree(pre, vin, L1+k-L2+<span class="hljs-number">1</span>, R1, k+<span class="hljs-number">1</span>, R2);<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二叉树的下一个结点"><a href="#二叉树的下一个结点" class="headerlink" title="二叉树的下一个结点"></a>二叉树的下一个结点</h1><p>题目：<a href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&amp;tqId=11210&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&amp;from=cyc_github&amp;tab=answerKey">牛客网</a></p><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p><p>其中的<a href="https://blog.nowcoder.net/n/954373f213e14eeab0a69ed0e9ef1b6e"><code>TreeLinkNode</code>的定义</a></p><blockquote><p>题目意思就是给定的树节点中<code>next</code>已经指向了父节点，现在要求出中序遍历这整棵树时，这个结点的下一个结点。</p></blockquote><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>分三种情况</p><ol><li>结点空，返回空</li><li>不空，但有右子树，则向右下移动一步，然后一直向左下移动（左子树），即找右子树的最左下子树</li><li>不空，无右子树，但有父结点（根据题意，<code>next</code>所指不空），如果此节点是父节点的左子树，则返回双亲，否则再向上找父节点的父节点，重复这个判断。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeLinkNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct TreeLinkNode *left;</span><br><span class="hljs-comment">    struct TreeLinkNode *right;</span><br><span class="hljs-comment">    struct TreeLinkNode *next;</span><br><span class="hljs-comment">    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) &#123;</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeLinkNode* <span class="hljs-title">GetNext</span><span class="hljs-params">(TreeLinkNode* pNode)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(!pNode)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(pNode-&gt;right)&#123;<br>            pNode = pNode-&gt;right;<br>            <span class="hljs-keyword">while</span>(pNode-&gt;left)&#123;<br>                pNode = pNode-&gt;left;<br>            &#125;<br>            <span class="hljs-keyword">return</span> pNode;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(pNode-&gt;next)&#123;<br>            <span class="hljs-keyword">auto</span> parent = pNode-&gt;next;<br>            <span class="hljs-keyword">if</span>(parent-&gt;left == pNode)&#123;<br>                <span class="hljs-keyword">return</span> parent;<br>            &#125;<br>            pNode = parent;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图的最短路径</title>
      <link href="posts/f185c229/"/>
      <url>posts/f185c229/</url>
      
        <content type="html"><![CDATA[<h1 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h1><h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><p><code>Dijkstra</code>算法用于计算图中一点到其它点的最短路径。</p><p>每次从剩余顶点中找到离源点最近的点，将这个点加入已确定最短路径的点集，然后更新其他未确定最短路径并且与这个点相邻的点到源点的最短距离。</p><h3 id="与Prim算法比较"><a href="#与Prim算法比较" class="headerlink" title="与Prim算法比较"></a>与Prim算法比较</h3><p>相同点：</p><ul><li>计算过程类似于<a href="/posts/edf913d3/#Prim">Prim算法</a>，都是从一个顶点开始，逐步向外扩展。</li></ul><p>不同点：</p><ul><li><a href="/posts/edf913d3/#Prim">Prim算法</a>是根据剩余顶点<code>与生成树之间的距离最小</code>来选取下一个点，而<code>Dijkstra</code>算法是根据剩余顶点<code>与源点之间的距离最小</code>。</li><li><a href="/posts/edf913d3/#Prim">Prim算法</a>每次加入一点后就对所有剩余的点进行更新，而<code>Dijkstra</code>算法只对未确定最短路并且<code>与刚刚确定的点相邻的点</code>进行更新。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/// &lt;summary&gt;</span><br><span class="hljs-comment">/// 用Dijkstra算法确定源点到其余点的最短路径</span><br><span class="hljs-comment">/// &lt;/summary&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;n&quot;&gt;图的顶点数&lt;/param&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;M&quot;&gt;图的邻接矩阵&lt;/param&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;v0&quot;&gt;源点&lt;/param&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;dist&quot;&gt;各点到源点的最短距离&lt;/param&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;path&quot;&gt;最短路径上的一点&lt;/param&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">float</span>** M, <span class="hljs-keyword">int</span> v0, <span class="hljs-keyword">float</span> dist[], <span class="hljs-keyword">int</span> path[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">bool</span>* <span class="hljs-built_in">set</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">bool</span>[n];  <span class="hljs-comment">// 是否以确定最短路径</span><br>    <span class="hljs-keyword">int</span> v;                    <span class="hljs-comment">// 当前确定最短路径的点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        dist[i] = M[v0][i];<br>        <span class="hljs-built_in">set</span>[i] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (M[v0][i] &lt; INF) &#123;<br>            path[i] = v0;     <span class="hljs-comment">// 直接与v0相邻，初始路径上一点就是v0</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            path[i] = <span class="hljs-number">-1</span>;     <span class="hljs-comment">// （暂时）无路径</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">set</span>[v0] = <span class="hljs-literal">true</span>;<br>    path[v0] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;  <span class="hljs-comment">// 逐个确定剩余的n-1个点</span><br>        <span class="hljs-keyword">float</span> min = INF;                 <span class="hljs-comment">// 剩余点到源点的最小距离</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">set</span>[i] &amp;&amp; dist[j] &lt; min) &#123;<br>                v = j;<br>                min = dist[j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">set</span>[v] = <span class="hljs-literal">true</span>;                  <span class="hljs-comment">// 确定最短路径</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;                     <span class="hljs-comment">// 更新剩余点到源点的最短距离</span><br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">set</span>[j] &amp;&amp; dist[v] + M[v][j] &lt; dist[j]) &#123; <span class="hljs-comment">// 通过刚刚确定的点v可以减少到源点的距离</span><br>                dist[j] = dist[v] + M[v][j];<br>                path[j] = v;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="输出路径"><a href="#输出路径" class="headerlink" title="输出路径"></a>输出路径</h3><p>最后得到的<code>path[v]</code>保存的是v到源点的最短路径上的前一点<code>u</code>，比如：</p><div class="mermaid">graph LRv0((v0)) --&gt; other((...)) --&gt; u((u)) --&gt; v((v))</div><p><em>对于源点v0，有<code>path[v0]=-1</code></em></p><p>于是通过这个<code>path[]</code>数组就可以递归地得到最短路径上的所有点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintPath</span><span class="hljs-params">(<span class="hljs-keyword">int</span> path[], <span class="hljs-keyword">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (path[v] == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, v);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        PrintPath(path, path[v]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&gt; %d &quot;</span>, v);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h1><h2 id="主要思想-1"><a href="#主要思想-1" class="headerlink" title="主要思想"></a>主要思想</h2><p><code>Floyd</code>算法用于计算图中所有点对之间的最短路径。</p><p>对于每个点<code>v</code>，尝试加入到所有点对<code>(i, j)</code>之间的路径上。如果从<code>i</code>到<code>j</code>的路径上加入顶点<code>v</code>之后路径变短，也就是 $A[i][v] + A[v][j] &lt; A[i][j]$，其中<code>A[][]</code>数组保存的是当前所有点对之间最短路径的长度。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Floyd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">float</span>** M, <span class="hljs-keyword">int</span>** path)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; A(n, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            A[i][j] = M[i][j];<br>            path[i][j] = <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 没有中间点（直接相连）</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt; n; v++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (A[i][v] + A[v][j] &lt; A[i][j]) &#123;<br>                    A[i][j] = A[i][v] + A[v][j];<br>                    path[i][j] = v;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="输出路径-1"><a href="#输出路径-1" class="headerlink" title="输出路径"></a>输出路径</h3><p>最后得到的<code>path[][]</code>保存的是点对之间路径上的一点，类似<code>Dijkstra</code>算法得到的结果，可以递归输出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintPath</span><span class="hljs-params">(<span class="hljs-keyword">int</span>** path, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (path[u][v] == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d -&gt; %d &quot;</span>,  u, v);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">int</span> mid = path[u][v];<br>        PrintPath(path, n, u, mid);<br>        PrintPath(path, n, mid, v);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图的最小生成树</title>
      <link href="posts/edf913d3/"/>
      <url>posts/edf913d3/</url>
      
        <content type="html"><![CDATA[<h1 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h1><h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><p>从一个源点开始生长，每次从剩余的点中找到<code>离生成树最近的点</code>，加入生成树后更新剩下点到生成树的最小距离。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 10000</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d -&gt; %d\n&quot;</span>, u, v);<br>&#125;<br><br><span class="hljs-comment">/// &lt;summary&gt;</span><br><span class="hljs-comment">/// 用Prim算法计算图的最小生成树权值</span><br><span class="hljs-comment">/// &lt;/summary&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;n&quot;&gt;图中点的个数&lt;/param&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;M&quot;&gt;图的权值矩阵（邻接矩阵）&lt;/param&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;v0&quot;&gt;起始点&lt;/param&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;sum&quot;&gt;最小生成树的权值和&lt;/param&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Prim</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">float</span>** M, <span class="hljs-keyword">int</span> v0, <span class="hljs-keyword">float</span>&amp; sum)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">float</span>* lowCost = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[n];  <span class="hljs-comment">// 到生成树的最小距离</span><br>    <span class="hljs-keyword">int</span>* lowVex = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];       <span class="hljs-comment">// 对应最小距离路径上的前一个点</span><br>    <span class="hljs-keyword">bool</span>* <span class="hljs-built_in">set</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">bool</span>[n];        <span class="hljs-comment">// 是否已加入生成树</span><br>    <span class="hljs-keyword">int</span> v;                          <span class="hljs-comment">// 当前加入最小生成树的点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">set</span>[i] = <span class="hljs-literal">false</span>;             <span class="hljs-comment">// 不在生成树中</span><br>        lowCost[i] = M[v0][i];      <span class="hljs-comment">// 初始化为到v0的权</span><br>        lowVex[i] = v0;             <span class="hljs-comment">// 生成树中只有v0</span><br>    &#125;<br>    v = v0;   <span class="hljs-comment">// 加入源点</span><br>    <span class="hljs-built_in">set</span>[v] = <span class="hljs-literal">true</span>;<br>    sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;  <span class="hljs-comment">// 逐个加入剩余的n-1个点</span><br>        <span class="hljs-keyword">float</span> min = INF;  <span class="hljs-comment">// 剩余点到生成树的最小距离</span><br>        <span class="hljs-keyword">int</span> k;            <span class="hljs-comment">// 最小距离对应的点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">set</span>[j] &amp;&amp; M[v][j] &lt; lowCost[j]) &#123;<br>                min = lowCost[j];<br>                k = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">set</span>[k] = <span class="hljs-literal">true</span>;       <span class="hljs-comment">// 加入生成树</span><br>        v = k;<br>        Print(lowVex[v], v); <span class="hljs-comment">// 输出加入的边</span><br>        sum += min;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;               <span class="hljs-comment">// 更新剩余点到生成树的最小距离</span><br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">set</span>[j] &amp;&amp; M[v][j] &lt; lowCost[j]) &#123;  <span class="hljs-comment">// 通过刚刚加入生成树的v可以减少到生成树的距离</span><br>                lowCost[j] = M[v][j];<br>                lowVex[j] = v;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h1><h2 id="主要思想-1"><a href="#主要思想-1" class="headerlink" title="主要思想"></a>主要思想</h2><p>每次都从图中找到一条<code>权值最小的边</code>，如果这条边加入生成树后<code>不会产生环</code>则加入，否则尝试次一等的边。</p><h3 id="判断是否会产生环"><a href="#判断是否会产生环" class="headerlink" title="判断是否会产生环"></a>判断是否会产生环</h3><ul><li>可以联想到在同一棵树上的任意两个点之间连线都会造成环，而<code>Kruskal</code>算法进行的过程中不是像<code>Prim</code>算法一样只有一颗树在生长，而是有<code>多棵树</code>（<code>单独一个点也是树</code>）。</li><li><p>连接不同树上的点不会造成环，因此只需要判断当前选择的边的两个顶点是否属于同一棵树就可以知道是否会产生环。</p></li><li><p>判断是否属于同一棵树可以通过判断所在树的树根是否相同来实现，所以一整棵树都可以用树根来代表。进而这整棵树都可以看成是由树根代表的<code>集合</code>。</p></li><li>判断是否属于同一个集合可以用<code>并查集</code>实现。这里的并查集实际上就是一个数组<code>parent</code>，记录了结点的双亲。通过双亲向上回溯，最后当<code>parent[i]==i</code>时，就表示树根为<code>i</code>。</li></ul><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> &#123;</span><br>    <span class="hljs-keyword">int</span> a, b;  <span class="hljs-comment">// 边的两个顶点</span><br>    <span class="hljs-keyword">int</span> w;     <span class="hljs-comment">// 边的权值</span><br>&#125;Edge;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Sort</span><span class="hljs-params">(Edge edges[], <span class="hljs-keyword">int</span> e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">std</span>::sort(edges, edges + e, [](<span class="hljs-keyword">const</span> Edge&amp; e1, <span class="hljs-keyword">const</span> Edge&amp; e2) &#123; <span class="hljs-keyword">return</span> e1.w &lt; e2.w; &#125;);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetRoot</span><span class="hljs-params">(<span class="hljs-keyword">int</span> parent[], <span class="hljs-keyword">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (i != parent[i]) &#123;<br>        i = parent[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><br><span class="hljs-comment">/// &lt;summary&gt;</span><br><span class="hljs-comment">/// 用Kruskal算法计算最小生成树的权值和</span><br><span class="hljs-comment">/// &lt;/summary&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;edges&quot;&gt;图的所有边&lt;/param&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;n&quot;&gt;图的顶点数&lt;/param&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;e&quot;&gt;图的边数&lt;/param&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;sum&quot;&gt;最小生成树的权值和&lt;/param&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Kruskal</span><span class="hljs-params">(Edge edges[], <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> e, <span class="hljs-keyword">int</span>&amp; sum)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b;<br>    <span class="hljs-keyword">int</span>* parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>    sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        parent[i] = i;  <span class="hljs-comment">// 只有一个结点，自己就是树根</span><br>    &#125;<br>    Sort(edges, e);     <span class="hljs-comment">// 将所有边按找权值递增排序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; e; i++) &#123;<br>        a = GetRoot(parent, edges[i].a); <span class="hljs-comment">// a所在的树根</span><br>        b = GetRoot(parent, edges[i].b); <span class="hljs-comment">// b所在的树根</span><br>        <span class="hljs-keyword">if</span> (a != b) &#123;<br>            parent[a] = b;  <span class="hljs-comment">// 把树a挂到b上，作为b的子树</span><br>            sum += edges[i].w;<br>            Print(edges[i].a, edges[i].b);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>由遍历序列确定二叉树</title>
      <link href="posts/24bbeb69/"/>
      <url>posts/24bbeb69/</url>
      
        <content type="html"><![CDATA[<h1 id="先序-中序"><a href="#先序-中序" class="headerlink" title="先序+中序"></a>先序+中序</h1><h2 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h2><p>先在先序序列中找树根，也就是第一个元素，然后在中序序列中找到这个元素，进而确定左右子树，也就是此元素左边和右边的。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>先序：<code>A B D E C F G H</code></p><p>后序：<code>D B E A C G F H</code></p><p>在先序中找到树根<code>A</code>，在后序中确定其左子树包含<code>D B E</code>，右子树包含<code>C G F H</code>，然后递归进行这个过程。</p><p>确定二叉树为：</p><div class="mermaid">graph TDA((A)) &#x3D;&#x3D;&#x3D; B((B)) A &#x3D;&#x3D;&#x3D; C((C))B &#x3D;&#x3D;&#x3D; D((D))B &#x3D;&#x3D;&#x3D; E((E))C -.- t(( ))C &#x3D;&#x3D;&#x3D; F((F))F &#x3D;&#x3D;&#x3D; G((G))F &#x3D;&#x3D;&#x3D; H((H))</div><p><em>注：C并没有左孩子结点，图中的虚线连接的结点只是用来占位的</em></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/// &lt;summary&gt;</span><br><span class="hljs-comment">/// 二叉树结点</span><br><span class="hljs-comment">/// &lt;/summary&gt;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BTNode</span>&#123;</span><br>    <span class="hljs-keyword">char</span> data;<br>    BTNode* lchild;<br>    BTNode* rchild;<br>&#125;BTNode;<br><br><span class="hljs-comment">/// &lt;summary&gt;</span><br><span class="hljs-comment">/// 数组查找</span><br><span class="hljs-comment">/// &lt;/summary&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;arr&quot;&gt;待查找数组&lt;/param&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;L&quot;&gt;数组开始下标&lt;/param&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;R&quot;&gt;数组结束下标&lt;/param&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;target&quot;&gt;目标元素&lt;/param&gt;</span><br><span class="hljs-comment">/// &lt;returns&gt;数组下标&lt;/returns&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Search</span><span class="hljs-params">(<span class="hljs-keyword">char</span> arr[], <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">char</span> target)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = L; i &lt;= R; i++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[i] == target) &#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">/// &lt;summary&gt;</span><br><span class="hljs-comment">/// 根据前序和中序遍历序列确定二叉树</span><br><span class="hljs-comment">/// &lt;/summary&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;pre&quot;&gt;前序遍历序列&lt;/param&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;in&quot;&gt;中序遍历序列&lt;/param&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;L1&quot;&gt;前序序列开始下标&lt;/param&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;R1&quot;&gt;前序序列结束下标&lt;/param&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;L2&quot;&gt;中序序列开始下标&lt;/param&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;R2&quot;&gt;中序序列结束下标&lt;/param&gt;</span><br><span class="hljs-comment">/// &lt;returns&gt;二叉树根&lt;/returns&gt;</span><br><span class="hljs-function">BTNode* <span class="hljs-title">CreateBT1</span><span class="hljs-params">(<span class="hljs-keyword">char</span> pre[], <span class="hljs-keyword">char</span> in[], <span class="hljs-keyword">int</span> L1, <span class="hljs-keyword">int</span> R1, <span class="hljs-keyword">int</span> L2, <span class="hljs-keyword">int</span> R2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (L1 &gt; R1) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    BTNode* s = <span class="hljs-keyword">new</span> BTNode();<br>    s-&gt;lchild = s-&gt;rchild = <span class="hljs-literal">nullptr</span>;<br>    s-&gt;data = pre[L1];  <span class="hljs-comment">// 根</span><br>    <span class="hljs-keyword">int</span> i = Search(in, L2, R2, pre[L1]); <span class="hljs-comment">// 根在中序里的下标</span><br>    s-&gt;lchild = CreateBT1(pre, in, L1 + <span class="hljs-number">1</span>, L1 + i - L2, L2, i - <span class="hljs-number">1</span>); <span class="hljs-comment">// 递归创建左子树</span><br>    s-&gt;rchild = CreateBT1(pre, in, L1 + i - L2 + <span class="hljs-number">1</span>, R1, i + <span class="hljs-number">1</span>, R2); <span class="hljs-comment">// 递归创建右子树</span><br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="后序-中序"><a href="#后序-中序" class="headerlink" title="后序+中序"></a>后序+中序</h1><h2 id="主要思路-1"><a href="#主要思路-1" class="headerlink" title="主要思路"></a>主要思路</h2><p>先在后序序列中找树根，也就是最后一个元素，然后在中序序列中找到这个元素，进而确定左右子树，也就是此元素左边和右边的。</p><h2 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h2><p>后序：<code>D E B G H F C A</code></p><p>中序：<code>D B E A C G F H</code></p><p>在后序中找到树根<code>A</code>，在中序里确定其左子树包含<code>D B E</code>，右子树包含<code>C G F H</code>，之后递归进行这个过程。</p><p>确定二叉树为：</p><div class="mermaid">graph TDA((A)) &#x3D;&#x3D;&#x3D; B((B)) A &#x3D;&#x3D;&#x3D; C((C))B &#x3D;&#x3D;&#x3D; D((D))B &#x3D;&#x3D;&#x3D; E((E))C -.- t(( ))C &#x3D;&#x3D;&#x3D; F((F))F &#x3D;&#x3D;&#x3D; G((G))F &#x3D;&#x3D;&#x3D; H((H))</div><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// &lt;summary&gt;</span><br><span class="hljs-comment">/// 根据后序和中序遍历序列确定二叉树</span><br><span class="hljs-comment">/// &lt;/summary&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;last&quot;&gt;后序遍历序列&lt;/param&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;in&quot;&gt;中序遍历序列&lt;/param&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;L1&quot;&gt;后序序列开始下标&lt;/param&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;R1&quot;&gt;后序序列结束下标&lt;/param&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;L2&quot;&gt;中序序列开始下标&lt;/param&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;R2&quot;&gt;中序序列结束下标&lt;/param&gt;</span><br><span class="hljs-comment">/// &lt;returns&gt;二叉树根&lt;/returns&gt;</span><br><span class="hljs-function">BTNode* <span class="hljs-title">CreateBT2</span><span class="hljs-params">(<span class="hljs-keyword">char</span> post[], <span class="hljs-keyword">char</span> in[], <span class="hljs-keyword">int</span> L1, <span class="hljs-keyword">int</span> R1, <span class="hljs-keyword">int</span> L2, <span class="hljs-keyword">int</span> R2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (L1 &gt; R1) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    BTNode* s = <span class="hljs-keyword">new</span> BTNode();<br>    s-&gt;lchild = s-&gt;rchild = <span class="hljs-literal">nullptr</span>;<br>    s-&gt;data = post[R1];  <span class="hljs-comment">// 根</span><br>    <span class="hljs-keyword">int</span> i = Search(in, L2, R2, post[R1]);  <span class="hljs-comment">// 根在中序里的下标</span><br>    s-&gt;lchild = CreateBT2(post, in, L1, L1 + i - L2 - <span class="hljs-number">1</span>, L2, i - <span class="hljs-number">1</span>); <span class="hljs-comment">// 递归创建左子树</span><br>    s-&gt;rchild = CreateBT2(post, in, L1 + i - L2, R1 - <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>, R2); <span class="hljs-comment">// 递归创建右子树</span><br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="层序-中序"><a href="#层序-中序" class="headerlink" title="层序+中序"></a>层序+中序</h1><h2 id="主要思路-2"><a href="#主要思路-2" class="headerlink" title="主要思路"></a>主要思路</h2><p>先在层序序列中找到树根，也就是第一个，然后在中序序列中找到这个元素，然后可以确定在中序序列中的左右子树，也就是这个元素的左边和右边的。但是在层序中，这个元素的左右子树并不是连续分布的，准确来说，在层序中会穿插左子树和右子树的元素。</p><h2 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h2><p>层序：<code>A B C D E F G H</code></p><p>中序：<code>D B E A C G F H</code></p><p>在层序中找到树根<code>A</code>，在中序里确定其左子树包含<code>D B E</code>，右子树包含<code>C G F H</code>。但是在层序中，左子树的<code>D B E</code>里穿插了<code>C</code>，右子树的<code>C G F H</code>穿插了<code>D</code>和<code>E</code>，总之不能像之前一样设置数组的<code>L</code>和<code>R</code>就直接进入下一步递归。这里需要将左右子树对应层序中的元素分别提取出来，作为<code>子层序序列</code>，然后进入下一步递归。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// &lt;summary&gt;</span><br><span class="hljs-comment">/// 根据中序序列提取子层序序列</span><br><span class="hljs-comment">/// &lt;/summary&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;subLevel&quot;&gt;子层序序列&lt;/param&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;level&quot;&gt;原层序序列&lt;/param&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;in&quot;&gt;中序序列&lt;/param&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;n&quot;&gt;层序序列长&lt;/param&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;L&quot;&gt;中序序列开始下标&lt;/param&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;R&quot;&gt;中序序列结束下标&lt;/param&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GetSubLevel</span><span class="hljs-params">(<span class="hljs-keyword">char</span> subLevel[], <span class="hljs-keyword">char</span> level[], <span class="hljs-keyword">char</span> in[], <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (Search(in, L, R, level[i]) != <span class="hljs-number">-1</span>) &#123;<br>            subLevel[k++] = level[i];<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/// &lt;summary&gt;</span><br><span class="hljs-comment">/// 根据层序和中序遍历序列确定二叉树</span><br><span class="hljs-comment">/// &lt;/summary&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;level&quot;&gt;层序遍历序列&lt;/param&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;in&quot;&gt;中序遍历序列&lt;/param&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;n&quot;&gt;层序序列长度&lt;/param&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;L&quot;&gt;中序序列开始下标&lt;/param&gt;</span><br><span class="hljs-comment">/// &lt;param name=&quot;R&quot;&gt;中序序列结束下标&lt;/param&gt;</span><br><span class="hljs-comment">/// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="hljs-function">BTNode* <span class="hljs-title">CreateBT3</span><span class="hljs-params">(<span class="hljs-keyword">char</span> level[], <span class="hljs-keyword">char</span> in[], <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (L &gt; R) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    BTNode* s = <span class="hljs-keyword">new</span> BTNode();<br>    s-&gt;lchild = s-&gt;rchild = <span class="hljs-literal">nullptr</span>;<br>    s-&gt;data = level[<span class="hljs-number">0</span>];  <span class="hljs-comment">// 根</span><br>    <span class="hljs-keyword">int</span> i = Search(in, L, R, level[<span class="hljs-number">0</span>]);  <span class="hljs-comment">// 根在中序里的下标</span><br>    <span class="hljs-keyword">int</span> LN = i - L, RN = R - i;  <span class="hljs-comment">// 左右子树元素个数</span><br>    <span class="hljs-keyword">char</span>* LLevel = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[LN]; <span class="hljs-comment">// 左子树对应的子层序序列</span><br>    <span class="hljs-keyword">char</span>* RLevel = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[RN]; <span class="hljs-comment">// 右子树对应的子层序序列</span><br>    GetSubLevel(LLevel, level, in, n, L, i - <span class="hljs-number">1</span>);<br>    GetSubLevel(RLevel, level, in, n, i + <span class="hljs-number">1</span>, R);<br>    s-&gt;lchild = CreateBT3(LLevel, in, LN, L, i - <span class="hljs-number">1</span>); <span class="hljs-comment">// 递归创建左子树</span><br>    s-&gt;rchild = CreateBT3(RLevel, in, RN, i + <span class="hljs-number">1</span>, R); <span class="hljs-comment">// 递归创建右子树</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复杂链表的复制 &amp; 两个链表的第一个公共节点</title>
      <link href="posts/d7b9fef9/"/>
      <url>posts/d7b9fef9/</url>
      
        <content type="html"><![CDATA[<h1 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h1><p>题目：<a href="https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&amp;tqId=11178&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&amp;from=cyc_github&amp;tab=answerKey">牛客网</a></p><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。</p><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>第一次遍历原链表，遍历时建立新链表，同时用无序字典<code>label2node</code>保存<code>label</code>与新链表中结点地址的映射关系（<code>RandomListNode</code>的<a href="https://blog.nowcoder.net/n/954373f213e14eeab0a69ed0e9ef1b6e">定义</a>中指明了<code>label</code>不会重复）。</p><p>第二次遍历原链表，如果原链表的某个结点<code>cur</code>有<code>random</code>指针，就为对应的新链表中的结点<code>label2node[cur-&gt;label]</code>设置<code>random</code>指针指向新链表中<code>label</code>对应的结点<code>label2node[cur-&gt;random-&gt;label]</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">RandomListNode* <span class="hljs-title">Clone</span><span class="hljs-params">(RandomListNode* pHead)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pHead == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, RandomListNode*&gt; label2node;<br>        <span class="hljs-keyword">auto</span> ans = <span class="hljs-keyword">new</span> RandomListNode(pHead-&gt;label), last = ans;<br>        label2node[ans-&gt;label] = ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> cur = pHead-&gt;next; cur; cur = cur-&gt;next)&#123;<br>            last-&gt;next = <span class="hljs-keyword">new</span> RandomListNode(cur-&gt;label);<br>            last = last-&gt;next;<br>            label2node[last-&gt;label] = last;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> cur = pHead; cur; cur = cur-&gt;next)&#123;<br>            <span class="hljs-keyword">if</span>(cur-&gt;random)&#123;<br>                label2node[cur-&gt;label]-&gt;random = label2node[cur-&gt;random-&gt;label];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>不用额外的空间存储<code>random</code>的映射关系，而是先将新链表的每个节点都插入到原链表的结点后面，这样新结点的<code>random</code>指针就是原结点（新节点前面）的<code>random-&gt;next</code>。确定了每个新节点的<code>random</code>之后再将新链表拆分出来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">RandomListNode* <span class="hljs-title">Clone</span><span class="hljs-params">(RandomListNode* pHead)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pHead == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-comment">// 插入新节点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> cur = pHead; cur;)&#123;<br>            <span class="hljs-keyword">auto</span> next = cur-&gt;next;<br>            cur-&gt;next = <span class="hljs-keyword">new</span> RandomListNode(cur-&gt;label);<br>            cur-&gt;next-&gt;next = next;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-comment">// 确定新节点的random</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> cur = pHead; cur;)&#123;<br>            <span class="hljs-keyword">auto</span> next = cur-&gt;next;<br>            <span class="hljs-keyword">if</span>(cur-&gt;random)&#123;<br>                next-&gt;random = cur-&gt;random-&gt;next;<br>            &#125;<br>            cur = next-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 拆分</span><br>        <span class="hljs-keyword">auto</span> ans = pHead-&gt;next;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> cur = pHead; cur;)&#123;<br>            <span class="hljs-keyword">auto</span> next = cur-&gt;next;<br>            cur-&gt;next = next-&gt;next;<br>            cur = cur-&gt;next;<br>            next-&gt;next = cur ? cur-&gt;next : <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="两个链表的第一个公共节点"><a href="#两个链表的第一个公共节点" class="headerlink" title="两个链表的第一个公共节点"></a>两个链表的第一个公共节点</h1><p>题目：<a href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&amp;tqId=11189&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&amp;from=cyc_github&amp;tab=answerKey">牛客网</a></p><p>输入两个链表，找出它们的第一个公共结点。</p><h2 id="解法一-1"><a href="#解法一-1" class="headerlink" title="解法一"></a>解法一</h2><p>遍历一次其中一条链表，用无序字典保存结点，遍历第二条链表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">FindFirstCommonNode</span><span class="hljs-params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!pHead1 || !pHead2)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-built_in">unordered_map</span>&lt;ListNode*, <span class="hljs-keyword">bool</span>&gt; has;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> cur = pHead1; cur; cur = cur-&gt;next)&#123;<br>            has[cur] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> cur = pHead2; cur; cur = cur-&gt;next)&#123;<br>            <span class="hljs-keyword">if</span>(has[cur])&#123;<br>                <span class="hljs-keyword">return</span> cur;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二-1"><a href="#解法二-1" class="headerlink" title="解法二"></a>解法二</h2><p>用双指针法，同时遍历，但是链表<code>A</code>和链表<code>B</code>的长度<code>a</code>和<code>b</code>可能不同</p><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21-02-24/1.PNG" alt=""></p><p>由于<code>a+b=b+a</code>，可以假设在链表<code>A</code>之前补上链表<code>B</code>，在链表<code>B</code>之前补上链表<code>A</code>，这样同时遍历的长度就都是<code>a+b</code>了。</p><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21-02-24/2.PNG" alt=""></p><p>实际并不真的将两个链表连起来，而是在遍历到链表尾时转而从另一条链表开始遍历。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">FindFirstCommonNode</span><span class="hljs-params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!pHead1 || !pHead2)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> cur1 = pHead1, cur2 = pHead2;<br>        <span class="hljs-keyword">while</span>(cur1 != cur2)&#123;<br>            cur1 = cur1 ? cur1-&gt;next : pHead2;<br>            cur2 = cur2 ? cur2-&gt;next : pHead1;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>这里不会并造成死循环，因为两个指针走完<code>a+b</code>之后就都会到达<code>nullptr</code>，也就是相等，从而终止循环</strong></p>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反转链表 &amp; 合并两个排序的链表</title>
      <link href="posts/4cc80e00/"/>
      <url>posts/4cc80e00/</url>
      
        <content type="html"><![CDATA[<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><p>题目：<a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&amp;tqId=11168&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&amp;from=cyc_github&amp;tab=answerKey">牛客网</a></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>设置一个虚拟头节点<code>vHead</code>，使用头插法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">ReverseList</span><span class="hljs-params">(ListNode* pHead)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(pHead == <span class="hljs-literal">nullptr</span> || pHead-&gt;next == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> pHead;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> vHead = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> cur = pHead; cur != <span class="hljs-literal">nullptr</span>;)&#123;<br>            <span class="hljs-keyword">auto</span> next = cur-&gt;next;<br>            cur-&gt;next = vHead-&gt;next;<br>            vHead-&gt;next = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> vHead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h1><p>题目：<a href="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&amp;tqId=11169&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&amp;from=cyc_github&amp;tab=answerKey">牛客网</a></p><h2 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h2><p>设置一个虚拟头节点<code>vHead</code>，一个<code>last</code>指向合并后的最后一个结点，两个指针分别指向两个链表最小元素（最前面），</p><p>最后当一个链表为空时，只需要将另一个直接挂在<code>last</code>之后即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">Merge</span><span class="hljs-params">(ListNode* pHead1, ListNode* pHead2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pHead1 == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> pHead2;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pHead2 == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> pHead1;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> vHead = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">-1</span>), last = vHead, cur1 = pHead1, cur2 = pHead2;<br>        <span class="hljs-keyword">while</span>(cur1 &amp;&amp; cur2)&#123;<br>            <span class="hljs-keyword">if</span>(cur1-&gt;val &lt; cur2-&gt;val)&#123;<br>                last-&gt;next = cur1;<br>                last = cur1;<br>                cur1 = cur1-&gt;next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                last-&gt;next = cur2;<br>                last = cur2;<br>                cur2 = cur2-&gt;next;<br>            &#125;<br>        &#125;<br>        last-&gt;next = cur1 ? cur1 : cur2;<br>        <span class="hljs-keyword">return</span> vHead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表中倒数第k个节点 &amp; 链表中环的入口节点</title>
      <link href="posts/1c9c196c/"/>
      <url>posts/1c9c196c/</url>
      
        <content type="html"><![CDATA[<h2 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a>链表中倒数第k个节点</h2><p>题目：<a href="https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&amp;tqId=11167&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&amp;from=cyc_github&amp;tab=answerKey">牛客网</a></p><p>输入一个链表，输出该链表中倒数第k个结点。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>第一次遍历得到总长度<code>len</code>，第二次遍历到第<code>len-k+1</code>个（将<code>len</code>减到k）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">FindKthToTail</span><span class="hljs-params">(ListNode* pListHead, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span> || pListHead == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> len&#123;<span class="hljs-number">0</span>&#125;;<br>        ListNode* cur;<br>        <span class="hljs-keyword">for</span>(cur = pListHead; cur != <span class="hljs-literal">nullptr</span>; cur = cur-&gt;next)&#123;<br>            len++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(k &gt; len)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(cur = pListHead; len != k; cur = cur-&gt;next)&#123;<br>            len--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="链表中环的入口节点"><a href="#链表中环的入口节点" class="headerlink" title="链表中环的入口节点"></a>链表中环的入口节点</h2><p>题目：<a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&amp;tqId=11208&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&amp;from=cyc_github&amp;tab=answerKey">牛客网</a></p><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>遍历并记录结点，有重复时就出现了环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">EntryNodeOfLoop</span><span class="hljs-params">(ListNode* pHead)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pHead == <span class="hljs-literal">nullptr</span> || pHead -&gt; next == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-built_in">vector</span>&lt;ListNode*&gt; nodes;<br>        <span class="hljs-keyword">for</span>(ListNode* cur = pHead; cur != <span class="hljs-literal">nullptr</span>; cur = cur-&gt;next)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; node : nodes)&#123;<br>                <span class="hljs-keyword">if</span>(node == cur)&#123;<br>                    <span class="hljs-keyword">return</span> cur;<br>                &#125;<br>            &#125;<br>            nodes.push_back(cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>设置两个指针，都从<code>pHead</code>开始，一个每次前进两步，另一个每次前进一步。当两个指针相遇时，说明有环。这时将一个指针回到<code>pHead</code>，然后都继续每次前进一步，第二次相遇点即为环的入口。</p><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21-02-23/1.PNG" alt="示意图" style="zoom:80%;" /></p><p>如上图所示：<code>s=b+c</code></p><p>第一次相遇：<code>2 * (a + b) = a + b + n * s</code> =&gt; <code>a = n * s - b</code></p><p>第二次相遇：两个指针分别从起点和第一次相遇点开始同速前进，最终相遇时都前进了<code>a</code>，此处即入口点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">EntryNodeOfLoop</span><span class="hljs-params">(ListNode* pHead)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pHead == <span class="hljs-literal">nullptr</span> || pHead-&gt;next == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        ListNode* ptr1 = pHead, * ptr2 = pHead;<br>        <span class="hljs-keyword">while</span>(ptr1 != <span class="hljs-literal">nullptr</span> &amp;&amp; ptr1-&gt;next != <span class="hljs-literal">nullptr</span>)&#123;<br>            ptr1 = ptr1-&gt;next-&gt;next;<br>            ptr2 = ptr2-&gt;next;<br>            <span class="hljs-keyword">if</span>(ptr1 == ptr2)&#123;<br>                ptr1 = pHead;<br>                <span class="hljs-keyword">while</span>(ptr1 != ptr2)&#123;<br>                    ptr1 = ptr1-&gt;next;<br>                    ptr2 = ptr2-&gt;next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> ptr1;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从头到尾打印链表 &amp; 删除链表中重复的结点</title>
      <link href="posts/4ab8daa5/"/>
      <url>posts/4ab8daa5/</url>
      
        <content type="html"><![CDATA[<h2 id="从头到尾打印链表"><a href="#从头到尾打印链表" class="headerlink" title="从头到尾打印链表"></a>从头到尾打印链表</h2><p>题目：<a href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&amp;tqId=11156&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&amp;from=cyc_github&amp;tab=answerKey">牛客网</a></p><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>先遍历一次获取总长度，然后在遍历一次，同时确定反转后的位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">*  struct ListNode &#123;</span><br><span class="hljs-comment">*        int val;</span><br><span class="hljs-comment">*        struct ListNode *next;</span><br><span class="hljs-comment">*        ListNode(int x) :</span><br><span class="hljs-comment">*              val(x), next(NULL) &#123;</span><br><span class="hljs-comment">*        &#125;</span><br><span class="hljs-comment">*  &#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">printListFromTailToHead</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;();<br>        &#125;<br>        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>        ListNode* cur = head;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)&#123;<br>            len++;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(len--)</span></span>;<br>        cur = head;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)&#123;<br>            ans[len--] = cur-&gt;val;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="删除链表中重复的结点"><a href="#删除链表中重复的结点" class="headerlink" title="删除链表中重复的结点"></a>删除链表中重复的结点</h2><p>题目：<a href="https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&amp;from=cyc_github&amp;tab=answerKey">牛客网</a></p><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>根据示例可知，只要是重复了的，就一个都不会保留，这样<code>pHead</code>就会改变。在遍历修改的过程中首先需要考虑<code>pHead</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplication</span><span class="hljs-params">(ListNode* pHead)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pHead == <span class="hljs-literal">nullptr</span> || pHead-&gt;next == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> pHead;<br>        &#125;<br>        ListNode* next = pHead-&gt;next;<br>        <span class="hljs-comment">// update pHead</span><br>        <span class="hljs-keyword">while</span>(pHead != <span class="hljs-literal">nullptr</span> &amp;&amp; next != <span class="hljs-literal">nullptr</span> &amp;&amp; pHead-&gt;val == next-&gt;val)&#123;<br>            <span class="hljs-keyword">while</span>(next != <span class="hljs-literal">nullptr</span> &amp;&amp; pHead-&gt;val == next-&gt;val)&#123;<br>                <span class="hljs-keyword">delete</span> pHead;<br>                pHead = next;<br>                next = next-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">delete</span> pHead;<br>            pHead = next;<br>            <span class="hljs-keyword">if</span>(next != <span class="hljs-literal">nullptr</span>)&#123;<br>                next = next-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(pHead == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(ListNode* cur = pHead-&gt;next, * pre = pHead, * next = cur-&gt;next; cur != <span class="hljs-literal">nullptr</span> &amp;&amp; next != <span class="hljs-literal">nullptr</span>;)&#123;<br>            <span class="hljs-keyword">if</span>(next != <span class="hljs-literal">nullptr</span> &amp;&amp; cur-&gt;val == next-&gt;val)&#123;<br>                <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span> &amp;&amp; (next = cur-&gt;next) != <span class="hljs-literal">nullptr</span> &amp;&amp; cur-&gt;val == next-&gt;val)&#123;<br>                    <span class="hljs-keyword">delete</span> cur;<br>                    cur = next;<br>                    next = next-&gt;next;<br>                &#125;<br>                <span class="hljs-keyword">delete</span> cur;<br>                pre-&gt;next = next;<br>                cur = next;<br>                <span class="hljs-keyword">if</span>(cur != <span class="hljs-literal">nullptr</span>)&#123;<br>                    next = cur-&gt;next;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                pre = cur;<br>                cur = next;<br>                next = cur-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pHead;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>上面的写法有很多冗余，就是因为把<code>pHead</code>与后面的结点分开进行了处理，实际上可以添加一个头节点，这样可以统一处理后面的结点。具体做法就是将上面额外处理<code>pHead</code>的部分删掉，后面的处理用<code>vHead</code>代替<code>pHead</code>，最后返回<code>vHead-&gt;next</code>即可.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplication</span><span class="hljs-params">(ListNode* pHead)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pHead == <span class="hljs-literal">nullptr</span> || pHead-&gt;next == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> pHead;<br>        &#125;<br>        ListNode* vHead = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">-1</span>);<br>        vHead-&gt;next = pHead;<br>        <span class="hljs-keyword">for</span>(ListNode* cur = vHead-&gt;next, * pre = vHead, * next = cur-&gt;next; cur != <span class="hljs-literal">nullptr</span> &amp;&amp; next != <span class="hljs-literal">nullptr</span>;)&#123;<br>            <span class="hljs-keyword">if</span>(next != <span class="hljs-literal">nullptr</span> &amp;&amp; cur-&gt;val == next-&gt;val)&#123;<br>                <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span> &amp;&amp; (next = cur-&gt;next) != <span class="hljs-literal">nullptr</span> &amp;&amp; cur-&gt;val == next-&gt;val)&#123;<br>                    <span class="hljs-keyword">delete</span> cur;<br>                    cur = next;<br>                    next = next-&gt;next;<br>                &#125;<br>                <span class="hljs-keyword">delete</span> cur;<br>                pre-&gt;next = next;<br>                cur = next;<br>                <span class="hljs-keyword">if</span>(cur != <span class="hljs-literal">nullptr</span>)&#123;<br>                    next = cur-&gt;next;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                pre = cur;<br>                cur = next;<br>                next = cur-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> vHead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><p>在处理链表的时候,添加一个虚拟的头节点,比如上面的<code>vHead</code>,可以使得链表的处理方便不少.</p>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>翻转单词顺序列 &amp; 左旋转字符串</title>
      <link href="posts/c2a55072/"/>
      <url>posts/c2a55072/</url>
      
        <content type="html"><![CDATA[<h2 id="翻转单词顺序列"><a href="#翻转单词顺序列" class="headerlink" title="翻转单词顺序列"></a>翻转单词顺序列</h2><p>题目：<a href="https://www.nowcoder.com/practice/3194a4f4cf814f63919d0790578d51f3?tpId=13&amp;tqId=11197&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&amp;from=cyc_github&amp;tab=answerKey">牛客网</a></p><p>例如，“student. a am I”，正确的句子应该是“I am a student.”。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>根据题目示例可知，句子中只是单词顺序颠倒，单词内部字符顺序是正确的，同时连在单词后面的<code>&#39;.&#39;</code>字符可以看成是与单词连在一起的，而单词前面的<code>&#39; &#39;</code>是用来分隔单词（包括<code>&#39;.&#39;</code>）的则需要放到后面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">ReverseSentence</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> size = str.size();<br>        <span class="hljs-keyword">if</span>(size &lt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">ans</span><span class="hljs-params">(str)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, k = size<span class="hljs-number">-1</span>; i &lt; size;)&#123;<br>            <span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(j &lt; size &amp;&amp; str[j] != <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                j++;<br>            &#125;<br>            <span class="hljs-keyword">int</span> t = j<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span>(t &gt;= i)&#123;<br>                ans[k--] = str[t--];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(k &gt;= <span class="hljs-number">0</span>)&#123;<br>                ans[k--] = <span class="hljs-string">&#x27; &#x27;</span>;<br>            &#125;<br>            i = j+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h2><p>题目：<a href="https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&amp;tqId=11196&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&amp;from=cyc_github&amp;tab=answerKey">牛客网</a></p><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>首先检测输入的合法性，然后因为是循环移动，要先使用<code>%</code>运算省去不必要的计算，最后使用辅助空间直接将字符串放到目标位置，而不用一个一个移动。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">LeftRotateString</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> size = str.size();<br>        <span class="hljs-keyword">int</span> k;<br>        <span class="hljs-keyword">if</span>(size &lt;= <span class="hljs-number">0</span> || n &lt;= <span class="hljs-number">0</span> || (k = n % size) &lt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> str;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">ans</span><span class="hljs-params">(str)</span></span>;<br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = k; i &lt; size; i++)&#123;<br>            ans[j++] = str[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)&#123;<br>            ans[j++] = str[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>和为S的两个数字 &amp; 和为S的连续正数序列</title>
      <link href="posts/f90ccec3/"/>
      <url>posts/f90ccec3/</url>
      
        <content type="html"><![CDATA[<h2 id="和为S的两个数字"><a href="#和为S的两个数字" class="headerlink" title="和为S的两个数字"></a>和为S的两个数字</h2><p>题目：<a href="https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b?tpId=13&amp;tqId=11195&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&amp;from=cyc_github&amp;tab=answerKey">牛客网</a></p><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>要求是乘积最小，并且已知数组递增，那么可以用双指针从最外层（开头和结尾）向内寻找，找到的第一对和为<code>S</code>的就是结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">FindNumbersWithSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">array</span>,<span class="hljs-keyword">int</span> sum)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> size = <span class="hljs-built_in">array</span>.size();<br>        <span class="hljs-keyword">if</span>(size &lt; <span class="hljs-number">2</span> || sum &lt;= <span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>])&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;();<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = size - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[i] &lt; sum)&#123;<br>                <span class="hljs-keyword">int</span> t = sum - <span class="hljs-built_in">array</span>[i];<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[j] == t)&#123;<br>                        ans[<span class="hljs-number">0</span>] = <span class="hljs-built_in">array</span>[j];<br>                        ans[<span class="hljs-number">1</span>] = <span class="hljs-built_in">array</span>[i];<br>                        <span class="hljs-keyword">return</span> ans;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="和为S的连续正数序列"><a href="#和为S的连续正数序列" class="headerlink" title="和为S的连续正数序列"></a>和为S的连续正数序列</h2><p>题目：<a href="https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe?tpId=13&amp;tqId=11194&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&amp;from=cyc_github&amp;tab=answerKey">牛客网</a></p><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!</p><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>可能的数字组合中最小值为<code>1</code>，最大值为$\frac{sum}{2}+1$（因为至少要两个数）。用双指针从前向后并从后向前逐步缩短序列，序列的和直接用等差数列求和公式$\frac{(i+j){\times}(j-i+1)}{2}$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; FindContinuousSequence(<span class="hljs-keyword">int</span> sum) &#123;<br>        <span class="hljs-keyword">if</span>(sum &lt;= <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;();<br>        &#125;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">int</span> u = (sum &gt;&gt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; u; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = u; j &gt; i; j--)&#123;<br>                <span class="hljs-keyword">int</span> len = j-i+<span class="hljs-number">1</span>, t = ((i+j)*len) &gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(t == sum)&#123;<br>                    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(len)</span></span>; t = i;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; len; k++)&#123;<br>                        v[k] = t++;<br>                    &#125;<br>                    ans.push_back(v);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口的最大值</title>
      <link href="posts/9c03e1e3/"/>
      <url>posts/9c03e1e3/</url>
      
        <content type="html"><![CDATA[<h2 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h2><p>题目：<a href="https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=13&amp;tqId=11217&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a></p><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组<code>&#123;2,3,4,2,6,2,5,1&#125;</code>及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为<code>&#123;4,4,6,6,6,5&#125;</code>； </p><p>针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： <code>&#123;[2,3,4],2,6,2,5,1&#125;， &#123;2,[3,4,2],6,2,5,1&#125;， &#123;2,3,[4,2,6],2,5,1&#125;， &#123;2,3,4,[2,6,2],5,1&#125;， &#123;2,3,4,2,[6,2,5],1&#125;， &#123;2,3,4,2,6,[2,5,1]&#125;</code>。</p><p>窗口大于数组长度的时候，返回空</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>直接按照定义进行求解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">maxInWindows</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; num, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> size)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> numSize = num.size();<br>        <span class="hljs-keyword">if</span>(numSize &lt;= <span class="hljs-number">0</span> || size == <span class="hljs-number">0</span> || numSize &lt; size)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;();<br>        &#125;<br>        <span class="hljs-keyword">int</span> m, ansSize = numSize - size + <span class="hljs-number">1</span>;<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(ansSize)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ansSize; i++)&#123;<br>            ans[i] = num[i];<br>            <span class="hljs-keyword">int</span> t = ans[i];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>, u = i+size; j &lt; u; j++)&#123;<br>                <span class="hljs-keyword">if</span>(num[j] &gt; t)&#123;<br>                    t = num[j];<br>                &#125;<br>            &#125;<br>            ans[i] = t;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>相邻两个窗口有<code>size-1</code>的部分是重叠的，如果前一个窗口的最大值在重叠部分，那么就不需要再对重叠部分进行遍历了。</p><p>具体做法是：用<code>idx</code>记录上一个窗口最大值的下标，判断上一个窗口最大值是否在当前窗口中，如果是，则不需要重新遍历<code>size</code>个元素，而只需要将当前窗口的最后一个元素与上一个窗口的最大值进行比较即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">maxInWindows</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; num, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> size)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> numSize = num.size();<br>        <span class="hljs-keyword">if</span>(numSize &lt;= <span class="hljs-number">0</span> || size == <span class="hljs-number">0</span> || numSize &lt; size)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;();<br>        &#125;<br>        <span class="hljs-keyword">int</span> idx = <span class="hljs-number">-1</span>, ansSize = numSize - size + <span class="hljs-number">1</span>;<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(ansSize)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ansSize; i++)&#123;<br>            <span class="hljs-keyword">int</span> u = i+size<span class="hljs-number">-1</span>; <span class="hljs-comment">// 此窗口最后一个下标</span><br>            <span class="hljs-keyword">if</span>(idx &gt;= i)&#123; <span class="hljs-comment">// 上一个窗口的最大值在此窗口中</span><br>                <span class="hljs-keyword">if</span>(num[u] &gt; num[idx])&#123;<br>                    idx = u;<br>                &#125;<br>                ans[i] = num[idx];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">int</span> t = num[i];<br>                idx = i;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= u; j++)&#123;<br>                    <span class="hljs-keyword">if</span>(num[j] &gt; t)&#123;<br>                        t = num[j];<br>                        idx = j;<br>                    &#125;<br>                &#125;<br>                ans[i] = t;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符流中第一个不重复的字符</title>
      <link href="posts/de5e44ea/"/>
      <url>posts/de5e44ea/</url>
      
        <content type="html"><![CDATA[<h2 id="字符流中第一个不重复的字符"><a href="#字符流中第一个不重复的字符" class="headerlink" title="字符流中第一个不重复的字符"></a>字符流中第一个不重复的字符</h2><p>题目：<a href="https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&amp;tqId=11207&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a></p><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><ul><li>用<code>std::string</code>保存字符，并用一个下标<code>cur</code>保存当前第一个出现的字符的位置，用长为256的数组对字符进行计数</li><li>每次加入字符时，对应字符的计数++，如果是重复字符就不用加入到字符串中了</li><li>取第一次出现的字符只需要从<code>cur</code>向后遍历即可</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">//Insert one char from stringstream</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(++cnt[ch] == <span class="hljs-number">1</span>)&#123;<br>            str += ch;<br>        &#125;<br>    &#125;<br>  <span class="hljs-comment">//return the first appearence once char in current stringstream</span><br>    <span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">FirstAppearingOnce</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> size = str.size();<br>        <span class="hljs-keyword">while</span>(cur &lt; size)&#123;<br>            <span class="hljs-keyword">if</span>(cnt[str[cur]] == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> str[cur];<br>            &#125;<br>            cur++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;#&#x27;</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> cur&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">int</span> cnt[<span class="hljs-number">256</span>]&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-built_in">string</span> str&#123;<span class="hljs-string">&quot;&quot;</span>&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据流中的中位数</title>
      <link href="posts/45531644/"/>
      <url>posts/45531644/</url>
      
        <content type="html"><![CDATA[<h2 id="数据流中的中位数"><a href="#数据流中的中位数" class="headerlink" title="数据流中的中位数"></a>数据流中的中位数</h2><p>题目：<a href="https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1?tpId=13&amp;tqId=11216&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a></p><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用<code>Insert()</code>方法读取数据流，使用<code>GetMedian()</code>方法获取当前读取数据的中位数。</p><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><ul><li>使用插入排序，维护带头节点的双向链表保持数据链非递减，并用一个<code>_mid</code>指针指向中位数</li><li>头节点中保存链表长度</li><li>总长度为奇数时，<code>_mid</code>指向的就是中位数；总长度为偶数时，<code>_mid</code>指向的数和下一个数的均值是中位数</li><li>每次插入一个数都要根据当前总个数为奇数还是偶数来使<code>_mid</code>前移或后移</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    Node(<span class="hljs-keyword">int</span> num_, Node* prev_ = <span class="hljs-literal">nullptr</span>, Node* next_ = <span class="hljs-literal">nullptr</span>): <br>        num(num_), next(next_), prev(prev_)&#123;<br>    &#125;<br>    <span class="hljs-keyword">int</span> num;<br>    Node* next;<br>    Node* prev;<br>&#125;Node;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    Solution(): _head&#123;<span class="hljs-keyword">new</span> Node(<span class="hljs-number">0</span>)&#125;, _mid(<span class="hljs-literal">nullptr</span>)&#123;<br>    &#125;<br>    <span class="hljs-keyword">void</span> Insert(<span class="hljs-keyword">int</span> num)<br>    &#123;<br>        _head-&gt;num++; <span class="hljs-comment">// 头节点保存总个数</span><br>        Node* newNode = <span class="hljs-keyword">new</span> Node(num);<br>        <span class="hljs-keyword">if</span>(_mid == <span class="hljs-literal">nullptr</span>)&#123;<br>            _head-&gt;next = _mid = newNode;<br>            newNode-&gt;prev = _head;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            Node* tmp;<br>            <span class="hljs-keyword">if</span>(num &lt;= _mid-&gt;num)&#123; <span class="hljs-comment">// 插到_mid之前</span><br>                tmp = _mid-&gt;prev;<br>                <span class="hljs-keyword">while</span>(tmp != _head &amp;&amp; tmp-&gt;num &gt; num)&#123;<br>                    tmp = tmp-&gt;prev;<br>                &#125;<br>                tmp-&gt;next-&gt;prev = newNode;<br>                newNode-&gt;next = tmp-&gt;next;<br>                tmp-&gt;next = newNode;<br>                newNode-&gt;prev = tmp;<br>                <span class="hljs-keyword">if</span>(!(_head-&gt;num &amp; <span class="hljs-number">1</span>))&#123; <span class="hljs-comment">// 现在总数为偶数，_mid前移</span><br>                    _mid = _mid-&gt;prev;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 插入到_mid之后</span><br>                tmp = _mid;<br>                <span class="hljs-keyword">while</span>(tmp-&gt;num &lt; num &amp;&amp; tmp-&gt;next != <span class="hljs-literal">nullptr</span>)&#123;<br>                    tmp = tmp-&gt;next;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(tmp-&gt;num &gt;= num)&#123;<br>                    tmp-&gt;prev-&gt;next = newNode;<br>                    newNode-&gt;prev = tmp-&gt;prev;<br>                    tmp-&gt;prev = newNode;<br>                    newNode-&gt;next = tmp;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    tmp-&gt;next = newNode;<br>                    newNode-&gt;prev = tmp;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(_head-&gt;num &amp; <span class="hljs-number">1</span>)&#123; <span class="hljs-comment">// 现在总数为奇数，_mid后移</span><br>                    _mid = _mid-&gt;next;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">GetMedian</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123; <br>        <span class="hljs-keyword">if</span>(_head-&gt;num &amp; <span class="hljs-number">1</span>)&#123; <span class="hljs-comment">// 总数为奇数，_mid所指就是中位数</span><br>            <span class="hljs-keyword">return</span> _mid-&gt;num;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> (_mid-&gt;num + _mid-&gt;next-&gt;num) / <span class="hljs-number">2.0</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    Node* _head;<br>    Node* _mid;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><ul><li>将中位数左边的用大顶堆保存，中位数右边的用小顶堆保存（中位数自己也可能在堆中）</li><li>两个堆的大小最多相差1（这里始终保持左边的数不少于右边的）</li><li>每次插入一个元素时<ol><li>如果左右两堆大小相同，不可以直接插入左边的，因为新的数可能比右边最小的数大，这个时候就要先插入右边，然后再从右边取一个数补给左边。</li><li>如果两堆大小不同，则根据上面的约定，一定是左边多一个数，那么新的数直接插入左边，之后再从左边取一个数补给右边即可。</li></ol></li></ul><p><strong>这样就可以快速找到中位数，而且不用保持整个数据链有序，从而提高效率。</strong></p><blockquote><p>注意：C++中的优先队列的比较函数比较的结果是<strong>弱序</strong>，也就是低优先级。默认的比较器是<code>std::less</code>，越小则优先级越低，也就是队头的是最大的</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(maxQ.size() == minQ.size())&#123;<br>            <span class="hljs-keyword">if</span>(maxQ.size() == <span class="hljs-number">0</span>)&#123;<br>                maxQ.push(num);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(minQ.top() &lt; num)&#123;<br>                minQ.push(num);<br>                maxQ.push(minQ.top());<br>                minQ.pop();<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                maxQ.push(num);<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            maxQ.push(num);<br>            minQ.push(maxQ.top());<br>            maxQ.pop();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">GetMedian</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123; <br>        <span class="hljs-keyword">return</span> maxQ.size() == minQ.size() ? <br>            (maxQ.top() + minQ.top()) / <span class="hljs-number">2.0</span> : (<span class="hljs-keyword">double</span>)maxQ.top();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-keyword">int</span>&gt; maxQ;<br>    <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; minQ;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python批量处理指定路径下所有文件</title>
      <link href="posts/767c1330/"/>
      <url>posts/767c1330/</url>
      
        <content type="html"><![CDATA[<h2 id="主要函数foreach-file"><a href="#主要函数foreach-file" class="headerlink" title="主要函数foreach_file"></a>主要函数foreach_file</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*-coding:utf-8 -*-</span><br><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Callable<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foreach_file</span>(<span class="hljs-params">path: <span class="hljs-built_in">str</span>, do: Callable[[<span class="hljs-built_in">str</span>], <span class="hljs-literal">None</span>]</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;处理路径下所有文件</span><br><span class="hljs-string"></span><br><span class="hljs-string">    :param path: 起始目录</span><br><span class="hljs-string">    :param do: 文件处理函数（参数为绝对路径，无返回值）</span><br><span class="hljs-string">    :return: 无返回值</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    files = os.listdir(path)<br>    <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> files:<br>        file_abs = os.path.join(path, file)<br>        <span class="hljs-keyword">if</span> os.path.isdir(file_abs):<br>            foreach_file(file_abs, do)<br>        <span class="hljs-keyword">else</span>:<br>            do(file_abs)<br><br></code></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>利用这个函数就可以方便地处理文件了</p><ul><li><p>打印所有文件名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">source_path = <span class="hljs-string">&#x27;D:/test/&#x27;</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    foreach_file(source_path, <span class="hljs-keyword">lambda</span> file: print(file))<br></code></pre></td></tr></table></figure></li><li><p>更改文件后缀</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">source_path = <span class="hljs-string">&#x27;D:/test/&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process</span>(<span class="hljs-params">file: <span class="hljs-built_in">str</span></span>):</span><br>    root_ext = os.path.splitext(file)<br>    <span class="hljs-keyword">if</span> root_ext[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;.txt&#x27;</span>:  <span class="hljs-comment"># 将所有.txt文件改为.data</span><br>        new_name = root_ext[<span class="hljs-number">0</span>] + <span class="hljs-string">&#x27;.data&#x27;</span><br>        <span class="hljs-comment"># print(file + &#x27; --&gt; &#x27; + new_name)</span><br>        os.rename(file, new_name)<br>        <br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    foreach_file(source_path, process)<br></code></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取Bilibili手机端音视频缓存文件</title>
      <link href="posts/28142ca5/"/>
      <url>posts/28142ca5/</url>
      
        <content type="html"><![CDATA[<h3 id="离线缓存路径"><a href="#离线缓存路径" class="headerlink" title="离线缓存路径"></a>离线缓存路径</h3><p><a href="https://app.bilibili.com/">Bilibili手机端（Android）</a>的默认缓存路径为：<code>/Android/data/tv.danmaku.bili/download/</code></p><p>每个缓存的视频文件都会分别放在这个路径下的一个子文件夹中，文件夹名随机，例如<code>84382269</code></p><blockquote><p>可以通过文件夹创建时间来区分离线的视频</p></blockquote><p>再进入一个子文件夹（<code>c_</code>开头，比如<code>c_294940961</code>），然后看到有<code>danmaku.xml</code>、<code>entry.json</code>和一个文件夹（通常名为<code>64</code>），再进入这个文件夹。</p><p>现在路径类似于：<code>/Android/data/tv.danmaku.bili/download/84382269/c_294940961/64/</code></p><p>可以看到<code>audio.m4s</code>、<code>video.m4s</code>和<code>index.json</code>，这两个<code>.m4s</code>文件就是对应缓存视频的音频和视频了。</p><h3 id="修改文件格式"><a href="#修改文件格式" class="headerlink" title="修改文件格式"></a>修改文件格式</h3><p>将这两个<code>.m4s</code>文件分别复制一份，然后将复制文件的后缀分别改成<code>.mp3</code>和<code>.mp4</code>，即<code>audio.mp3</code>和<code>video.mp4</code>，这样一般的播放器都可以识别播放。为便于区分，可以改成对应视频的名字，如<code>时光盲盒.mp3</code>和<code>时光盲盒.mp4</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bilibili </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小的K个数</title>
      <link href="posts/e24c3085/"/>
      <url>posts/e24c3085/</url>
      
        <content type="html"><![CDATA[<h2 id="最小的K个数"><a href="#最小的K个数" class="headerlink" title="最小的K个数"></a>最小的K个数</h2><p>题目：<a href="https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&amp;tqId=11182&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a></p><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。</p><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>使用优先队列，本质是最小堆</p><p>（提交后才知道K大于输入长度的时候也要返回空数组）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">GetLeastNumbers_Solution</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; input, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(k &lt;= <span class="hljs-number">0</span> || k &gt; input.size())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;();<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(k)</span></span>;<br>        <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt; &gt; q(input.begin(), input.end());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)&#123;<br>            ans[i] = q.top();<br>            q.pop();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>排序，本质是快速排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">GetLeastNumbers_Solution</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; input, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(k &lt;= <span class="hljs-number">0</span> || k &gt; input.size())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;();<br>        &#125;<br>        sort(input.begin(), input.end());<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(input.begin(), input.begin() + k);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h3><p>利用快速排序的<code>partition</code>思想，可以快速找到前K小的数（题目中没有要求返回的结果要排序）</p><p>平均时间复杂度：<code>O(n)</code>（n+n/2+n/4+…+1）</p><p>最坏时间复杂度：<code>O(n^2)</code>（每次只移动一个元素）</p><p>空间复杂度：<code>O(1)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">GetLeastNumbers_Solution</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; input, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(k &lt;= <span class="hljs-number">0</span> || k &gt; input.size())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;();<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k == input.size())&#123;<br>            <span class="hljs-keyword">return</span> input;<br>        &#125;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = input.size() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l &lt;= r)&#123;<br>            <span class="hljs-keyword">int</span> pos = partition(input, l, r);<br>            <span class="hljs-keyword">if</span>(pos == k - <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(input.begin(), input.begin()+k);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pos &lt; k - <span class="hljs-number">1</span>)&#123;<br>                l = pos + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                r = pos - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> pivot = arr[l]; <span class="hljs-comment">// 枢轴</span><br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-keyword">while</span>(l &lt; r &amp;&amp; arr[r] &gt;= pivot) --r;<br>            arr[l] = arr[r];<br>            <span class="hljs-keyword">while</span>(l &lt; r &amp;&amp; arr[l] &lt;= pivot) ++l;<br>            arr[r] = arr[l];<br>        &#125;<br>        arr[l] = pivot; <span class="hljs-comment">// 最终l=r就是枢轴位置，左边都&lt;=枢轴，右边都&gt;=枢轴</span><br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈的压入、弹出序列</title>
      <link href="posts/cd307c9a/"/>
      <url>posts/cd307c9a/</url>
      
        <content type="html"><![CDATA[<h2 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h2><p>题目：<a href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&amp;tqId=11174&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a></p><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>可以设置一个辅助栈，尝试入栈和出栈流程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsPopOrder</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; pushV,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; popV)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> size = pushV.size();<br>        <span class="hljs-keyword">if</span>(size &lt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; s;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; j &lt; size; j++)&#123; <span class="hljs-comment">// i:指向下一个要push的元素，j：指向下一个要pop的元素</span><br>            <span class="hljs-keyword">if</span>(!s.empty() &amp;&amp; s.top() == popV[j])&#123;<br>                s.pop();<br>                i++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                 <span class="hljs-keyword">while</span>(i &lt; size &amp;&amp; pushV[i] != popV[j])&#123;<br>                     s.push(pushV[i++]);<br>                 &#125;<br>                 <span class="hljs-keyword">if</span>(i &gt;= size)&#123;<br>                     <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                 &#125;<br>                 i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用两个栈实现队列 &amp; 包含min函数的栈</title>
      <link href="posts/e658af2c/"/>
      <url>posts/e658af2c/</url>
      
        <content type="html"><![CDATA[<h2 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h2><p>题目：<a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&amp;tqId=11158&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a></p><p>用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>出栈顺序与出队列的顺序正好是相反的，很容易想到再导入另一个栈，就能得到出队顺序</p><p>push时直接向stack1中push，pop时先将stack1中的元素导入到stack2中，再从stack2中pop，所得就是结果，最后再将stack2中剩余元素导回stack1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> node)</span> </span>&#123;<br>        stack1.push(node);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> size = stack1.size();<br>        <span class="hljs-keyword">while</span>(size--)&#123;<br>            stack2.push(stack1.top());<br>            stack1.pop();<br>        &#125;<br>        <span class="hljs-keyword">int</span> ans = stack2.top();<br>        stack2.pop();<br>        size = stack2.size();<br>        <span class="hljs-keyword">while</span>(size--)&#123;<br>            stack1.push(stack2.top());<br>            stack2.pop();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; stack1;<br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; stack2;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>上面的做法比较简单，但是每次出队列操作需要重复移动大量元素。</p><p><strong>可以考虑将stack1中的元素导入stack2并取出队头元素之后，并不将stack2再导回stack1。</strong></p><p>因为将stack1中的元素导入到stack2中的过程就相当于是截取了现有的元素排成队列放到stack2里，stack2中的剩余元素就是按照出队顺序排好了的，之后出队列操作也是直接从stack2中pop就行了，如果stack2空了，就再从stack1导入。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> node)</span> </span>&#123;<br>        stack1.push(node);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(stack2.size() &lt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">int</span> size = stack1.size();<br>            <span class="hljs-keyword">while</span>(size--)&#123;<br>                stack2.push(stack1.top());<br>                stack1.pop();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> ans = stack2.top();<br>        stack2.pop();<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; stack1;<br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; stack2;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h2><p>题目：<a href="https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&amp;tqId=11173&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a></p><p>实现一个包含 min() 函数的栈，该方法返回当前栈中最小的值。（时间复杂度应为O（1））。</p><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>设置主栈和辅助栈，每次主栈push一个元素时，辅助栈push加入这个元素之后主栈内的最小值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        _s.push(value);<br>        <span class="hljs-keyword">if</span>(_s_min.empty() || value &lt; _s_min.top())&#123;<br>            _s_min.push(value);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            _s_min.push(_s_min.top());<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        _s_min.pop();<br>        _s.pop();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> _s.top();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> _s_min.top();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; _s;<br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; _s_min;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="改进-1"><a href="#改进-1" class="headerlink" title="改进"></a>改进</h3><ul><li>按照上面的解法，每次加入一个大于当前最小值的元素的时候，会在辅助栈再push当前最小值，这样会有大量冗余。实际上可以只在加入当前最小值的时候才在辅助栈中push，并且在删除栈顶元素时判断是不是删掉了当前最小值，如果是，才辅助栈中删掉一个当前最小值。</li><li>在加入元素中每次都要判断辅助栈是否为空，其实可以提前在辅助栈中存入一个最大整数值，就可以在不影响出栈顺序的情况下省掉这一判断。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    Solution()&#123;<br>        _s_min.push(INT_MAX);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        _s.push(value);<br>        <span class="hljs-keyword">if</span>(value &lt;= _s_min.top())&#123;<br>            _s_min.push(value);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(_s.top() == _s_min.top())&#123;<br>            _s_min.pop();<br>        &#125;<br>        _s.pop();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> _s.top();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> _s_min.top();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; _s;<br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; _s_min;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>串的模式匹配算法</title>
      <link href="posts/5782a085/"/>
      <url>posts/5782a085/</url>
      
        <content type="html"><![CDATA[<h1 id="串的模式匹配算法"><a href="#串的模式匹配算法" class="headerlink" title="串的模式匹配算法"></a>串的模式匹配算法</h1><h2 id="相关约定"><a href="#相关约定" class="headerlink" title="相关约定"></a>相关约定</h2><ul><li><p>串<code>s</code>的0号位置存放的是串<code>s</code>的长度，如<code>s = &#123;3, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;&#125;</code></p></li><li><p>主串记为<code>S</code>，模式串记为<code>T</code>，匹配过程中主串索引为<code>i</code>，模式串索引为<code>j</code></p></li><li><p>匹配目标是在<code>S</code>中找到<code>T</code>第一次出现的位置</p></li></ul><h2 id="朴素匹配算法"><a href="#朴素匹配算法" class="headerlink" title="朴素匹配算法"></a>朴素匹配算法</h2><p>每次匹配失败后，主串的索引<code>i</code>回溯到开头的下一个位置重新开始匹配</p><p>这次匹配的开头位置是<code>i - (j - 1)</code>，下次从<code>i - (j - 1)</code>开始匹配</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Index</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* s, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* t, <span class="hljs-keyword">int</span> pos = <span class="hljs-number">1</span>)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i = pos, j = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt;= s[<span class="hljs-number">0</span>] &amp;&amp; j &lt;= t[<span class="hljs-number">0</span>])&#123;<br>        <span class="hljs-keyword">if</span>(s[i] == t[j])&#123;<br>            i++; j++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            i += <span class="hljs-number">2</span> - j; j = <span class="hljs-number">1</span>; <span class="hljs-comment">// i = i - (j-1) + 1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> j &gt; t[<span class="hljs-number">0</span>] ? i - t[<span class="hljs-number">0</span>] : <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="KMP匹配算法"><a href="#KMP匹配算法" class="headerlink" title="KMP匹配算法"></a>KMP匹配算法</h2><p>不回溯主串索引<code>i</code>，而是向右移模式串的索引<code>j</code>，尽量利用已经匹配的结果。模式串索引<code>j</code>的下一个位置即为<code>next[j]</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">IndexKMP</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* s, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* t, <span class="hljs-keyword">int</span> pos = <span class="hljs-number">1</span>)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i = pos, j = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span>* next = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[t[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>];<br>    GetNext(t, next);<br>    <span class="hljs-keyword">while</span>(i &lt;= s[<span class="hljs-number">0</span>] &amp;&amp; j &lt;= t[<span class="hljs-number">0</span>])&#123;<br>        <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span> || s[i] == t[j])&#123;<br>            i++; j++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            j = next[j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] next;<br>    <span class="hljs-keyword">return</span> j &gt; t[<span class="hljs-number">0</span>] ? i - t[<span class="hljs-number">0</span>] : <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="求next数组"><a href="#求next数组" class="headerlink" title="求next数组"></a>求next数组</h3><h4 id="手算"><a href="#手算" class="headerlink" title="手算"></a>手算</h4><p>当匹配失效时，将模式串索引<code>j</code>之前由<code>1~j-1</code>的字符组成的串记为<code>str</code>，则</p><center>next[j] = str 的最长相同前后缀的长度 + 1</center><ul><li>这里<code>str</code>的前缀和后缀的长度都小于<code>str</code></li><li><code>next[1] = 0</code>，<code>next[2] = 1</code>（由上一条可知）</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GetNext</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* t, <span class="hljs-keyword">int</span> next[])</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>;<br>    next[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; t[<span class="hljs-number">0</span>])&#123;<br>        <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span> || t[i] == t[j])&#123;<br>            i++; j++;<br>            next[i] = j;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            j = next[j];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><div class="table-container"><table><thead><tr><th style="text-align:center">j</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th></tr></thead><tbody><tr><td style="text-align:center">T</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">next[j]</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td></tr></tbody></table></div><h3 id="next数组改进"><a href="#next数组改进" class="headerlink" title="next数组改进"></a>next数组改进</h3><p>按照上面求出的<code>next</code>数组，当模式串索引<code>j</code>处发生失配时，<code>j</code>需要改变为<code>next[j]</code>。但是如果<code>next[j]</code>处对应的模式串字符与<code>j</code>处对应的模式串字符相同，则改变之后匹配一定也是失败的。</p><p>所以<code>j</code>应该改成<code>next[next[j]]</code>，改进后的数组命名为<code>nextval</code></p><h4 id="手算-1"><a href="#手算-1" class="headerlink" title="手算"></a>手算</h4><p>先算出<code>next</code>数组，然后令<code>nextval[0] = 1</code>，从左向右逐个看<code>j</code>处的字符是否与<code>next[j]</code>的相同，如果是，就将对应<code>nextval</code>设为<code>nextval[nextval[j]]</code>，否则还是<code>next[j]</code></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>只需要改<code>GetNext</code>函数的一行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// next[i] = j; 改成下面的</span><br>next[i] = t[i] != t[j] ? j : next[j];<br></code></pre></td></tr></table></figure><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><div class="table-container"><table><thead><tr><th style="text-align:center">j</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th></tr></thead><tbody><tr><td style="text-align:center">T</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">next[j]</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">nextval[j]</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">4</td></tr></tbody></table></div><h2 id="使用std-string的版本"><a href="#使用std-string的版本" class="headerlink" title="使用std::string的版本"></a>使用std::string的版本</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 朴素匹配算法</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Index</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; s, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; t, <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i = pos, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> sizeS = s.size(), sizeT = t.size();<br>    <span class="hljs-keyword">while</span>(i &lt; sizeS &amp;&amp; j &lt; sizeT)&#123;<br>        <span class="hljs-keyword">if</span>(s[i] == t[j])&#123;<br>            i++; j++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            i += <span class="hljs-number">1</span> - j; j = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> j &gt;= sizeT ? i - sizeT: <span class="hljs-built_in">string</span>::npos;<br>&#125;<br><br><span class="hljs-comment">// 计算改进的next数组</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GetNext</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; t, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; next)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> sizeT = t.size();<br>    next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; sizeT)&#123;<br>        <span class="hljs-keyword">if</span>(j == <span class="hljs-number">-1</span> || t[i] == t[j])&#123;<br>            i++; j++;<br><span class="hljs-comment">//            next[i] = j;</span><br>            next[i] = t[i] != t[j] ? j : next[j];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            j = next[j];<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// KMP算法</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">IndexKMP</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; s, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; t, <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i = pos, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> sizeS = s.size(), sizeT = t.size();<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(sizeT)</span></span>;<br>    GetNext(t, next);<br>    <span class="hljs-keyword">while</span>(i &lt; sizeS &amp;&amp; j &lt; sizeT)&#123;<br>        <span class="hljs-keyword">if</span>(j == <span class="hljs-number">-1</span> || s[i] == t[j])&#123;<br>            i++; j++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            j = next[j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> j &gt;= sizeT ? i - sizeT : <span class="hljs-built_in">string</span>::npos;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺时针打印矩阵 &amp; 第一个只出现一次的字符位置</title>
      <link href="posts/38bc2790/"/>
      <url>posts/38bc2790/</url>
      
        <content type="html"><![CDATA[<h2 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h2><p>题目：<a href="https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&amp;tqId=11172&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a></p><p>按顺时针的方向，从外到里打印矩阵的值。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><ol><li><p>首先根据顺时针遍历矩阵，可以想到是一直循环→↓←↑这四个方向</p></li><li><p>在矩阵的右上角、右下角、左下角进行转向，左上角为起始点，不用转向。这里要考虑两种特殊情况：</p><ol><li>矩阵只有一行时，左上角和左下角重合</li><li>矩阵只有一列时，左上角和右上角重合</li></ol><p>这两种情况都可以通过当前的方向进行判断</p></li><li><p>每完成一遍循环之后矩阵都会缩小一圈</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">printMatrix</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> r1&#123;<span class="hljs-number">0</span>&#125;, r2 = matrix.size() - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 行r1~r2</span><br>        <span class="hljs-keyword">int</span> c1&#123;<span class="hljs-number">0</span>&#125;, c2 = matrix[<span class="hljs-number">0</span>].size() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 列c1~c2</span><br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">((r2+<span class="hljs-number">1</span>) * (c2+<span class="hljs-number">1</span>))</span></span>;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]&#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;&#125;; <span class="hljs-comment">// → ↓ ← ↑</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> cur&#123;<span class="hljs-number">0</span>&#125;, size = ans.size(), r&#123;<span class="hljs-number">0</span>&#125;, c&#123;<span class="hljs-number">0</span>&#125;, d&#123;<span class="hljs-number">0</span>&#125;; cur &lt; size; cur++)&#123;<br>            ans[cur] = matrix[r][c];<br>            <span class="hljs-comment">// 右上、右下、左下(只有一行时通过d区别左上和左下)</span><br>            <span class="hljs-keyword">if</span>((r == r1 &amp;&amp; c == c2) || (r == r2 &amp;&amp; c == c2) || (r == r2 &amp;&amp; c == c1 &amp;&amp; d))&#123;<br>                d++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(r == r1+<span class="hljs-number">1</span> &amp;&amp; c == c1 &amp;&amp; d == <span class="hljs-number">3</span>)&#123; <span class="hljs-comment">// 只有一列时通过d区别左上和右上</span><br>                d = <span class="hljs-number">0</span>;<br>                r1++; r2--;<br>                c1++; c2--;<br>            &#125;<br>            r += dir[d][<span class="hljs-number">0</span>];<br>            c += dir[d][<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><p>这题思路不难想，但是需要考虑好边界条件和特殊情况，不然一直是段错误。</p><p>这题在循环中用到了很多判断，可以稍微优化下，减少判断次数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">printMatrix</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> r1&#123;<span class="hljs-number">0</span>&#125;, r2 = matrix.size() - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 行r1~r2</span><br>        <span class="hljs-keyword">int</span> c1&#123;<span class="hljs-number">0</span>&#125;, c2 = matrix[<span class="hljs-number">0</span>].size() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 列c1~c2</span><br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">((r2+<span class="hljs-number">1</span>) * (c2+<span class="hljs-number">1</span>))</span></span>;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]&#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;&#125;; <span class="hljs-comment">// → ↓ ← ↑</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> cur&#123;<span class="hljs-number">0</span>&#125;, size = ans.size(), r&#123;<span class="hljs-number">0</span>&#125;, c&#123;<span class="hljs-number">0</span>&#125;, d&#123;<span class="hljs-number">0</span>&#125;; cur &lt; size; cur++)&#123;<br>            ans[cur] = matrix[r][c];<br>            <span class="hljs-keyword">if</span>(c == c2)&#123;<br>                <span class="hljs-keyword">if</span>(r == r1 || r == r2)&#123;<br>                    d++;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == c1)&#123;<br>                <span class="hljs-keyword">if</span>(r == r2 &amp;&amp; d)&#123;<br>                    d++;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(r == r1+<span class="hljs-number">1</span> &amp;&amp; d == <span class="hljs-number">3</span>)&#123;<br>                    d = <span class="hljs-number">0</span>;<br>                    r1++; r2--;<br>                    c1++; c2--;<br>                &#125;<br>            &#125;<br>            r += dir[d][<span class="hljs-number">0</span>];<br>            c += dir[d][<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="第一个只出现一次的字符位置"><a href="#第一个只出现一次的字符位置" class="headerlink" title="第一个只出现一次的字符位置"></a>第一个只出现一次的字符位置</h2><p>题目：<a href="https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c?tpId=13&amp;tqId=11187&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a></p><p>在一个字符串中找到第一个只出现一次的字符，并返回它的位置。字符串只包含 ASCII 码字符。</p><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>遍历两遍即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FirstNotRepeatingChar</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> cnt[<span class="hljs-string">&#x27;z&#x27;</span>-<span class="hljs-string">&#x27;A&#x27;</span>+<span class="hljs-number">1</span>]&#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> c : str)&#123;<br>            cnt[c-<span class="hljs-string">&#x27;A&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, size = str.size(); i &lt; size; i++)&#123;<br>            <span class="hljs-keyword">if</span>(cnt[str[i]-<span class="hljs-string">&#x27;A&#x27;</span>] == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>替换空格</title>
      <link href="posts/82b3ae31/"/>
      <url>posts/82b3ae31/</url>
      
        <content type="html"><![CDATA[<h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h2><p>题目：<a href="https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&amp;tqId=11155&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a></p><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>先确定最终的长度，再从后向前遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">replaceSpace</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str,<span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> nSpace = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(str[i] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                nSpace++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = length + <span class="hljs-number">2</span>*nSpace - <span class="hljs-number">1</span>, j = length - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--)&#123;<br>            <span class="hljs-keyword">if</span>(str[j] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                str[i--] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                str[i--] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                str[i--] = <span class="hljs-string">&#x27;%&#x27;</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                str[i--] = str[j];<br>            &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>直接利用<code>std::string</code>的字符串拼接或者其他语言自带的替换函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">replaceSpace</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str,<span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>        <span class="hljs-built_in">string</span> s;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; str[i] != <span class="hljs-number">0</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(str[i] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                s += <span class="hljs-string">&quot;%20&quot;</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                s += str[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">strcpy</span>(str, s.c_str());<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维数组中的查找</title>
      <link href="posts/dbea8e4c/"/>
      <url>posts/dbea8e4c/</url>
      
        <content type="html"><![CDATA[<h2 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h2><p>题目: <a href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&amp;tqId=11154&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a></p><p>给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二维数组中。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>根据递增排序，首先想到一行之内可以用二分法查找。而确定行号可以从最后一行开始向上遍历每行的行首元素，只要行首元素&lt;=tagret并且行尾元素&gt;=target，那就可以对这一行使用二分查找。没有找到还需要继续上一行，直到行首元素和行尾元素都小于target。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-built_in">array</span>)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>.size() &lt;= <span class="hljs-number">0</span> || <span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>].size() &lt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>, col = <span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>].size()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r = <span class="hljs-built_in">array</span>.size() - <span class="hljs-number">1</span>; r &gt;= <span class="hljs-number">0</span>; r--)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[r][<span class="hljs-number">0</span>] &lt;= target)&#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[r][col] &gt;= target)&#123;<br>                    <span class="hljs-keyword">if</span>(BinFind(target,<span class="hljs-built_in">array</span>[r]))&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   &#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">BinFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target, <span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(arr.size() &lt;= <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr.size() == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>] == target;<br>    &#125;<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = arr.size() - <span class="hljs-number">1</span>, cur = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(arr[cur] != target)&#123;<br>        <span class="hljs-keyword">if</span>(arr[cur] &lt; target)&#123;<br>            l = cur + <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            r = cur - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l &lt;= r)&#123;<br>            cur = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h4><p>根据递增的性质，对于行首元素的遍历应该也可以改用二分法，这里使用剪枝，复杂度也不算太高。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组中重复的数字</title>
      <link href="posts/a2a6349b/"/>
      <url>posts/a2a6349b/</url>
      
        <content type="html"><![CDATA[<h2 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h2><p>题目：<a href="https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&amp;tqId=11203&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a></p><blockquote><p>在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。</p></blockquote><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>建立相同长度的bool数组has，记录重复数字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">duplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numbers[], <span class="hljs-keyword">int</span> length, <span class="hljs-keyword">int</span>* duplication)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(numbers == <span class="hljs-literal">nullptr</span> || length &lt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><span class="hljs-comment">//         bool* has = new bool[length]&#123;0&#125;;</span><br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">has</span><span class="hljs-params">(length, <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(has[numbers[i]])&#123;<br>                duplication[<span class="hljs-number">0</span>] = numbers[i];<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                has[numbers[i]] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h4><p>这里先是用的动态开辟数组，但总是提示越界。换成vector就没错。后来才意识到开始没考虑length为0的情况，动态开辟会错误，用vector就不会了。而且用vector也不用管理内存了。</p><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p><del>不使用额外的空间，利用范围限制的条件，将元素放到其值对应的下标位置里</del></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">duplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numbers[], <span class="hljs-keyword">int</span> length, <span class="hljs-keyword">int</span>* duplication)</span> </span>&#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;length; ++i) &#123;<br>         <span class="hljs-comment">// 不相等就一直交换</span><br>         <span class="hljs-keyword">while</span> (i != numbers[i]) &#123;<br>             <span class="hljs-keyword">if</span> (numbers[i] != numbers[numbers[i]]) &#123;<br>                 swap(numbers[i], numbers[numbers[i]]);<br>             &#125;<br>             <span class="hljs-keyword">else</span> &#123;<br>                 *duplication = numbers[i];<br>                 <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>             &#125;<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是题解里给的一种解法，但是过不了测试用例：<code>[6,3,2,0,2,5,0]</code>，正确答案应该是2，输出却为0</p><h4 id="心得-1"><a href="#心得-1" class="headerlink" title="心得"></a>心得</h4><p>虽然这里用不了，但是这种就地(in-place)的思想还是可以借鉴的</p>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手算二维FFT</title>
      <link href="posts/49dd02/"/>
      <url>posts/49dd02/</url>
      
        <content type="html"><![CDATA[<h3 id="FFT原理"><a href="#FFT原理" class="headerlink" title="FFT原理"></a>FFT原理</h3><p>可以参照前面<a href="/posts/19f48cd5/">用C++实现的FFT算法</a></p><h3 id="手算一维FFT"><a href="#手算一维FFT" class="headerlink" title="手算一维FFT"></a>手算一维FFT</h3><p>对于序列[1, 2, 3, 4]</p><ol><li><p>将奇数项和偶数项分离</p><blockquote><p>注意：这里奇数偶数都是指在序列中的序号，而不是元素的值</p></blockquote><p>可以分为：[1, 3]和[2, 4]</p></li><li><p>计算只有两个数的FFT</p><p>$F_0=f_0+f_1W_2^0$</p><p>$F_1=f_0-f_1W_2^0$</p><p>其中$W_N^{ {\mu}x}=e^{\frac{-j2{\pi}{\mu}x}{N} }$， $W_N^0=1$</p><p>所以：$F_0=f_0+f_1$， $F_0=f_0-f_1$</p></li><li><p>计算四个数的FFT</p><p>得到了两个数的FFT，就可以用来计算四个数的FFT。这可以看成是一个分治之后向上合并的过程，并且同样是交叉运算。这个交叉运算过程就是所谓的<code>蝶形运算</code>，而我们直接从分治到最后的两个数一组，并计算每组两个数的FFT的时候，原来的序列其实就是被<code>重排序</code>了。</p></li></ol><p>详细计算过程如下：</p><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21-01-14/fft-hand-1.PNG" alt=""></p><p>因此序列[1, 2, 3, 4]的FFT结果就是[10, -2+2j, -2, -2-2j]</p><p>至此，可以手算一维的FFT了</p><h3 id="手算二维FFT"><a href="#手算二维FFT" class="headerlink" title="手算二维FFT"></a>手算二维FFT</h3><p>二维的FFT就是先对矩阵每行进行一维FFT，得到新的矩阵之后再对每一列进行一维FFT</p><p>也就是说，对于一个4x4的矩阵，进行二维FFT，共需要计算8次一维的FFT</p><p>举个最简单的例子，</p><script type="math/tex; mode=display">\begin{bmatrix}1 & 2 \\ 3 & 4\end{bmatrix}</script><p>用上面计算两个数的FFT时的结论：两个数一加一减就是一维的FFT结果。可以很快计算出这个矩阵的经过每行FFT之后：</p><script type="math/tex; mode=display">\begin{bmatrix}3 & -1 \\ 7 & -1\end{bmatrix}</script><p>再经过每列FFT之后：</p><script type="math/tex; mode=display">\begin{bmatrix}10 & -2 \\ -4 & 0\end{bmatrix}</script><p>这个结果可以用MATLAB进行验证：</p><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21-01-14/fft-hand-2.PNG" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>高斯平滑和中值滤波</title>
      <link href="posts/98e02c5c/"/>
      <url>posts/98e02c5c/</url>
      
        <content type="html"><![CDATA[<h3 id="高斯平滑"><a href="#高斯平滑" class="headerlink" title="高斯平滑"></a>高斯平滑</h3><p>可以认为是使用高斯模板加权的均值滤波。(<a href="https://www.jianshu.com/p/73e6ccbd8f3f">关于高斯模板</a>)</p><p>这里使用3x3的模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">uchar <span class="hljs-title">GetMean</span><span class="hljs-params">(uchar* image, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">double</span> gray =<br><span class="hljs-number">0.0947416</span> * image[(r - <span class="hljs-number">1</span>) * width + c - <span class="hljs-number">1</span>] +<br><span class="hljs-number">0.118318</span>  * image[(r - <span class="hljs-number">1</span>) * width + c] +<br><span class="hljs-number">0.0947416</span> * image[(r - <span class="hljs-number">1</span>) * width + c + <span class="hljs-number">1</span>] +<br><br><span class="hljs-number">0.118318</span> * image[r * width + c - <span class="hljs-number">1</span>] +<br><span class="hljs-number">0.147761</span> * image[r * width + c] +<br><span class="hljs-number">0.118318</span> * image[r * width + c + <span class="hljs-number">1</span>] +<br><br><span class="hljs-number">0.0947416</span> * image[(r + <span class="hljs-number">1</span>) * width + c - <span class="hljs-number">1</span>] +<br><span class="hljs-number">0.118318</span>  * image[(r + <span class="hljs-number">1</span>) * width + c] +<br><span class="hljs-number">0.0947416</span> * image[(r + <span class="hljs-number">1</span>) * width + c + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">return</span> (uchar)gray;<br>&#125;<br></code></pre></td></tr></table></figure><p>对256色BMP灰度图进行处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> height = m_dib-&gt;m_height;<br><span class="hljs-keyword">int</span> width = m_dib-&gt;m_width;<br>uchar* image = m_dib-&gt;m_BMPdata;<br>uchar* newImage = <span class="hljs-keyword">new</span> uchar[height * width];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i&#123; <span class="hljs-number">1</span> &#125;; i &lt; height - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j&#123; <span class="hljs-number">1</span> &#125;; j &lt; width - <span class="hljs-number">1</span>; j++) &#123;<br>        newImage[width * i + j] = GetMean(image, width, height, i, j);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 边缘直接赋值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : &#123;<span class="hljs-number">0</span>, height - <span class="hljs-number">1</span>&#125;) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j&#123; <span class="hljs-number">0</span> &#125;; j &lt; width - <span class="hljs-number">1</span>; j++) &#123;<br>        newImage[width * i + j] = image[width * i + j];<br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j : &#123;<span class="hljs-number">0</span>, width - <span class="hljs-number">1</span>&#125;) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i&#123; <span class="hljs-number">0</span> &#125;; i &lt; height - <span class="hljs-number">1</span>; i++) &#123;<br>        newImage[width * i + j] = image[width * i + j];<br>    &#125;<br>&#125;<br><br>m_dib-&gt;m_BMPdata = newImage;<br></code></pre></td></tr></table></figure><h3 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 返回数组的中值</span><br><span class="hljs-function">uchar <span class="hljs-title">GetMid</span><span class="hljs-params">(<span class="hljs-keyword">const</span> uchar* arr, <span class="hljs-keyword">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>uchar res&#123; arr[<span class="hljs-number">0</span>] &#125;;<br><span class="hljs-comment">// 计数法快速求中值</span><br><span class="hljs-keyword">int</span> count[<span class="hljs-number">256</span>]&#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i&#123; <span class="hljs-number">0</span> &#125;; i &lt; len; i++) &#123;<br>count[(<span class="hljs-keyword">int</span>)arr[i]]++;<br>&#125;<br><span class="hljs-keyword">int</span> mid = len / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> cnt&#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i&#123; <span class="hljs-number">0</span> &#125;; i &lt; <span class="hljs-number">256</span>; i++) &#123;<br>cnt += count[i];<br><span class="hljs-keyword">if</span> (cnt &gt;= mid) &#123;<br>res = i;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// 3x3的中值</span><br><span class="hljs-function">uchar <span class="hljs-title">GetMid</span><span class="hljs-params">(<span class="hljs-keyword">const</span> uchar* image, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    uchar tmp[<span class="hljs-number">9</span>] = &#123;<br>        image[(r - <span class="hljs-number">1</span>) * width + c - <span class="hljs-number">1</span>],<br>        image[(r - <span class="hljs-number">1</span>) * width + c],<br>        image[(r - <span class="hljs-number">1</span>) * width + c + <span class="hljs-number">1</span>],<br><br>        image[r * width + c - <span class="hljs-number">1</span>],<br>        image[r * width + c],<br>        image[r * width + c + <span class="hljs-number">1</span>],<br><br>        image[(r + <span class="hljs-number">1</span>) * width + c - <span class="hljs-number">1</span>],<br>        image[(r + <span class="hljs-number">1</span>) * width + c],<br>        image[(r + <span class="hljs-number">1</span>) * width + c + <span class="hljs-number">1</span>]<br>    &#125;;<br>    <span class="hljs-keyword">return</span> GetMid(tmp, <span class="hljs-number">9</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>对256色灰度图像进行处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i&#123; <span class="hljs-number">2</span> &#125;; i &lt; height - <span class="hljs-number">2</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j&#123; <span class="hljs-number">2</span> &#125;; j &lt; width - <span class="hljs-number">2</span>; j++) &#123;<br>        newImage[width * i + j] = GetMid(image, width, height, i, j);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 边缘直接赋值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, height - <span class="hljs-number">2</span>, height - <span class="hljs-number">1</span>&#125;) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j&#123; <span class="hljs-number">0</span> &#125;; j &lt; width; j++) &#123;<br>        newImage[width * i + j] = image[width * i + j];<br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j : &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, width - <span class="hljs-number">2</span>, width - <span class="hljs-number">1</span>&#125;) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i&#123; <span class="hljs-number">0</span> &#125;; i &lt; height; i++) &#123;<br>        newImage[width * i + j] = image[width * i + j];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 滤波 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读取 &amp; 显示BMP图像</title>
      <link href="posts/960ebb34/"/>
      <url>posts/960ebb34/</url>
      
        <content type="html"><![CDATA[<h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><h3 id="定义DIB类"><a href="#定义DIB类" class="headerlink" title="定义DIB类"></a>定义DIB类</h3><p>BMP文件中依次为文件头、位图信息头、调色板</p><h4 id="DIB-h"><a href="#DIB-h" class="headerlink" title="DIB.h"></a>DIB.h</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><br><span class="hljs-comment">// MFC框架</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;framework.h&quot;</span></span><br><br><span class="hljs-comment">// 保证两字节对齐（否则默认四字节对齐）</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> pack(2)</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BMPFileHeader</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-comment">// 定义BMP文件头</span><br>WORD bfType;<br>DWORD bfSize;<br>WORD bfReserved1;<br>WORD bfReserved2;<br>DWORD bfOffBits;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> pack(2)</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BMPInfoHeader</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-comment">// 定义BMP信息头</span><br>DWORD biSize;<br>DWORD biWidth;<br>DWORD biHeight;<br>WORD biPlanes;<br>WORD biBitCount;<br>DWORD biCompression;<br>DWORD biSizeImage;<br>DWORD biXPelsPerMeter;<br>DWORD biYPelsPerMeter;<br>DWORD biClrUsed;<br>DWORD biClrImportant;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> pack(1)</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RGBQuad</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-comment">// 定义调色板像素格式</span><br>BYTE rgbBlue;<br>BYTE rgbGreen;<br>BYTE rgbRed;<br>BYTE rgbReserved;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DIB</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>BMPFileHeader m_BMPfileheader;  <span class="hljs-comment">// 位图的文件头</span><br>BMPInfoHeader m_BMPinfoheader;  <span class="hljs-comment">// 位图的信息头</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>* m_BMPdata;       <span class="hljs-comment">// 位图的真实图像数据</span><br>RGBQuad* m_palette;             <span class="hljs-comment">// 调色板 if has</span><br><br><span class="hljs-keyword">int</span> m_width;<br><span class="hljs-keyword">int</span> m_height;<br><span class="hljs-keyword">int</span> m_colornb; <span class="hljs-comment">// 当使用调色板时，保存调色板的颜色数量</span><br><br><span class="hljs-keyword">public</span>:<br>DIB();<br><span class="hljs-keyword">virtual</span> ~DIB();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CString&amp; fileName)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CString&amp; fileName)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Clear</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Grayscale</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="DIB-cpp"><a href="#DIB-cpp" class="headerlink" title="DIB.cpp"></a>DIB.cpp</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;pch.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;DIB.h&quot;</span></span><br><br>DIB::DIB()<br>&#123;<br>m_BMPdata = <span class="hljs-literal">NULL</span>;<br>m_palette = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br>DIB::~DIB()<br>&#123;<br>Clear();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DIB::Clear</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (m_BMPdata) &#123;<br><span class="hljs-keyword">delete</span>[] m_BMPdata;<br>m_BMPdata = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (m_palette) &#123;<br><span class="hljs-keyword">delete</span>[] m_palette;<br>m_palette = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DIB::Read</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CString&amp; fileName)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 在此处添加你的代码</span><br><span class="hljs-comment">// 读入新图像前把旧数据清空</span><br>Clear();<br><br>CFile file;<br>VERIFY(file.Open(fileName, CFile::modeRead));<br>file.Read(&amp;m_BMPfileheader, <span class="hljs-keyword">sizeof</span>(BMPFileHeader));<span class="hljs-comment">//文件头</span><br><span class="hljs-keyword">if</span> (m_BMPfileheader.bfType == <span class="hljs-number">0x4D42</span>) &#123; <span class="hljs-comment">// 是位图 (&quot;BM&quot;)</span><br>file.Read(&amp;m_BMPinfoheader, <span class="hljs-keyword">sizeof</span>(BMPInfoHeader));<span class="hljs-comment">//信息头</span><br>m_width = m_BMPinfoheader.biWidth;<br>m_height = m_BMPinfoheader.biHeight;<br><br><span class="hljs-keyword">int</span> bit = m_BMPinfoheader.biBitCount;<br><br><span class="hljs-keyword">if</span> (bit &lt;= <span class="hljs-number">16</span>) &#123;<span class="hljs-comment">//小于16位色的有调色板，真彩色没有</span><br>AfxMessageBox(_T(<span class="hljs-string">&quot;Used palette&quot;</span>));<br>m_colornb = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (m_BMPinfoheader.biClrUsed == <span class="hljs-number">0</span>)<br>m_colornb = (<span class="hljs-number">1</span> &lt;&lt; bit);<span class="hljs-comment">// 2^(bitCount)</span><br><span class="hljs-keyword">else</span><br>m_colornb = m_BMPinfoheader.biClrUsed;<br><br>m_palette = <span class="hljs-keyword">new</span> RGBQuad[m_colornb];<br>file.Read(m_palette, <span class="hljs-keyword">sizeof</span>(RGBQuad) * m_colornb); <span class="hljs-comment">//调色板</span><br>&#125;<br><br><span class="hljs-comment">// 读取真实图像数据</span><br>file.Seek(m_BMPfileheader.bfOffBits, CFile::begin);<br><span class="hljs-comment">// 有些图像中额size是0，要手动计算大小</span><br><span class="hljs-comment">/*if (m_BMPinfoheader.biSizeImage == 0) &#123;</span><br><span class="hljs-comment">AfxMessageBox(_T(&quot;size zero!!&quot;));</span><br><span class="hljs-comment">m_BMPinfoheader.biSizeImage = m_width * m_height * bit / 8;</span><br><span class="hljs-comment">&#125;*/</span><br>m_BMPdata = <span class="hljs-keyword">new</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>[m_BMPinfoheader.biSizeImage]; <span class="hljs-comment">//图像数据</span><br>file.Read(m_BMPdata, m_BMPinfoheader.biSizeImage);<br>file.Close();<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>file.Close();<br>AfxMessageBox(_T(<span class="hljs-string">&quot;Not a bmp image!&quot;</span>));<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DIB::Write</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CString&amp; fileName)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 在此处添加你的代码</span><br>CFile BMPFile;<br>VERIFY(BMPFile.Open(fileName, CFile::modeCreate | CFile::modeWrite));<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">// 写文件头</span><br>BMPFile.Write(&amp;m_BMPfileheader, <span class="hljs-keyword">sizeof</span>(BMPFileHeader));<br><span class="hljs-comment">// 写信息头</span><br>BMPFile.Write(&amp;m_BMPinfoheader, <span class="hljs-keyword">sizeof</span>(BMPInfoHeader));<br><span class="hljs-comment">// 如果有调色板，写入调色板</span><br><span class="hljs-keyword">if</span> (m_palette != <span class="hljs-literal">NULL</span>)<br>BMPFile.Write(m_palette, <span class="hljs-keyword">sizeof</span>(RGBQuad) * m_colornb);<br><span class="hljs-comment">// 写图像数据</span><br>BMPFile.Write(m_BMPdata, m_BMPinfoheader.biSizeImage);<br>&#125;<br><span class="hljs-keyword">catch</span> (CException * pe)&#123;<br>pe-&gt;Delete();<br>AfxMessageBox(_T(<span class="hljs-string">&quot;write error&quot;</span>));<br>BMPFile.Close();<br><span class="hljs-keyword">return</span>;<br>&#125;<br>BMPFile.Close();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DIB::Grayscale</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m_height; j++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_width; i++) &#123;<br><span class="hljs-keyword">int</span> index = j * m_width + i;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> r = m_BMPdata[<span class="hljs-number">3</span> * index];<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> g = m_BMPdata[<span class="hljs-number">3</span> * index + <span class="hljs-number">1</span>];<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> b = m_BMPdata[<span class="hljs-number">3</span> * index + <span class="hljs-number">2</span>];<br><br><span class="hljs-keyword">unsigned</span> gray = (r * <span class="hljs-number">0.299</span> + g * <span class="hljs-number">0.587</span> + b * <span class="hljs-number">0.114</span>);<br>m_BMPdata[<span class="hljs-number">3</span> * index] = gray;<br>m_BMPdata[<span class="hljs-number">3</span> * index + <span class="hljs-number">1</span>] = gray;<br>m_BMPdata[<span class="hljs-number">3</span> * index + <span class="hljs-number">2</span>] = gray;<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在<code>&#123;项目名&#125;View.h</code>中添加类成员<code>DIB* m_dib</code>，并<code>using uchar = unsigned char</code></p><p>在<code>&#123;项目名&#125;View.cpp</code>中修改<code>OnFileOpen</code>，添加读取代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">CFileDialog <span class="hljs-title">dlg</span><span class="hljs-params">(TRUE)</span></span>; <span class="hljs-comment">// 读取任何文件</span><br><span class="hljs-keyword">if</span> (dlg.DoModal() == IDOK) &#123;<br>    bitmapPath = dlg.GetPathName();  <span class="hljs-comment">// 获取文件完整路径</span><br>    m_dib = <span class="hljs-keyword">new</span> DIB; <br>    m_dib-&gt;Read(bitmapPath);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h2><p>在<code>&#123;项目名&#125;View.cpp</code>中修改<code>OnDraw</code>，添加绘制代码</p><h3 id="逐像素绘制"><a href="#逐像素绘制" class="headerlink" title="逐像素绘制"></a>逐像素绘制</h3><p>这里只考虑24位真彩色位图</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++">uchar* image = m_dib-&gt;m_BMPdata;<br><span class="hljs-keyword">int</span> height = m_dib-&gt;m_height;<br><span class="hljs-keyword">int</span> width = m_dib-&gt;m_width;<br><span class="hljs-keyword">int</span> width3 = width * <span class="hljs-number">3</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; height; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; width; j++) &#123;<br>        <span class="hljs-comment">// 每个像素依次保存的是b、g、r，各一个字节</span><br>        uchar* pos = image + width3 * i + j * <span class="hljs-number">3</span>;<br>        uchar b = *pos; pos++; <br>        uchar g = *pos; pos++;<br>        uchar r = *pos;<br>        <span class="hljs-comment">// 整个位图数据中先保存的是最后一行，要手动翻转</span><br>        pDC-&gt;SetPixelV(<span class="hljs-number">10</span> + j, <span class="hljs-number">10</span> + height - i, RGB(r, g, b)); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="调用MFC接口显示"><a href="#调用MFC接口显示" class="headerlink" title="调用MFC接口显示"></a>调用MFC接口显示</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//定义bitmap指针 调用函数LoadImage装载位图</span><br>HBITMAP m_hBitmap;<br>m_hBitmap = (HBITMAP)LoadImage(<span class="hljs-literal">NULL</span>, bitMapPath, IMAGE_BITMAP, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, LR_LOADFROMFILE | LR_DEFAULTSIZE | LR_CREATEDIBSECTION);<br><br><span class="hljs-keyword">if</span> (m_bitmap.m_hObject) &#123;<br>    m_bitmap.Detach();           <span class="hljs-comment">//切断CWnd和窗口联系</span><br>&#125;<br>m_bitmap.Attach(m_hBitmap);      <span class="hljs-comment">//将句柄HBITMAP m_hBitmap与CBitmap m_bitmap关联</span><br><br><span class="hljs-comment">//边界</span><br>CRect rect;<br>GetClientRect(&amp;rect);<br><br><span class="hljs-comment">//图片显示(x,y)起始坐标</span><br><span class="hljs-keyword">int</span> m_showX = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> m_showY = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> m_nWindowWidth = rect.right - rect.left;   <span class="hljs-comment">//计算客户区宽度</span><br><span class="hljs-keyword">int</span> m_nWindowHeight = rect.bottom - rect.top;  <span class="hljs-comment">//计算客户区高度</span><br><br><span class="hljs-comment">//定义并创建一个内存设备环境DC</span><br>CDC dcBmp;<br><span class="hljs-keyword">if</span> (!dcBmp.CreateCompatibleDC(pDC))   <span class="hljs-comment">//创建兼容性的DC</span><br>    <span class="hljs-keyword">return</span>;<br><br>BITMAP m_bmp;                          <span class="hljs-comment">//临时bmp图片变量</span><br>m_bitmap.GetBitmap(&amp;m_bmp);            <span class="hljs-comment">//将图片载入位图中</span><br><br>CBitmap* pbmpOld = <span class="hljs-literal">NULL</span>;<br>dcBmp.SelectObject(&amp;m_bitmap);         <span class="hljs-comment">//将位图选入临时内存设备环境</span><br><br><span class="hljs-comment">//图片显示调用函数stretchBlt</span><br>pDC-&gt;StretchBlt(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, m_bmp.bmWidth, m_bmp.bmHeight, &amp;dcBmp, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, m_bmp.bmWidth, m_bmp.bmHeight, SRCCOPY);<br><br>dcBmp.SelectObject(pbmpOld);           <span class="hljs-comment">//恢复临时DC的位图</span><br>DeleteObject(&amp;m_bitmap);               <span class="hljs-comment">//删除内存中的位图</span><br>dcBmp.DeleteDC();                      <span class="hljs-comment">//删除CreateCompatibleDC得到的图片DC</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像二维FFT</title>
      <link href="posts/19f48cd5/"/>
      <url>posts/19f48cd5/</url>
      
        <content type="html"><![CDATA[<h3 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PI 3.1415926</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-keyword">double</span> real;<br><span class="hljs-keyword">double</span> imag;<br>&#125;<span class="hljs-built_in">complex</span>;<br><br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>;<br><span class="hljs-keyword">using</span> uchar = <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>;<br><span class="hljs-keyword">using</span> Complex1D = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">complex</span>&gt;;<br><span class="hljs-keyword">using</span> Complex2D = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">complex</span>&gt;&gt;;<br><span class="hljs-keyword">using</span> Double1D = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;;<br><span class="hljs-keyword">using</span> Double2D = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;&gt;;<br></code></pre></td></tr></table></figure><h3 id="复数运算及相关工具函数"><a href="#复数运算及相关工具函数" class="headerlink" title="复数运算及相关工具函数"></a>复数运算及相关工具函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// a * b</span><br><span class="hljs-function"><span class="hljs-built_in">complex</span> <span class="hljs-title">Mul</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">complex</span>&amp; a, <span class="hljs-keyword">const</span> <span class="hljs-built_in">complex</span>&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">complex</span> res;<br>res.real = a.real * b.real - a.imag * b.imag;<br>res.imag = a.imag * b.real + a.real * b.imag;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// a + b</span><br><span class="hljs-function"><span class="hljs-built_in">complex</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">complex</span>&amp; a, <span class="hljs-keyword">const</span> <span class="hljs-built_in">complex</span>&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">complex</span>&#123; a.real + b.real, a.imag + b.imag &#125;;<br>&#125;<br><br><span class="hljs-comment">// a - b</span><br><span class="hljs-function"><span class="hljs-built_in">complex</span> <span class="hljs-title">Sub</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">complex</span>&amp; a, <span class="hljs-keyword">const</span> <span class="hljs-built_in">complex</span>&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">complex</span>&#123; a.real - b.real, a.imag - b.imag &#125;;<br>&#125;<br><br><span class="hljs-comment">// e^(ix)</span><br><span class="hljs-function"><span class="hljs-built_in">complex</span> <span class="hljs-title">Euler</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span>&amp; x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">complex</span>&#123; <span class="hljs-built_in">cos</span>(x), <span class="hljs-built_in">sin</span>(x) &#125;;<br>&#125;<br><br><span class="hljs-comment">// |a|</span><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Magnitude</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">complex</span>&amp; a)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(a.real * a.real + a.imag * a.imag);<br>&#125;<br><br><span class="hljs-comment">// 二维复数矩阵转置</span><br><span class="hljs-function">Complex2D <span class="hljs-title">Transform</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Complex2D&amp; a)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Complex2D <span class="hljs-title">res</span><span class="hljs-params">(a)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i&#123; <span class="hljs-number">0</span> &#125;; i &lt; a.size(); i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j&#123; <span class="hljs-number">0</span> &#125;; j &lt; a[i].size(); j++) &#123;<br>res[i][j] = a[j][i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// 二维频谱图平移(一、三象限对换，二、四象限对换)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Shift</span><span class="hljs-params">(Complex2D&amp; src)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Complex2D <span class="hljs-title">tmp</span><span class="hljs-params">(src)</span></span>;<br><span class="hljs-keyword">int</span> height = src.size();<br><span class="hljs-keyword">int</span> width = src[<span class="hljs-number">0</span>].size();<br><span class="hljs-keyword">int</span> width_2 = width / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">int</span> height_2 = height / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i&#123; <span class="hljs-number">0</span> &#125;; i &lt; height; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j&#123; <span class="hljs-number">0</span> &#125;; j &lt; width; j++) &#123;<br><span class="hljs-keyword">int</span> i1, j1;<br><span class="hljs-keyword">if</span> (i &lt; height_2)<br>i1 = i + height_2;<br><span class="hljs-keyword">else</span> <br>i1 = i - height_2;<br><span class="hljs-keyword">if</span> (j &lt; width_2)<br>j1 = j + width_2;<br><span class="hljs-keyword">else</span> <br>j1 = j - width_2;<br>tmp[i1][j1] = src[i][j];<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i&#123; <span class="hljs-number">0</span> &#125;; i &lt; width; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j&#123; <span class="hljs-number">0</span> &#125;; j &lt; height; j++) &#123;<br>src[i][j] = tmp[i][j];<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 返回最近（不小于）num的2的幂</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetClosest2Power</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> e = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (e &lt; num) &#123;<br>e &lt;&lt;= <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> e;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="一维FFT"><a href="#一维FFT" class="headerlink" title="一维FFT"></a>一维FFT</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 一维的处理过程</span><br><span class="hljs-comment">// flag=1 IFFT</span><br><span class="hljs-comment">// flag=-1 FFT</span><br><span class="hljs-function">Complex1D <span class="hljs-title">FFTProgress1D</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Complex1D&amp; src, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">int</span> flag)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 递归出口</span><br><span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">return</span> Complex1D&#123; src &#125;;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len == <span class="hljs-number">2</span>) &#123;<br><span class="hljs-keyword">return</span> Complex1D&#123;<br>Add(src[<span class="hljs-number">0</span>], src[<span class="hljs-number">1</span>]), Sub(src[<span class="hljs-number">0</span>], src[<span class="hljs-number">1</span>])<br>&#125;;<br>&#125;<br><br><span class="hljs-keyword">int</span> len_2 = len / <span class="hljs-number">2</span>;<br><span class="hljs-function">Complex1D <span class="hljs-title">a</span><span class="hljs-params">(len_2)</span></span>;<br><span class="hljs-function">Complex1D <span class="hljs-title">b</span><span class="hljs-params">(len_2)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i&#123; <span class="hljs-number">0</span> &#125;; i &lt; len_2; i++) &#123;<br>a[i] = src[<span class="hljs-number">2</span> * i];      <span class="hljs-comment">// 偶数</span><br>b[i] = src[<span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>];  <span class="hljs-comment">// 奇数</span><br>&#125;<br>    <span class="hljs-comment">// 分治</span><br>Complex1D&amp;&amp; A = FFTProgress1D(a, len_2, flag);<br>Complex1D&amp;&amp; B = FFTProgress1D(b, len_2, flag);<br><span class="hljs-function">Complex1D <span class="hljs-title">dst</span><span class="hljs-params">(len)</span></span>;<br><span class="hljs-comment">// DFT为-2PI*k/N, IDFT为2PI*k/N</span><br><span class="hljs-keyword">double</span> <span class="hljs-built_in">exp</span> = flag * <span class="hljs-number">2</span> * PI / len;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i&#123; <span class="hljs-number">0</span> &#125;; i &lt; len_2; i++) &#123;<br><span class="hljs-comment">// e^(2PI*k/N) * P(k)</span><br><span class="hljs-built_in">complex</span>&amp;&amp; tmp = Mul(Euler(<span class="hljs-built_in">exp</span> * i), B[i]);<br><span class="hljs-comment">// F(k) = G(k) + e^(2PI*k/N) * P(k)</span><br>dst[i] = Add(A[i], tmp);<br><span class="hljs-comment">// F(k+N/2) = G(k)+e^(2PI*(k+N/2)/N) * P(k+N/2)</span><br>dst[i + len_2] = Sub(A[i], tmp);<br>&#125;<br><span class="hljs-keyword">return</span> dst;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二维FFT"><a href="#二维FFT" class="headerlink" title="二维FFT"></a>二维FFT</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 二维的处理过程</span><br><span class="hljs-comment">// flag = -1 DFT</span><br><span class="hljs-comment">// flag = 1 IDFT</span><br><span class="hljs-function">Complex2D <span class="hljs-title">FFTProgress2D</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Complex2D&amp; src, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">int</span> flag)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Complex2D <span class="hljs-title">src1</span><span class="hljs-params">(src)</span></span>;<br><br><span class="hljs-comment">// 每行进行一次一维FFT</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i&#123; <span class="hljs-number">0</span> &#125;; i &lt; len; i++) &#123;<br>src1[i] = FFTProgress1D(src[i], len, flag);<br>&#125;<br><br><span class="hljs-comment">// 转置</span><br>Complex2D&amp;&amp; dst = Transform(src1);<br><br><span class="hljs-comment">// 再对每一行进行一维DFT（实际就是转置之前的每一列）</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i&#123; <span class="hljs-number">0</span> &#125;; i &lt; len; i++) &#123;<br>dst[i] = FFTProgress1D(dst[i], len, flag);<br>&#125;<br><br><span class="hljs-comment">// 再转置回来</span><br>dst = Transform(dst);<br><span class="hljs-keyword">return</span> dst;<br>&#125;<br><br><span class="hljs-function">Complex2D <span class="hljs-title">FFT2D</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Double2D&amp; src)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> row = src.size();<br><span class="hljs-keyword">int</span> column = src[<span class="hljs-number">0</span>].size();<br><br><span class="hljs-comment">// 扩展到2的幂次</span><br><span class="hljs-keyword">int</span> len = GetClosest2Power(row &gt; column ? row : column);<br><span class="hljs-function">Complex2D <span class="hljs-title">src1</span><span class="hljs-params">(len)</span></span>;<br><br><span class="hljs-comment">// 并用0填充</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i&#123; <span class="hljs-number">0</span> &#125;; i &lt; len; i++) &#123;<br>src1[i].resize(len);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j&#123; <span class="hljs-number">0</span> &#125;; j &lt; len; j++) &#123;<br>src1[i][j].imag = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (i &lt; row &amp;&amp; j &lt; column) &#123;<br>src1[i][j].real = src[i][j];<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>src1[i][j].real = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 进入计算过程</span><br><span class="hljs-keyword">return</span> FFTProgress2D(src1, len, <span class="hljs-number">-1</span>);<br>&#125;<br><br><span class="hljs-function">Double2D <span class="hljs-title">IFFT2D</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Complex2D&amp; src, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">int</span> realRow, <span class="hljs-keyword">int</span> realColumn)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> size = len * len;<br>Complex2D&amp;&amp; src1 = FFTProgress2D(src, len, <span class="hljs-number">1</span>);<br><span class="hljs-function">Double2D <span class="hljs-title">dst</span><span class="hljs-params">(realRow)</span></span>;<br><span class="hljs-keyword">int</span> min&#123; <span class="hljs-number">255</span> &#125;, max&#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i&#123; <span class="hljs-number">0</span> &#125;; i &lt; realRow; i++) &#123;<br>dst[i].resize(realColumn);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j&#123; <span class="hljs-number">0</span> &#125;; j &lt; realColumn; j++) &#123;<br>dst[i][j] = Magnitude(src1[i][j]);<br>min = dst[i][j] &lt; min ? dst[i][j] : min;<br>max = dst[i][j] &gt; max ? dst[i][j] : max;<br>&#125;<br>&#125;<br>    <span class="hljs-comment">// 缩放处理</span><br><span class="hljs-keyword">double</span> scale = <span class="hljs-number">255.0</span> / (max - min);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; items : dst) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; item : items) &#123;<br>item = (item - min) * scale;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> dst;<br>&#125;<br><br><span class="hljs-comment">// 将FFT2D的结果转化成频谱图用于显示</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Complex2Image</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Complex2D&amp; src, uchar* image)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Complex2D <span class="hljs-title">src1</span><span class="hljs-params">(src)</span></span>;<br><span class="hljs-keyword">int</span> len = src.size();<br>Shift(src1);<br><span class="hljs-keyword">int</span>* tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len * len];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i&#123; <span class="hljs-number">0</span> &#125;; i &lt; len; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j&#123; <span class="hljs-number">0</span> &#125;; j &lt; len; j++) &#123;<br><span class="hljs-keyword">int</span> index = i * len + j;<br>tmp[index] = (<span class="hljs-keyword">int</span>)Magnitude(src1[i][j]);<br><span class="hljs-keyword">if</span> (tmp[index] &lt; <span class="hljs-number">0</span>)tmp[index] = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">// scale</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i&#123; len * len - <span class="hljs-number">1</span> &#125;; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>tmp[i] /= <span class="hljs-number">500</span>;<br>image[i] = tmp[i] &lt; <span class="hljs-number">255</span> ? tmp[i] : <span class="hljs-number">255</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">delete</span>[] tmp;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="计算BMP灰度图的频谱"><a href="#计算BMP灰度图的频谱" class="headerlink" title="计算BMP灰度图的频谱"></a>计算BMP灰度图的频谱</h3><p>对256色（一个像素占一个字节）的BMP灰度图像进行处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++">uchar* image = m_dib-&gt;m_BMPdata;<br><span class="hljs-keyword">int</span> height = m_dib-&gt;m_height;<br><span class="hljs-keyword">int</span> width = m_dib-&gt;m_width;<br><br><span class="hljs-keyword">int</span> len = GetClosest2Power(height &gt; width ? height : width);<br>uchar* newImage = <span class="hljs-keyword">new</span> uchar[len * len]&#123; <span class="hljs-number">0</span> &#125;;<br><br><span class="hljs-function">Double2D <span class="hljs-title">src</span><span class="hljs-params">(height)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i&#123; <span class="hljs-number">0</span> &#125;; i &lt; height; i++) &#123;<br>    src[i].resize(width);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j&#123; <span class="hljs-number">0</span> &#125;; j &lt; width; j++) &#123;<br>        src[i][j] = (<span class="hljs-keyword">double</span>)image[i * width + j];<br>    &#125;<br>&#125;<br>Complex2D&amp;&amp; dst = FFT2D(src);<br>Complex2Image(dst, newImage);<br><br>m_dib-&gt;m_BMPdata = newImage;<br>m_dib-&gt;m_height = len;<br>m_dib-&gt;m_width = len;<br></code></pre></td></tr></table></figure><p>平移之前的频谱图：</p><p>（将<code>Complex2Image</code>中<code>Shift</code>那行注释掉）</p><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21-01-14/fft-1.PNG" alt=""></p><p>平移之后的频谱图：</p><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21-01-14/fft-2.PNG" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> FFT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ns3分析RIP协议</title>
      <link href="posts/41871a62/"/>
      <url>posts/41871a62/</url>
      
        <content type="html"><![CDATA[<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol><li><p>构建拓扑</p><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21-01-14/ns3-1.PNG" alt=""></p></li><li><p>配置结点并运行PING</p><p>不断从PC1向PC2进行PING</p></li><li><p>构造坏消息</p><p>一定时间后将C和E之间的连接断开</p></li></ol><h3 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ns3/core-module.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ns3/internet-module.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ns3/csma-module.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ns3/internet-apps-module.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ns3/ipv4-static-routing-helper.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ns3/ipv4-routing-table-entry.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ns3/animation-interface.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ns3/netanim-module.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> ns3;<br><br>NS_LOG_COMPONENT_DEFINE (<span class="hljs-string">&quot;RipSimpleRouting&quot;</span>);<br><br><span class="hljs-comment">// 断开两个结点间的连接</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TearDownLink</span> <span class="hljs-params">(Ptr&lt;Node&gt; nodeA, Ptr&lt;Node&gt; nodeB, <span class="hljs-keyword">uint32_t</span> interfaceA, <span class="hljs-keyword">uint32_t</span> interfaceB)</span></span><br><span class="hljs-function"></span>&#123;<br>    nodeA-&gt;GetObject&lt;Ipv4&gt; ()-&gt;SetDown (interfaceA);<br>    nodeB-&gt;GetObject&lt;Ipv4&gt; ()-&gt;SetDown (interfaceB);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">bool</span> verbose = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">bool</span> printRoutingTables = <span class="hljs-literal">false</span>;                <span class="hljs-comment">// 打印路由表</span><br>    <span class="hljs-keyword">bool</span> showPings = <span class="hljs-literal">false</span>;<br>    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">SplitHorizon</span> <span class="hljs-params">(<span class="hljs-string">&quot;NoSplitHorizon&quot;</span>)</span></span>;    <span class="hljs-comment">// 水平分隔策略</span><br><br>    <span class="hljs-function">CommandLine <span class="hljs-title">cmd</span><span class="hljs-params">(__FILE__)</span></span>;<br>    cmd.AddValue (<span class="hljs-string">&quot;verbose&quot;</span>, <span class="hljs-string">&quot;turn on log components&quot;</span>, verbose);<br>    cmd.AddValue (<span class="hljs-string">&quot;printRoutingTables&quot;</span>, <span class="hljs-string">&quot;Print routing tables at 30, 60 and 90 seconds&quot;</span>, printRoutingTables);<br>    cmd.AddValue (<span class="hljs-string">&quot;showPings&quot;</span>, <span class="hljs-string">&quot;Show Ping6 reception&quot;</span>, showPings);<br>    cmd.AddValue (<span class="hljs-string">&quot;splitHorizonStrategy&quot;</span>, <span class="hljs-string">&quot;Split Horizon strategy to use (NoSplitHorizon, SplitHorizon, PoisonReverse)&quot;</span>, SplitHorizon);<br>    cmd.Parse (argc, argv);<br><br>    <span class="hljs-keyword">if</span> (verbose)<br>    &#123;<br>      LogComponentEnableAll (LogLevel (LOG_PREFIX_TIME | LOG_PREFIX_NODE));<br>      LogComponentEnable (<span class="hljs-string">&quot;RipSimpleRouting&quot;</span>, LOG_LEVEL_INFO);<br>      LogComponentEnable (<span class="hljs-string">&quot;Rip&quot;</span>, LOG_LEVEL_ALL);<br>      LogComponentEnable (<span class="hljs-string">&quot;Ipv4Interface&quot;</span>, LOG_LEVEL_ALL);<br>      LogComponentEnable (<span class="hljs-string">&quot;Icmpv4L4Protocol&quot;</span>, LOG_LEVEL_ALL);<br>      LogComponentEnable (<span class="hljs-string">&quot;Ipv4L3Protocol&quot;</span>, LOG_LEVEL_ALL);<br>      LogComponentEnable (<span class="hljs-string">&quot;ArpCache&quot;</span>, LOG_LEVEL_ALL);<br>      LogComponentEnable (<span class="hljs-string">&quot;V4Ping&quot;</span>, LOG_LEVEL_ALL);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (SplitHorizon == <span class="hljs-string">&quot;NoSplitHorizon&quot;</span>)<br>    &#123;<br>        Config::SetDefault (<span class="hljs-string">&quot;ns3::Rip::SplitHorizon&quot;</span>, EnumValue (RipNg::NO_SPLIT_HORIZON));<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (SplitHorizon == <span class="hljs-string">&quot;SplitHorizon&quot;</span>)<br>    &#123;<br>        Config::SetDefault (<span class="hljs-string">&quot;ns3::Rip::SplitHorizon&quot;</span>, EnumValue (RipNg::SPLIT_HORIZON));<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        Config::SetDefault (<span class="hljs-string">&quot;ns3::Rip::SplitHorizon&quot;</span>, EnumValue (RipNg::POISON_REVERSE));<br>    &#125;<br><br>    <span class="hljs-comment">// 创建各结点</span><br>    NS_LOG_INFO(<span class="hljs-string">&quot;Create nodes.&quot;</span>);<br>    Ptr&lt;Node&gt; pc1 = CreateObject&lt;Node&gt;();<br>    Names::Add(<span class="hljs-string">&quot;Pc1Node&quot;</span>, pc1);<br>    Ptr&lt;Node&gt; pc2 = CreateObject&lt;Node&gt;();<br>    Names::Add(<span class="hljs-string">&quot;Pc2Node&quot;</span>, pc2);<br>    Ptr&lt;Node&gt; a = CreateObject&lt;Node&gt; ();<br>    Names::Add (<span class="hljs-string">&quot;RouterA&quot;</span>, a);<br>    Ptr&lt;Node&gt; b = CreateObject&lt;Node&gt; ();<br>    Names::Add (<span class="hljs-string">&quot;RouterB&quot;</span>, b);<br>    Ptr&lt;Node&gt; c = CreateObject&lt;Node&gt; ();<br>    Names::Add (<span class="hljs-string">&quot;RouterC&quot;</span>, c);<br>    Ptr&lt;Node&gt; d = CreateObject&lt;Node&gt; ();<br>    Names::Add (<span class="hljs-string">&quot;RouterD&quot;</span>, d);<br>    Ptr&lt;Node&gt; e = CreateObject&lt;Node&gt; ();<br>    Names::Add (<span class="hljs-string">&quot;RouterE&quot;</span>, e);<br>    Ptr&lt;Node&gt; f = CreateObject&lt;Node&gt; ();<br>    Names::Add (<span class="hljs-string">&quot;RouterF&quot;</span>, f);<br>    <br>    <span class="hljs-comment">// 添加各网络连接</span><br>    <span class="hljs-function">NodeContainer <span class="hljs-title">net1</span><span class="hljs-params">(pc1, b)</span></span>;<br>    <span class="hljs-function">NodeContainer <span class="hljs-title">net2</span><span class="hljs-params">(b, c)</span></span>;<br>    <span class="hljs-function">NodeContainer <span class="hljs-title">net3</span><span class="hljs-params">(a, b)</span></span>;<br>    <span class="hljs-function">NodeContainer <span class="hljs-title">net4</span><span class="hljs-params">(a, c)</span></span>;<br>    <span class="hljs-function">NodeContainer <span class="hljs-title">net5</span><span class="hljs-params">(a, d)</span></span>;<br>    <span class="hljs-function">NodeContainer <span class="hljs-title">net6</span><span class="hljs-params">(d, e)</span></span>;<br>    <span class="hljs-function">NodeContainer <span class="hljs-title">net7</span><span class="hljs-params">(c, e)</span></span>;<br>    <span class="hljs-function">NodeContainer <span class="hljs-title">net8</span><span class="hljs-params">(e, f)</span></span>;<br>    <span class="hljs-function">NodeContainer <span class="hljs-title">net9</span><span class="hljs-params">(f, pc2)</span></span>;<br>    <span class="hljs-function">NodeContainer <span class="hljs-title">routers</span><span class="hljs-params">(a, b, c, d, e)</span></span>;<br>    routers.Add(f);<br>    <span class="hljs-function">NodeContainer <span class="hljs-title">nodes</span><span class="hljs-params">(pc1, pc2)</span></span>;<br><br>    NS_LOG_INFO(<span class="hljs-string">&quot;Create channels.&quot;</span>);<br>    CsmaHelper csma;<br>    csma.SetChannelAttribute (<span class="hljs-string">&quot;DataRate&quot;</span>, DataRateValue (<span class="hljs-number">5000000</span>));<br>    csma.SetChannelAttribute (<span class="hljs-string">&quot;Delay&quot;</span>, TimeValue (MilliSeconds (<span class="hljs-number">2</span>)));<br>    NetDeviceContainer ndc1 = csma.Install (net1);<br>    NetDeviceContainer ndc2 = csma.Install (net2);<br>    NetDeviceContainer ndc3 = csma.Install (net3);<br>    NetDeviceContainer ndc4 = csma.Install (net4);<br>    NetDeviceContainer ndc5 = csma.Install (net5);<br>    NetDeviceContainer ndc6 = csma.Install (net6);<br>    NetDeviceContainer ndc7 = csma.Install (net7);<br>    NetDeviceContainer ndc8 = csma.Install (net8);<br>    NetDeviceContainer ndc9 = csma.Install (net9);<br><br>    NS_LOG_INFO(<span class="hljs-string">&quot;Create IPv4 and routing&quot;</span>);<br>    RipHelper ripRouting;<br>    <span class="hljs-comment">// 路由器B和F与主机PC1和PC2相连的接口不参与RIP报文交换</span><br>    ripRouting.ExcludeInterface(b, <span class="hljs-number">1</span>);<br>    ripRouting.ExcludeInterface(f, <span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// 设置接口度量值</span><br>    ripRouting.SetInterfaceMetric(b, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>    ripRouting.SetInterfaceMetric(c, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>    ripRouting.SetInterfaceMetric(a, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>);<br>    ripRouting.SetInterfaceMetric(c, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>);<br>    ripRouting.SetInterfaceMetric(d, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>);<br>    ripRouting.SetInterfaceMetric(e, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>);<br>    ripRouting.SetInterfaceMetric(c, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br>    ripRouting.SetInterfaceMetric(e, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>    ripRouting.SetInterfaceMetric(e, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>);<br>    ripRouting.SetInterfaceMetric(f, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><br>    Ipv4ListRoutingHelper listRH;<br>    listRH.Add(ripRouting, <span class="hljs-number">0</span>);<br><br>    InternetStackHelper internet;<br>    internet.SetIpv6StackInstall(<span class="hljs-literal">false</span>);<br>    internet.SetRoutingHelper(listRH);<br>    internet.Install(routers);<br><br>    InternetStackHelper internetNodes;<br>    internetNodes.SetIpv6StackInstall(<span class="hljs-literal">false</span>);<br>    internetNodes.Install(nodes);<br><br>    <span class="hljs-comment">// 分配IP地址，设置网络掩码</span><br>    NS_LOG_INFO(<span class="hljs-string">&quot;Assign IPv4 Addresses.&quot;</span>);<br>    Ipv4AddressHelper ipv4;<br><br>    ipv4.SetBase(Ipv4Address(<span class="hljs-string">&quot;10.0.0.0&quot;</span>), Ipv4Mask(<span class="hljs-string">&quot;255.255.255.0&quot;</span>));<br>    Ipv4InterfaceContainer iic1 = ipv4.Assign(ndc1);<br><br>    ipv4.SetBase(Ipv4Address(<span class="hljs-string">&quot;10.0.1.0&quot;</span>), Ipv4Mask(<span class="hljs-string">&quot;255.255.255.0&quot;</span>));<br>    Ipv4InterfaceContainer iic2 = ipv4.Assign(ndc2);<br><br>    ipv4.SetBase(Ipv4Address(<span class="hljs-string">&quot;10.0.2.0&quot;</span>), Ipv4Mask(<span class="hljs-string">&quot;255.255.255.0&quot;</span>));<br>    Ipv4InterfaceContainer iic3 = ipv4.Assign(ndc3);<br><br>    ipv4.SetBase(Ipv4Address(<span class="hljs-string">&quot;10.0.3.0&quot;</span>), Ipv4Mask(<span class="hljs-string">&quot;255.255.255.0&quot;</span>));<br>    Ipv4InterfaceContainer iic4 = ipv4.Assign(ndc4);<br><br>    ipv4.SetBase(Ipv4Address(<span class="hljs-string">&quot;10.0.4.0&quot;</span>), Ipv4Mask(<span class="hljs-string">&quot;255.255.255.0&quot;</span>));<br>    Ipv4InterfaceContainer iic5 = ipv4.Assign(ndc5);<br><br>    ipv4.SetBase(Ipv4Address(<span class="hljs-string">&quot;10.0.5.0&quot;</span>), Ipv4Mask(<span class="hljs-string">&quot;255.255.255.0&quot;</span>));<br>    Ipv4InterfaceContainer iic6 = ipv4.Assign(ndc6);<br><br>    ipv4.SetBase(Ipv4Address(<span class="hljs-string">&quot;10.0.6.0&quot;</span>), Ipv4Mask(<span class="hljs-string">&quot;255.255.255.0&quot;</span>));<br>    Ipv4InterfaceContainer iic7 = ipv4.Assign(ndc7);<br><br>    ipv4.SetBase(Ipv4Address(<span class="hljs-string">&quot;10.0.7.0&quot;</span>), Ipv4Mask(<span class="hljs-string">&quot;255.255.255.0&quot;</span>));<br>    Ipv4InterfaceContainer iic8 = ipv4.Assign(ndc8);<br><br>    ipv4.SetBase(Ipv4Address(<span class="hljs-string">&quot;10.0.8.0&quot;</span>), Ipv4Mask(<span class="hljs-string">&quot;255.255.255.0&quot;</span>));<br>    Ipv4InterfaceContainer iic9 = ipv4.Assign(ndc9);<br><br>    Ptr&lt;Ipv4StaticRouting&gt; staticRouting;<br>    staticRouting = Ipv4RoutingHelper::GetRouting&lt;Ipv4StaticRouting&gt;(pc1-&gt;GetObject&lt;Ipv4&gt;()-&gt;GetRoutingProtocol());<br>    staticRouting-&gt;SetDefaultRoute(<span class="hljs-string">&quot;10.0.0.2&quot;</span>, <span class="hljs-number">1</span>);<br>    staticRouting = Ipv4RoutingHelper::GetRouting&lt;Ipv4StaticRouting&gt;(pc2-&gt;GetObject&lt;Ipv4&gt;()-&gt;GetRoutingProtocol());<br>    staticRouting-&gt;SetDefaultRoute(<span class="hljs-string">&quot;10.0.8.1&quot;</span>, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 打印路由表</span><br>    <span class="hljs-keyword">if</span> (printRoutingTables)<br>    &#123;<br>        RipHelper routingHelper;<br>        Ptr&lt;OutputStreamWrapper&gt; routingStream = Create&lt;OutputStreamWrapper&gt; (&amp;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>);<br>        routingHelper.PrintRoutingTableAt (Seconds (<span class="hljs-number">2.0</span>), a, routingStream);<br>        routingHelper.PrintRoutingTableAt (Seconds (<span class="hljs-number">2.0</span>), b, routingStream);<br>        routingHelper.PrintRoutingTableAt (Seconds (<span class="hljs-number">2.0</span>), c, routingStream);<br>        routingHelper.PrintRoutingTableAt (Seconds (<span class="hljs-number">2.0</span>), d, routingStream);<br>        routingHelper.PrintRoutingTableAt (Seconds (<span class="hljs-number">2.0</span>), e, routingStream);<br>        routingHelper.PrintRoutingTableAt (Seconds (<span class="hljs-number">2.0</span>), f, routingStream);<br><br>        routingHelper.PrintRoutingTableAt (Seconds (<span class="hljs-number">3.0</span>), a, routingStream);<br>        routingHelper.PrintRoutingTableAt (Seconds (<span class="hljs-number">3.0</span>), b, routingStream);<br>        routingHelper.PrintRoutingTableAt (Seconds (<span class="hljs-number">3.0</span>), c, routingStream);<br>        routingHelper.PrintRoutingTableAt (Seconds (<span class="hljs-number">3.0</span>), d, routingStream);<br>        routingHelper.PrintRoutingTableAt (Seconds (<span class="hljs-number">3.0</span>), e, routingStream);<br>        routingHelper.PrintRoutingTableAt (Seconds (<span class="hljs-number">3.0</span>), f, routingStream);<br><br>        routingHelper.PrintRoutingTableAt (Seconds (<span class="hljs-number">4.0</span>), a, routingStream);<br>        routingHelper.PrintRoutingTableAt (Seconds (<span class="hljs-number">4.0</span>), b, routingStream);<br>        routingHelper.PrintRoutingTableAt (Seconds (<span class="hljs-number">4.0</span>), c, routingStream);<br>        routingHelper.PrintRoutingTableAt (Seconds (<span class="hljs-number">4.0</span>), d, routingStream);<br>        routingHelper.PrintRoutingTableAt (Seconds (<span class="hljs-number">4.0</span>), e, routingStream);<br>        routingHelper.PrintRoutingTableAt (Seconds (<span class="hljs-number">4.0</span>), f, routingStream);<br><br>        routingHelper.PrintRoutingTableAt (Seconds (<span class="hljs-number">5.0</span>), a, routingStream);<br>        routingHelper.PrintRoutingTableAt (Seconds (<span class="hljs-number">5.0</span>), b, routingStream);<br>        routingHelper.PrintRoutingTableAt (Seconds (<span class="hljs-number">5.0</span>), c, routingStream);<br>        routingHelper.PrintRoutingTableAt (Seconds (<span class="hljs-number">5.0</span>), d, routingStream);<br>        routingHelper.PrintRoutingTableAt (Seconds (<span class="hljs-number">5.0</span>), e, routingStream);<br>        routingHelper.PrintRoutingTableAt (Seconds (<span class="hljs-number">5.0</span>), f, routingStream);<br><br>        routingHelper.PrintRoutingTableAt (Seconds (<span class="hljs-number">6.0</span>), a, routingStream);<br>        routingHelper.PrintRoutingTableAt (Seconds (<span class="hljs-number">6.0</span>), b, routingStream);<br>        routingHelper.PrintRoutingTableAt (Seconds (<span class="hljs-number">6.0</span>), c, routingStream);<br>        routingHelper.PrintRoutingTableAt (Seconds (<span class="hljs-number">6.0</span>), d, routingStream);<br>        routingHelper.PrintRoutingTableAt (Seconds (<span class="hljs-number">6.0</span>), e, routingStream);<br>        routingHelper.PrintRoutingTableAt (Seconds (<span class="hljs-number">6.0</span>), f, routingStream);<br><br>        routingHelper.PrintRoutingTableAt (Seconds (<span class="hljs-number">7.0</span>), a, routingStream);<br>        routingHelper.PrintRoutingTableAt (Seconds (<span class="hljs-number">7.0</span>), b, routingStream);<br>        routingHelper.PrintRoutingTableAt (Seconds (<span class="hljs-number">7.0</span>), c, routingStream);<br>        routingHelper.PrintRoutingTableAt (Seconds (<span class="hljs-number">7.0</span>), d, routingStream);<br>        routingHelper.PrintRoutingTableAt (Seconds (<span class="hljs-number">7.0</span>), e, routingStream);<br>        routingHelper.PrintRoutingTableAt (Seconds (<span class="hljs-number">7.0</span>), f, routingStream);<br>    &#125;<br><br>    NS_LOG_INFO(<span class="hljs-string">&quot;Create Applications.&quot;</span>);<br>    <span class="hljs-keyword">uint32_t</span> packetSize = <span class="hljs-number">1024</span>;<br>    Time interPacketInterval = Seconds(<span class="hljs-number">1.0</span>);<br>    <span class="hljs-comment">// ping的远程IP is 10.0.8.2 (pc2所在网络)</span><br>    <span class="hljs-function">V4PingHelper <span class="hljs-title">ping</span><span class="hljs-params">(<span class="hljs-string">&quot;10.0.8.2&quot;</span>)</span></span>;<br><br>    ping.SetAttribute (<span class="hljs-string">&quot;Interval&quot;</span>, TimeValue (interPacketInterval));<br>    ping.SetAttribute (<span class="hljs-string">&quot;Size&quot;</span>, UintegerValue (packetSize));<br>    <span class="hljs-keyword">if</span> (showPings)<br>    &#123;<br>        ping.SetAttribute (<span class="hljs-string">&quot;Verbose&quot;</span>, BooleanValue (<span class="hljs-literal">true</span>));<br>    &#125;<br>    <span class="hljs-comment">// ping的发起者pc1</span><br>    ApplicationContainer apps = ping.Install(pc1);<br>    apps.Start(Seconds(<span class="hljs-number">1.0</span>));<br>    apps.Stop(Seconds(<span class="hljs-number">1200.0</span>));<br><br>    <span class="hljs-comment">// 打开跟踪数据</span><br>    AsciiTraceHelper ascii;<br>    csma.EnableAsciiAll (ascii.CreateFileStream (<span class="hljs-string">&quot;MyRip.tr&quot;</span>));<br>    csma.EnablePcapAll (<span class="hljs-string">&quot;MyRip&quot;</span>, <span class="hljs-literal">true</span>);<br><br>    <span class="hljs-comment">// 定时断开C和E之间的连接</span><br>    Simulator::Schedule (Seconds (<span class="hljs-number">30</span>), &amp;TearDownLink, c, e, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>);<br><br>    <span class="hljs-comment">// 固定结点</span><br>    AnimationInterface::SetConstantPosition(b, <span class="hljs-number">10.0</span>, <span class="hljs-number">10.0</span>);<br>    AnimationInterface::SetConstantPosition(c, <span class="hljs-number">20.0</span>, <span class="hljs-number">10.0</span>);<br>    AnimationInterface::SetConstantPosition(a, <span class="hljs-number">10.0</span>, <span class="hljs-number">20.0</span>);<br>    AnimationInterface::SetConstantPosition(d, <span class="hljs-number">10.0</span>, <span class="hljs-number">30.0</span>);<br>    AnimationInterface::SetConstantPosition(e, <span class="hljs-number">20.0</span>, <span class="hljs-number">30.0</span>);<br>    AnimationInterface::SetConstantPosition(f, <span class="hljs-number">30.0</span>, <span class="hljs-number">30.0</span>);<br>    AnimationInterface::SetConstantPosition(pc1, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>);<br>    AnimationInterface::SetConstantPosition(pc2, <span class="hljs-number">40.0</span>, <span class="hljs-number">20.0</span>);<br>    <span class="hljs-comment">// NetAnim可视化</span><br>    <span class="hljs-comment">// AnimationInterface anim(&quot;MyRip.xml&quot;);</span><br><br>    <span class="hljs-comment">/* Now, do the actual simulation. */</span><br>    NS_LOG_INFO (<span class="hljs-string">&quot;Run Simulation.&quot;</span>);<br>    Simulator::Stop (Seconds (<span class="hljs-number">1200.0</span>));<br>    Simulator::Run ();<br>    Simulator::Destroy ();<br>    NS_LOG_INFO (<span class="hljs-string">&quot;Done.&quot;</span>);<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h3><ol><li><p>构建的拓扑</p><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21-01-14/ns3-2.png" alt=""></p></li><li><p>未建立连接</p><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21-01-14/ns3-3.png" alt=""></p></li><li><p>连接建立</p><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21-01-14/ns3-4.png" alt=""></p></li><li><p>坏消息</p><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21-01-14/ns3-5.png" alt=""></p></li><li><p>新的连接</p><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21-01-14/ns3-6.png" alt=""></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> ns3 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于UDP &amp; python的网络聊天室</title>
      <link href="posts/30c6e0c6/"/>
      <url>posts/30c6e0c6/</url>
      
        <content type="html"><![CDATA[<h3 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h3><ol><li>服务端：开启聊天室，向客户机发送消息并转发客户机的消息给聊天室的其他客户机</li><li>客户端：加入聊天室，输入有效用户名，开始聊天</li></ol><h3 id="python代码"><a href="#python代码" class="headerlink" title="python代码"></a>python代码</h3><h4 id="client-py"><a href="#client-py" class="headerlink" title="client.py"></a>client.py</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> sys, threading<br><br><span class="hljs-comment"># 还需要更详细的错误处理</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">receive_message</span>():</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 客户端用recv接收数据，最大1024字节</span><br>            print(s.recv(<span class="hljs-number">1024</span>).decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br>        <span class="hljs-keyword">except</span>:<br>            <span class="hljs-keyword">break</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">send_message</span>():</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">try</span>:<br>            message = <span class="hljs-built_in">input</span>()<br>            <span class="hljs-comment"># 发送给服务器</span><br>            s.sendto((name + <span class="hljs-string">&#x27;:&#x27;</span> + message).encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>), server_socket)<br>            <span class="hljs-keyword">if</span> message == <span class="hljs-string">&quot;exit&quot;</span>:<br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">except</span> KeyboardInterrupt:<br>            <span class="hljs-comment"># 中断退出</span><br>            s.sendto((name + <span class="hljs-string">&#x27;:&#x27;</span> + <span class="hljs-string">&quot;exit&quot;</span>).encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>), server_socket)<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">except</span> socket.herror:<br><br>            <span class="hljs-keyword">break</span><br><br><br>s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)<br><br>server_ip = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入服务器的ip：&quot;</span>)<br>server_port = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入服务器绑定的端口号：&quot;</span>))<br>server_socket = (server_ip, server_port)<br><br>print(<span class="hljs-string">&#x27;&#x27;&#x27;----- 欢迎来到聊天室，退出聊天室请输入 &quot;exit&quot; -----&#x27;&#x27;&#x27;</span>)<br><br>name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;输入你的昵称：&quot;</span>)<br><span class="hljs-comment"># 向服务器发送新用户名</span><br>s.sendto(name.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>), server_socket)<br>receive = s.recv(<span class="hljs-number">1024</span>).decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><span class="hljs-comment"># 昵称重复时，服务器回复 &quot;NO&quot;</span><br><span class="hljs-keyword">while</span> receive == <span class="hljs-string">&quot;NO&quot;</span>:<br>    name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;该昵称已被使用，请重新输入：&quot;</span>)<br>    s.sendto(name.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>), server_socket)<br>    receive = s.recv(<span class="hljs-number">1024</span>).decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><br>print(<span class="hljs-string">&#x27;&#x27;&#x27;--------------- %s ---------------&#x27;&#x27;&#x27;</span> % name)<br><br><span class="hljs-comment"># 使用多线程收发信息</span><br>thread_receive = threading.Thread(target=receive_message, name = <span class="hljs-string">&quot;thread_receive&quot;</span>)<br>thread_send = threading.Thread(target=send_message, name=<span class="hljs-string">&quot;thread_send&quot;</span>)<br>thread_receive.start()<br>thread_send.start()<br>thread_send.join()<br><br><span class="hljs-comment"># 客户端关闭连接</span><br>s.close()<br>print(<span class="hljs-string">&quot;--------------- 连接关闭 ---------------&quot;</span>)<br><br></code></pre></td></tr></table></figure><h4 id="server-py"><a href="#server-py" class="headerlink" title="server.py"></a>server.py</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># !/usr/bin/env python3</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-keyword">import</span> socket<br><br><span class="hljs-comment"># 创建socket对象</span><br>s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)  <span class="hljs-comment"># 套接字类型为无连接的UDP</span><br><br><span class="hljs-comment"># 使用本机ip</span><br>server_ip = socket.gethostbyname(socket.gethostname())<br>server_port = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入要绑定的端口号：&quot;</span>))<br><br><span class="hljs-comment"># 绑定端口</span><br>print(<span class="hljs-string">&quot;server&quot;</span> + server_ip + <span class="hljs-string">&#x27;:&#x27;</span> + <span class="hljs-built_in">str</span>(server_port))<br>s.bind((server_ip, server_port))<br><br><span class="hljs-comment"># 所有用户</span><br><span class="hljs-comment"># 用户名：socket</span><br>users = &#123;&#125;<br><br><span class="hljs-comment"># 添加异常处理！！</span><br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 服务器端调用recvfrom接收数据，最大1024字节</span><br>    <span class="hljs-keyword">try</span>:<br>        data, address = s.recvfrom(<span class="hljs-number">1024</span>)<br>    <span class="hljs-keyword">except</span>:<br>        print(<span class="hljs-string">&quot;recvfrom异常，服务器关闭&quot;</span>)<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">else</span>:<br>        print(<span class="hljs-string">&#x27;Received from %s:%s.&#x27;</span> % address)<br>        <span class="hljs-comment"># 将要广播的消息</span><br>        broadcast = <span class="hljs-string">b&quot;&quot;</span><br>        <span class="hljs-comment"># 检查所有用户数据，判断是否为新用户</span><br>        <span class="hljs-keyword">if</span> address <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> users.values():<br>            <span class="hljs-comment"># 检查用户名存在性（新用户只发送名字）</span><br>            <span class="hljs-keyword">if</span> data.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">in</span> users.keys():<br>                <span class="hljs-comment"># 发送失败消息</span><br>                s.sendto(<span class="hljs-string">b&quot;NO&quot;</span>, address)<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">else</span>:<br>                s.sendto(<span class="hljs-string">b&quot;YES&quot;</span>, address)<br>            <span class="hljs-comment"># 通知所有人新用户上线</span><br>            broadcast = (<span class="hljs-string">&quot;欢迎 &quot;</span> + data.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>) + <span class="hljs-string">&quot; 进入聊天室...&quot;</span>).encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>            <span class="hljs-comment"># 加入用户信息</span><br>            users[data.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)] = address<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 分割消息</span><br>            name, message = data.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>).split(<span class="hljs-string">&#x27;:&#x27;</span>, <span class="hljs-number">1</span>)<br>            <span class="hljs-comment"># 用户退出消息</span><br>            <span class="hljs-keyword">if</span> message == <span class="hljs-string">&quot;exit&quot;</span>:<br>                broadcast = (name + <span class="hljs-string">&quot;退出聊天室...&quot;</span>).encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>                <span class="hljs-keyword">del</span> users[name]<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 普通消息</span><br>                broadcast = (name + <span class="hljs-string">&quot; : &quot;</span> + message).encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>        <span class="hljs-comment"># 向(除发送方外的)客户发送响应</span><br>        <span class="hljs-keyword">for</span> addr <span class="hljs-keyword">in</span> users.values():<br>            <span class="hljs-keyword">if</span> addr != address:<br>                s.sendto(broadcast, addr)<br><br>s.close()<br><br></code></pre></td></tr></table></figure><h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h3><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21-01-14/python1.png" alt=""></p><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21-01-14/python2.png" alt=""></p><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21-01-14/python3.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOSBOX设置分辨率和启动时执行命令</title>
      <link href="posts/53af9b56/"/>
      <url>posts/53af9b56/</url>
      
        <content type="html"><![CDATA[<p>我的DOSBOX版本是0.74，在DOSBOX安装目录下找到<code>DOSBox 0.74 Options.bat</code>，双击运行后会打开配置文件</p><h3 id="分辨率设置"><a href="#分辨率设置" class="headerlink" title="分辨率设置"></a>分辨率设置</h3><p>最开头的<code>[sdl]</code>下面是分辨率相关设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">fullscreen=<span class="hljs-literal">false</span><br>fulldouble=<span class="hljs-literal">false</span><br>fullresolution=original<br>windowresolution=800x600<br>output=opengl<br></code></pre></td></tr></table></figure><h3 id="启动时运行命令"><a href="#启动时运行命令" class="headerlink" title="启动时运行命令"></a>启动时运行命令</h3><p>最底部的<code>[autoexec]</code>下面是启动时自动运行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">mount c: d:\asm<br>c:<br></code></pre></td></tr></table></figure><p>这样DOSBOX启动时会自动将C盘挂载到D:\ASM，并切换到挂载后的C盘，也就是D:\ASM</p><p>之后的汇编源文件就放在D:\ASM目录下</p><h3 id="用脚本编译"><a href="#用脚本编译" class="headerlink" title="用脚本编译"></a>用脚本编译</h3><p>在DOSBOX中正常编译流程是先masm再link，中间还会有许多选项。为了方便编译，可以在D:\ASM目录下新建文本文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">masm %1;<br>link %1;<br></code></pre></td></tr></table></figure><p>然后另存为<code>build.bat</code></p><p>比如编译<code>test.asm</code>，只需要在DOSBOX的命令行中输入<code>build test</code>即可</p>]]></content>
      
      
      <categories>
          
          <category> Assembly </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言弹跳小球</title>
      <link href="posts/f0e93994/"/>
      <url>posts/f0e93994/</url>
      
        <content type="html"><![CDATA[<h3 id="实现功能："><a href="#实现功能：" class="headerlink" title="实现功能："></a>实现功能：</h3><ol><li>小球从一点开始运动，碰到边界后反弹</li><li>使用组合键<code>Ctrl + F</code>暂停、继续</li><li>使用组合键<code>Ctrl + X</code>退出</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br></pre></td><td class="code"><pre><code class="hljs assembly"> ; bouncing ball<br> ; masm 5.0<br>;***************************************************************<br>data_seg segment<br><br>    count       dw 1    ; count for a update deltatime<br>    count_max   equ 1<br>    <br>    old_cs1c    dw ?<br>    old_ip1c    dw ?<br>    <br>    origin_x    db ?    ; cursor original size<br>    origin_y    db ?<br>    <br>    v_x         db 1    ; velocity of ball<br>    v_y         db 2    ; <br>    <br>    stopped     db 0    ; flag of stopped<br>    <br>    ball_char   equ &#39;*&#39; ; character represents ball<br>    ball_attr   equ 0eh ; attribute of ball <br>    <br>    x_start     equ 4   ; start position<br>    y_start     equ 3<br>    x_min       equ 1   ; defination of moving area :  0-----&gt; y<br>    x_max       equ 20  ;                              |<br>    y_min       equ 1   ;                             \|<br>    y_max       equ 20  ;                              x<br>    <br>    code_ctrl   equ 1dh ; defination of key code<br>    code_f      equ 21h<br>    code_x      equ 2dh<br>    bit_ctrl    equ 04h<br>data_seg ends<br>;***************************************************************<br>stack_seg segment stack ; can&#39;t omit &#39;stack&#39;<br>            dw      100 dup(?)<br>        tos label   word<br>stack_seg ends<br>;***************************************************************<br>code_seg segment<br>;--------------------<br>main    proc    far<br>    assume  cs: code_seg, ss: stack_seg, ds: data_seg, es:data_seg <br>start:<br>;setup ss and sp<br>    mov ax, stack_seg<br>    mov ss, ax<br>    mov sp, offset tos<br>;setup stack for return<br>    ;push    ds<br>    ;sub     ax, ax<br>    ;push    ax<br>;setup ds and es<br>    mov ax, data_seg<br>    mov ds, ax<br>    mov es, ax<br>;main code<br><br>    ; save old timer interrupt vector<br>    mov al, 1ch<br>    mov ah, 35h<br>    int 21h<br>    mov old_cs1c, es<br>    mov old_ip1c, bx<br>    push ds<br>    ; set new timer interrupt vector<br>    mov dx, offset update<br>    mov ax, seg update<br>    mov ds, ax<br>    mov al, 1ch<br>    mov ah, 25h<br>    int 21h<br>    pop ds<br>    ; enable timer and keyboard interrupt<br>    in al, 21h<br>    and al, 11111100b<br>    out 21h, al<br>    sti<br>    ; clear screen<br>    call clear_scr<br>    <br>    ; save cursor original size<br>    mov bh, 0<br>    mov ah, 3<br>    int 10h<br>    mov origin_y, ch<br>    mov origin_x, cl<br>    <br>    ; hide cursor<br>    mov cx, 80h<br>    mov ah, 1<br>    int 10h <br>    <br>    ; set cursor position<br>    mov bh, 0   <br>    mov dh, x_min - 1 ; row and column<br>    mov dl, y_min - 1<br>    mov ah, 2<br>    int 10h<br>    ; draw moving area<br>    mov al, &#39;&#x3D;&#39; ; character<br>    mov bh, 0   ; page<br>    mov bl, 0dah<br>    mov cx, y_max - y_min + 3<br>    mov ah, 9 <br>    int 10h<br>    ; set cursor position<br>    mov bh, 0   <br>    mov dh, x_max + 1 ; row and column<br>    mov dl, y_min - 1<br>    mov ah, 2<br>    int 10h<br>    ; draw moving area<br>    mov al, &#39;&#x3D;&#39; ; character<br>    mov bh, 0   ; page<br>    mov bl, 0dah<br>    mov cx, y_max - y_min + 3<br>    mov ah, 9 <br>    int 10h<br>    <br>    ; set start position<br>    mov bh, 0   <br>    mov dh, x_start ; row and column<br>    mov dl, y_start<br>    mov ah, 2<br>    int 10h<br>    <br>main_loop:    <br>    <br>get_ctrl_f:<br>    ; get keyboard status<br>    mov ah, 2<br>    int 16h<br>    test al, bit_ctrl   ; if pressed ctrl<br>    jz main_loop<br>    ; is any key pressed<br>    mov ah, 0bh<br>    int 21h<br>    inc al<br>    jnz main_loop<br>    ; get another key<br>    mov ah, 0 <br>    int 16h<br>    cmp ah, code_x      ; if pressed x  &#x3D;&gt; exit<br>    je exit<br>    cmp ah, code_f      ; if pressed f  &#x3D;&gt; toggle stop<br>    jne main_loop<br>    mov al, 1<br>    xor stopped, al<br>    jmp main_loop<br>    <br>exit:<br>    call clear_scr<br>    ; restore old timer interrupt vector<br>    mov dx, old_ip1c<br>    mov ds, old_cs1c<br>    mov al, 1ch<br>    mov ah, 25h<br>    int 21h<br>    ; reset cursor<br>    mov ch, origin_y<br>    mov cl, origin_x<br>    mov ah, 1<br>    int 10h<br>    ; return<br>    mov ax, 4c00h<br>    int 21h<br>main    endp<br>;--------------------<br>update  proc    near<br>    ; frame update<br>    push ds<br>    push ax<br>    push bx<br>    push cx<br>    push dx<br>    <br>    mov ax, data_seg<br>    mov ds, ax<br>    sti<br>    cmp stopped, 1<br>    je update_exit<br>    dec count<br>    jnz update_exit<br>    mov count, count_max       ; update interval<br>    <br>    ; clear previous position<br>    mov al, &#39; &#39;     <br>    mov bh, 0       ; page<br>    mov bl, 0       ; attribute<br>    mov cx, 1       ; repeat times<br>    mov ah, 9       ; show char<br>    int 10h<br>    <br>    ; get current position dh, dl<br>    mov bh, 0       ; page<br>    mov ah, 3       ; get cursor position<br>    int 10h<br>    ; calculate next position<br>    cmp dh, x_min<br>    ja no_min_x<br>    neg v_x<br>no_min_x:<br>    cmp dh, x_max<br>    jb add_x<br>    neg v_x<br>add_x:<br>    add dh, v_x    <br><br>    cmp dl, y_min<br>    ja no_min_y<br>    neg v_y<br>no_min_y:<br>    cmp dl, y_max<br>    jb add_y<br>    neg v_y<br>add_y:<br>    add dl, v_y<br><br>    ; set new cursor position<br>    mov bh, 0 <br>    mov ah, 2<br>    int 10h<br>    ; show ball<br>    mov al, ball_char     <br>    mov bh, 0           ; page<br>    mov bl, ball_attr   ; attribute<br>    mov cx, 1           ; repeat times<br>    mov ah, 9           ; show character<br>    int 10h<br><br>update_exit:<br>    cli   <br>    pop dx<br>    pop cx<br>    pop bx<br>    pop ax<br>    pop ds<br>    iret <br>update  endp<br>;--------------------<br>clear_scr proc  near<br>    ; clear screen<br>    push ax<br>    push bx<br>    push cx<br>    push dx<br>    mov ah, 6   ; scroll up screen<br>    mov al, 0   ; blank screen<br>    mov bh, 7   ; blank line<br>    mov ch, 0   ; upper left row<br>    mov cl, 0   ; upper left column<br>    mov dh, 24  ; lower right row<br>    mov dl, 79  ; lower right column<br>    int 10h<br>    ; locate cursor to upper left<br>    mov bh, 0   ; page<br>    mov dx, 0   ; row and column<br>    mov ah, 2   ; locate cursor<br>    int 10h<br>    pop dx<br>    pop cx<br>    pop bx<br>    pop ax<br>    ret<br>clear_scr endp<br>;--------------------<br>code_seg ends<br>;***************************************************************<br>    end start<br></code></pre></td></tr></table></figure><h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><p><img src= "/mimg/PokeBall.PNG" data-lazy-src="https://cdn.jsdelivr.net/gh/1971489/Images/21-01-13/ball.gif" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Assembly </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="posts/d87f7e0c/"/>
      <url>posts/d87f7e0c/</url>
      
        <content type="html"><![CDATA[<p>test</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
